<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mega Chess: Color Fix</title>
    <style>
        /* --- STYLES --- */
        body { margin: 0; padding: 0; overflow: hidden; font-family: "Segoe UI", Arial, sans-serif; background: #eeeed2; user-select: none; }
        #canvas { display: block; cursor: grab; }
        #canvas:active { cursor: grabbing; }

        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.94);
            padding: 12px; border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            width: 380px;
            max-height: 95vh;
            overflow-y: auto;
            backdrop-filter: blur(8px); z-index: 10;
            transition: opacity 0.3s;
            display: flex; flex-direction: column; gap: 10px;
        }
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 4px; }
        #controls::-webkit-scrollbar-thumb { background: #bbb; border-radius: 4px; }

        #turnIndicator {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px);
            color: #333; padding: 8px 25px; border-radius: 50px; font-size: 20px;
            font-weight: bold; border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); pointer-events: none;
            display: flex; align-items: center; gap: 10px; transition: 0.3s; z-index: 10;
        }

        #loadingOverlay {
            position: absolute; bottom: 20px; right: 20px; width: 300px;
            background: rgba(0,0,0,0.8); display: none; padding: 15px; border-radius: 10px;
            flex-direction: column; justify-content: center; align-items: flex-start;
            z-index: 200; color: white; backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        .progress-bar { width: 100%; height: 6px; background: #444; border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.1s; }

        /* --- PROMOTION OVERLAY STYLES --- */
        #promotionOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center;
            z-index: 150; backdrop-filter: blur(8px); animation: fadeIn 0.3s;
        }
        .promo-card {
            background: white; padding: 25px; border-radius: 16px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 2px solid #3498db;
            width: 500px; max-height: 80vh; display: flex; flex-direction: column;
            animation: popIn 0.3s forwards;
        }
        .promo-header { font-size: 24px; margin-bottom: 15px; color: #2c3e50; font-weight: bold; }
        .promo-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 8px;
            overflow-y: auto; padding: 10px; border: 1px solid #eee; border-radius: 8px; background: #f9f9f9;
        }

        .promo-btn {
            font-size: 30px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
            padding: 5px;
            color: #000 !important;
            line-height: 1;
        }
        .promo-btn:hover { background: #e3f2fd; transform: scale(1.1); border-color: #3498db; }

        #gameOverOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center;
            z-index: 100; backdrop-filter: blur(5px); animation: fadeIn 0.5s;
        }
        .victory-card {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 4px solid #f1c40f;
            min-width: 300px; transform: scale(0.9); animation: popIn 0.3s forwards;
        }
        .victory-card h1 { margin: 0; color: #e74c3c; font-size: 48px; text-transform: uppercase; }
        .victory-card h2 { margin: 10px 0 30px 0; color: #2c3e50; font-size: 24px; }
        .victory-card .winner-icon { font-size: 60px; margin: 10px 0; display: block; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes popIn { to { transform: scale(1); } }

        h3 { margin: 0 0 5px 0; color: #2c3e50; font-size: 18px; border-bottom: 1px solid #ddd; padding-bottom: 8px; }
        .control-group { margin-bottom: 5px; }
        label { display: block; margin-bottom: 4px; font-size: 12px; font-weight: 700; color: #555; text-transform: uppercase; }
        input, button { width: 100%; padding: 6px; box-sizing: border-box; border-radius: 6px; border: 1px solid #ccc; font-size: 13px; }

        .btn-row { display: flex; gap: 4px; margin-top: 4px; }
        button { background: #769656; color: white; border: none; cursor: pointer; font-weight: 600; transition: 0.1s; }
        button:hover { background: #5d7c40; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        button.secondary { background: #9ca3af; }
        button.secondary:hover { background: #6b7280; }
        button.danger { background: #e74c3c; }
        button.danger:hover { background: #c0392b; }
        button.action { background: #f39c12; }
        button.action:hover { background: #d35400; }
        button.checkers { background: #8e44ad; }
        button.checkers:hover { background: #732d91; }
        button.classic { background: #3498db; }
        button.classic:hover { background: #2980b9; }
        button.undo-btn { background: #555; }
        button.undo-btn:hover { background: #333; }

        /* --- LOG STYLES --- */
         #logContainer {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-top: 5px;
            height: 140px;
            overflow-y: auto;
            position: relative;
        }
        #logContainer::-webkit-scrollbar { width: 6px; }
        #logContainer::-webkit-scrollbar-thumb { background: #ccc; }

        #logTable {
            width: 100%;
            border-collapse: collapse;
            font-family: "Segoe UI Mono", monospace;
            font-size: 12px;
            table-layout: fixed;
        }
        #logTable th {
            position: sticky; top: 0;
            background: #e0e0e0;
            color: #555;
            padding: 4px;
            font-size: 11px;
            z-index: 2;
            text-align: center;
            border-bottom: 1px solid #ccc;
        }
        #logTable td {
            padding: 3px 5px;
            border-bottom: 1px solid #f0f0f0;
            color: #333;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }
        #logTable tr:nth-child(even) { background: #f9f9f9; }
        
        .log-num { width: 30px; color: #999; font-weight: bold; border-right: 1px solid #eee; background: #fafafa; }
        .move-icon { font-weight: bold; color: #2c3e50; margin-right: 2px; }
        .move-cap { color: #c0392b; font-weight: bold; margin-left: 2px; font-size: 10px; }
        .move-coords { color: #444; }

        .piece-container { display: flex; flex-direction: column; gap: 8px; }
        .category-block { background: rgba(0,0,0,0.03); border-radius: 6px; padding: 6px; border: 1px solid rgba(0,0,0,0.05); }
        .grid-header { font-size: 11px; font-weight: bold; text-transform: uppercase; color: #666; margin-bottom: 4px; text-align: center; background: #e0e0e0; border-radius: 3px; padding: 2px; }
        .piece-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; }
        .piece-btn { aspect-ratio: 1; padding: 0; font-size: 22px; background: #fff; color: #333; border: 1px solid #ccc; cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: transform 0.1s, background 0.1s; }
        .piece-btn:hover { background: #fff; transform: scale(1.15); z-index: 5; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .piece-btn.selected { background: #769656; color: white; border-color: #4b6334; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        .piece-btn.eraser { background: #ffebee; color: #c0392b; border-color: #e74c3c; font-size: 18px; }
        .piece-btn.black-piece { background: #333; color: #eee; border-color: #000; }
        .piece-btn.black-piece:hover { background: #555; }

        .info-panel { margin-top: 10px; padding: 8px; background: rgba(241, 242, 246, 0.8); border-radius: 6px; font-size: 12px; color: #555; text-align: center;}
        #debug { position: absolute; top: 10px; right: 10px; color: #555; background: rgba(255,255,255,0.5); padding: 5px 10px; border-radius: 4px; font-family: monospace; pointer-events: none; z-index: 5; }

        .input-row { display: flex; gap: 5px; align-items: center; justify-content: space-between; margin-bottom: 5px;}
        .input-row input[type="number"] { width: 60px; }
        .input-row span { font-size: 12px; font-weight: bold; }
        input[type=range] { padding: 0; margin: 5px 0; }
        .separator { border-top: 1px dashed #ccc; margin: 5px 0; }
        .gen-panel { background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; border: 1px solid rgba(0,0,0,0.1); }

        #opt-warning { color: #d35400; font-weight: bold; display: none; margin-top: 5px; font-size: 11px; text-align: center;}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="loadingOverlay">
        <strong id="loadingText">Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ ÑĞ²Ñ–Ñ‚Ñƒ...</strong>
        <div class="progress-bar">
            <div id="loadingProgress" class="progress-fill"></div>
        </div>
        <div style="font-size: 10px; margin-top: 5px; color: #ccc">ĞĞ¿Ñ‚Ğ¸Ğ¼Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ...</div>
    </div>

    <!-- PROMOTION OVERLAY -->
    <div id="promotionOverlay">
        <div class="promo-card">
            <div class="promo-header">âœ¨ ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ âœ¨</div>
            <div id="promotionGrid" class="promo-grid">
                <!-- Buttons will be injected here -->
            </div>
            <div style="margin-top:10px; font-size:12px; color:#777;">ĞĞ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ Ğ½Ğ° Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ</div>
        </div>
    </div>

    <div id="turnIndicator">
        <span id="turnIcon" style="font-size: 30px;">â™”</span>
        <span id="turnText">Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ–</span>
    </div>

    <div id="gameOverOverlay">
        <div class="victory-card">
            <h1>ĞœĞĞ¢!</h1>
            <span class="winner-icon" id="winnerIcon">ğŸ†</span>
            <h2 id="winnerTxt">ĞŸĞµÑ€ĞµĞ¼Ğ¾Ğ³Ğ° Ğ‘Ñ–Ğ»Ğ¸Ñ…</h2>
            <button class="action" onclick="game.resetGame()">ğŸ”„ ĞĞ¾Ğ²Ğ° Ğ³Ñ€Ğ°</button>
        </div>
    </div>

    <div id="controls">
        <h3>ğŸš€ Mega Chess: Unlimited</h3>

        <div class="control-group">
            <label>Ğ Ğ¾Ğ·Ğ¼Ñ–Ñ€ Ğ´Ğ¾ÑˆĞºĞ¸:</label>
            <input type="number" id="boardSize" value="32" min="8" max="1000000">
            <div class="btn-row">
                <button class="secondary" onclick="game.setSize(100)">100</button>
                <button class="secondary" onclick="game.setSize(1000)">1K</button>
                <button class="secondary" onclick="game.setSize(50000)">50K</button>
                <button class="secondary" onclick="game.setSize(1000000)">1M</button>
            </div>
        </div>

        <div class="control-group gen-panel">
             <label>âš”ï¸ Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ:</label>
             <div class="input-row">
                 <span>Ğ—Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½Ñ (%):</span>
                 <input type="number" id="fillPercent" value="25" min="1" max="50">
             </div>
             <div class="input-row">
                <span>Ğ¤ĞµĞ½Ñ‚ĞµĞ·Ñ– %:</span>
                <span id="fantasyPercentDisplay">40%</span>
             </div>
             <input type="range" id="fantasyMix" min="0" max="100" value="40" step="10">

             <div class="btn-row">
                 <button class="classic" onclick="game.fillClassic()">â™Ÿï¸ ĞšĞ»Ğ°Ñ.</button>
                 <button class="action" onclick="game.fillFantasy()">ğŸ² ĞœÑ–ĞºÑ</button>
                 <button class="checkers" onclick="game.fillCheckers()">âšªâš« Ğ¨Ğ°ÑˆĞºĞ¸</button>
             </div>

        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>Ğ ĞµĞ¶Ğ¸Ğ¼Ğ¸:</label>
             <div class="btn-row">
                 <button class="undo-btn" onclick="game.undoMove()">â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ (Del)</button>
                 <button id="rulesBtn" onclick="game.toggleRules()">ğŸŸ¢ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°</button>
             </div>
             <div class="btn-row">
                 <button id="turnBtn" onclick="game.toggleTurnMode()">ğŸŸ¢ Ğ¥Ñ–Ğ´ (Ğ’ĞšĞ›)</button>
             </div>
        </div>

        <div class="control-group">
            <label>ğŸ“œ Ğ—Ğ°Ğ¿Ğ¸Ñ Ñ…Ğ¾Ğ´Ñ–Ğ²:</label>
            <div id="logContainer">
                <table id="logTable">
                    <thead>
                        <tr>
                            <th class="log-num">#</th>
                            <th>Ğ‘Ñ–Ğ»Ñ–</th>
                            <th>Ğ§Ğ¾Ñ€Ğ½Ñ–</th>
                        </tr>
                    </thead>
                    <tbody id="logTableBody">
                        <!-- Ğ¥Ğ¾Ğ´Ğ¸ Ğ±ÑƒĞ´ÑƒÑ‚ÑŒ Ñ‚ÑƒÑ‚ -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>ğŸ¨ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ (Ğ’ÑÑ– Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸):</label>
             <div id="pieceContainer" class="piece-container"></div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±: <span id="zoomDisplay">100%</span></label>
             <input type="range" id="zoomSlider" min="-3" max="2" step="0.01">
        </div>
        <div class="separator"></div>
        <div class="control-group">
            <label>ğŸ’¾ Ğ¤Ğ°Ğ¹Ğ» Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ—:</label>
            <div class="btn-row">
                <button class="action" onclick="game.saveGame()">ğŸ“¥ Ğ—Ğ±ĞµÑ€ĞµĞ³Ñ‚Ğ¸ (.json)</button>
                <button class="classic" onclick="document.getElementById('fileInput').click()">ğŸ“‚ Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸</button>
                <!-- ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ñ–Ğ½Ğ¿ÑƒÑ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ -->
                <input type="file" id="fileInput" style="display:none" accept=".json" onchange="game.loadGame(this)">
            </div>
        </div>
        <div class="btn-row">
            <button onclick="game.centerBoard()">ğŸ  Ğ¦ĞµĞ½Ñ‚Ñ€</button>
            <button class="danger" onclick="game.clear()">ğŸ—‘ï¸ ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚Ğ¸</button>
        </div>

        <div class="info-panel">
            <span id="coord">-</span> | Ğ¤Ñ–Ğ³ÑƒÑ€: <span id="count">Auto</span>
        </div>
    </div>

    <div id="debug">FPS: <span id="fps">60</span></div>

    <script>
        const PIECE_CATEGORIES = [
            { name: "Ğ†Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¸", bg: "#fff", items: [{ s: 'delete', t: 'Ğ“ÑƒĞ¼ĞºĞ°', c: 'eraser' }] },
            { name: "ĞšĞ»Ğ°ÑĞ¸ĞºĞ° (Ğ‘Ñ–Ğ»Ñ–)", bg: "#f0f0f0", items: [{s:'â™”',t:'ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ'}, {s:'â™•',t:'Ğ¤ĞµÑ€Ğ·ÑŒ'}, {s:'â™–',t:'Ğ¢ÑƒÑ€Ğ°'}, {s:'â™—',t:'Ğ¡Ğ»Ğ¾Ğ½'}, {s:'â™˜',t:'ĞšÑ–Ğ½ÑŒ'}, {s:'â™™',t:'ĞŸÑ–ÑˆĞ°Ğº'}] },
            { name: "ĞšĞ»Ğ°ÑĞ¸ĞºĞ° (Ğ§Ğ¾Ñ€Ğ½Ñ–)", bg: "#ddd", items: [{s:'â™š',t:'ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ', cls:'black-piece', color:'b'}, {s:'â™›',t:'Ğ¤ĞµÑ€Ğ·ÑŒ', cls:'black-piece', color:'b'}, {s:'â™œ',t:'Ğ¢ÑƒÑ€Ğ°', cls:'black-piece', color:'b'}, {s:'â™',t:'Ğ¡Ğ»Ğ¾Ğ½', cls:'black-piece', color:'b'}, {s:'â™',t:'ĞšÑ–Ğ½ÑŒ', cls:'black-piece', color:'b'}, {s:'â™Ÿ',t:'ĞŸÑ–ÑˆĞ°Ğº', cls:'black-piece', color:'b'}] },
            { name: "Ğ¨Ğ°ÑˆĞºĞ¸", bg: "#e0e0e0", items: [{s:'â›€',t:'Ğ‘Ñ–Ğ»Ğ° ÑˆĞ°ÑˆĞºĞ°', color:'w'}, {s:'â›',t:'Ğ‘Ñ–Ğ»Ğ° Ğ´Ğ°Ğ¼ĞºĞ°', color:'w'}, {s:'â›‚',t:'Ğ§Ğ¾Ñ€Ğ½Ğ° ÑˆĞ°ÑˆĞºĞ°', color:'b', cls:'black-piece'}, {s:'â›ƒ',t:'Ğ§Ğ¾Ñ€Ğ½Ğ° Ğ´Ğ°Ğ¼ĞºĞ°', color:'b', cls:'black-piece'}] },
            { name: "Mega: Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ğ¸", bg: "#e8daef", items: [{s:'ğŸš€',t:'Ğ Ğ°ĞºĞµÑ‚Ğ°'}, {s:'âš“',t:'Ğ¯ĞºÑ–Ñ€'}, {s:'ğŸ¹',t:'Ğ›ÑƒĞº'}, {s:'ğŸ£',t:'Ğ’ÑƒĞ´ĞºĞ°'}, {s:'ğŸ§œ',t:'Ğ ÑƒÑĞ°Ğ»ĞºĞ°'}, {s:'âš¡',t:'Ğ‘Ğ»Ğ¸ÑĞºĞ°Ğ²ĞºĞ°'}, {s:'ğŸ”±',t:'Ğ¢Ñ€Ğ¸Ğ·ÑƒĞ±'}, {s:'ğŸ¦¯',t:'Ğ¢Ñ€Ğ¾ÑÑ‚Ğ¸Ğ½Ğ°'}, {s:'ğŸ•¯ï¸',t:'Ğ¡Ğ²Ñ–Ñ‡ĞºĞ°'}, {s:'ğŸ“¼',t:'Ğ¢Ğ°Ğ½Ğº'}, {s:'ğŸ“œ',t:'Ğ¡ÑƒĞ²Ñ–Ğ¹'}, {s:'ğŸŒŠ',t:'Ğ¦ÑƒĞ½Ğ°Ğ¼Ñ–'}, {s:'ğŸ§¬',t:'Ğ”ĞĞš'}, {s:'ğŸ—¡ï¸',t:'ĞœĞµÑ‡'}] },
            { name: "Mega: Ğ¡Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ğ¸ (Ğ¢Ğ²Ğ°Ñ€Ğ¸Ğ½Ğ¸)", bg: "#d4e6f1", items: [{s:'ğŸ˜º',t:'ĞšÑ–Ñ‚'}, {s:'ğŸº',t:'Ğ’Ğ¾Ğ²Ğº'}, {s:'ğŸ¦Š',t:'Ğ›Ğ¸Ñ'}, {s:'ğŸ—',t:'ĞšĞ°Ğ±Ğ°Ğ½'}, {s:'ğŸ¦',t:'Ğ“Ğ¾Ñ€Ğ¸Ğ»Ğ°'}, {s:'ğŸƒ',t:'Ğ‘ÑƒĞ¹Ğ²Ğ¾Ğ»'}, {s:'ğŸŠ',t:'ĞšÑ€Ğ¾ĞºĞ¾Ğ´Ğ¸Ğ»'}, {s:'ğŸŒ',t:'Ğ Ğ°Ğ²Ğ»Ğ¸Ğº'}, {s:'ğŸ¦‘',t:'ĞšĞ°Ğ»ÑŒĞ¼Ğ°Ñ€'}, {s:'ğŸ™',t:'Ğ’Ğ¾ÑÑŒĞ¼Ğ¸Ğ½Ñ–Ğ³'}, {s:'ğŸ',t:'Ğ‘Ğ´Ğ¶Ğ¾Ğ»Ğ°'}, {s:'ğŸ¦‹',t:'ĞœĞµÑ‚ĞµĞ»Ğ¸Ğº'}, {s:'ğŸ«',t:'Ğ’ĞµÑ€Ğ±Ğ»ÑĞ´'}, {s:'ğŸ¦“',t:'Ğ—ĞµĞ±Ñ€Ğ°'}, {s:'ğŸ¦’',t:'Ğ–Ğ¸Ñ€Ğ°Ñ„Ğ°'}, {s:'ğŸ•',t:'ĞŸĞµÑ'}, {s:'ğŸ¦€',t:'ĞšÑ€Ğ°Ğ±'}, {s:'ğŸ†',t:'Ğ›ĞµĞ¾Ğ¿Ğ°Ñ€Ğ´'}, {s:'ğŸ¿ï¸',t:'Ğ‘Ñ–Ğ»ĞºĞ°'}, {s:'ğŸ¦‡',t:'ĞšĞ°Ğ¶Ğ°Ğ½'}, {s:'ğŸ¦—',t:'ĞšĞ¾Ğ½Ğ¸Ğº'}] },
            { name: "Mega: ĞšĞ¾Ğ¼Ğ±Ñ–Ğ½Ğ¾Ğ²Ğ°Ğ½Ñ– & Ğ Ğ¾Ğ»Ñ–", bg: "#f9e79f", items: [{s:'ğŸ',t:'Ğ†Ğ¼Ğ¿ĞµÑ€Ğ°Ñ‚Ñ€Ğ¸Ñ†Ñ'}, {s:'ğŸ‘¸',t:'ĞŸÑ€Ğ¸Ğ½Ñ†ĞµÑĞ°'}, {s:'ğŸº',t:'ĞĞ¼Ğ°Ğ·Ğ¾Ğ½ĞºĞ°'}, {s:'ğŸ‘®',t:'ĞŸĞ¾Ğ»Ñ–Ñ†Ñ–Ñ'}, {s:'ğŸ¤–',t:'Ğ Ğ¾Ğ±Ğ¾Ñ‚'}, {s:'ğŸ›¸',t:'ĞĞ›Ğ'}, {s:'ğŸ‡',t:'Ğ’ĞµÑ€ÑˆĞ½Ğ¸Ğº'}, {s:'ğŸŒªï¸',t:'Ğ¢Ğ¾Ñ€Ğ½Ğ°Ğ´Ğ¾'}, {s:'ğŸ§›',t:'Ğ’Ğ°Ğ¼Ğ¿Ñ–Ñ€'}, {s:'ğŸ’‚',t:'Ğ“Ğ²Ğ°Ñ€Ğ´Ñ–Ñ”Ñ†ÑŒ'}, {s:'ğŸ‘·',t:'Ğ‘ÑƒĞ´Ñ–Ğ²ĞµĞ»ÑŒĞ½Ğ¸Ğº'}, {s:'ğŸ§',t:'Ğ”Ğ¶Ğ¸Ğ½'}, {s:'ğŸ§š',t:'Ğ¤ĞµÑ'}, {s:'â˜€ï¸',t:'Ğ¡Ğ¾Ğ½Ñ†Ğµ'}, {s:'ğŸ§™',t:'ĞœĞ°Ğ³'}, {s:'ğŸ•µï¸',t:'Ğ¨Ğ¿Ğ¸Ğ³ÑƒĞ½'}, {s:'ğŸ¥‹',t:'Ğ¡Ğ°Ğ¼ÑƒÑ€Ğ°Ğ¹'}, {s:'ğŸ¥·',t:'ĞÑ–Ğ½Ğ´Ğ·Ñ'}, {s:'ğŸ‘¨',t:'Ğ§Ğ¾Ğ»Ğ¾Ğ²Ñ–Ğº'}, {s:'ğŸ¤´',t:'ĞŸÑ€Ğ¸Ğ½Ñ†'}, {s:'ğŸ‘¼',t:'ĞĞ½Ğ³ĞµĞ»'}] },
            { name: "Mega: ĞÑ€ÑĞµĞ½Ğ°Ğ» & ĞœĞ¾Ğ½ÑÑ‚Ñ€Ğ¸", bg: "#fadbd8", items: [{s:'ğŸ›¡ï¸',t:'Ğ©Ğ¸Ñ‚'}, {s:'ğŸ”ª',t:'ĞšĞ¸Ğ½Ğ´Ğ¶Ğ°Ğ»'}, {s:'ğŸ”¥',t:'Ğ’Ğ¾Ğ³Ğ¾Ğ½ÑŒ'}, {s:'ğŸ’§',t:'Ğ’Ğ¾Ğ´Ğ°'}, {s:'â„ï¸',t:'Ğ¡Ğ½Ñ–Ğ³'}, {s:'ğŸ§Ÿ',t:'Ğ—Ğ¾Ğ¼Ğ±Ñ–'}, {s:'ğŸª¨',t:'ĞšĞ°Ğ¼Ñ–Ğ½ÑŒ'}, {s:'ğŸ§¨',t:'Ğ”Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‚'}, {s:'ğŸ’£',t:'Ğ‘Ğ¾Ğ¼Ğ±Ğ°'}, {s:'âš—ï¸',t:'Ğ—Ñ–Ğ»Ğ»Ñ'}, {s:'ğŸ’',t:'ĞšÑ–Ğ»ÑŒÑ†Ğµ'}, {s:'ğŸ”®',t:'Ğ¡Ñ„ĞµÑ€Ğ°'}, {s:'ğŸ¦‚',t:'Ğ¡ĞºĞ¾Ñ€Ğ¿Ñ–Ğ¾Ğ½'}, {s:'ğŸ',t:'Ğ—Ğ¼Ñ–Ñ'}, {s:'ğŸ¦–',t:'Ğ¢Ñ–-Ğ ĞµĞºÑ'}, {s:'ğŸ¦ˆ',t:'ĞĞºÑƒĞ»Ğ°'}, {s:'ğŸ‘¾',t:'Ğ§ÑƒĞ¶Ğ¸Ğ¹'}, {s:'ğŸ‘º',t:'Ğ“Ğ¾Ğ±Ğ»Ñ–Ğ½'}, {s:'ğŸ²',t:'Ğ”Ñ€Ğ°ĞºĞ¾Ğ½'}, {s:'ğŸ¦„',t:'Ğ„Ğ´Ğ¸Ğ½Ğ¾Ñ€Ñ–Ğ³'}, {s:'ğŸ¦…',t:'Ğ“Ñ€Ğ¸Ñ„Ğ¾Ğ½'}, {s:'ğŸ•·ï¸',t:'ĞŸĞ°Ğ²ÑƒĞº'}, {s:'ğŸ¢',t:'Ğ§ĞµÑ€ĞµĞ¿Ğ°Ñ…Ğ°'}] },
            { name: "Mega: ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ñ–Ñ & ĞŸÑ€Ğ¸Ñ€Ğ¾Ğ´Ğ°", bg: "#d5f5e3", items: [{s:'ğŸŒµ',t:'ĞšĞ°ĞºÑ‚ÑƒÑ'}, {s:'ğŸ„',t:'Ğ“Ñ€Ğ¸Ğ±'}, {s:'ğŸŒ²',t:'Ğ”ĞµÑ€ĞµĞ²Ğ¾'}, {s:'ğŸ',t:'Ğ›Ğ¸ÑÑ‚'}, {s:'ğŸŒ‹',t:'Ğ’ÑƒĞ»ĞºĞ°Ğ½'}, {s:'ğŸŒ©ï¸',t:'Ğ“Ñ€Ğ¾Ğ·Ğ°'}, {s:'ğŸ§©',t:'ĞŸĞ°Ğ·Ğ»'}, {s:'ğŸ²',t:'ĞšÑƒĞ±Ğ¸Ğº'}, {s:'âš›ï¸',t:'ĞÑ‚Ğ¾Ğ¼'}, {s:'ğŸšœ',t:'Ğ¢Ñ€Ğ°ĞºÑ‚Ğ¾Ñ€'}, {s:'âš”ï¸',t:'ĞœĞµÑ‡Ñ–'}, {s:'ğŸ˜',t:'Ğ¡Ğ»Ğ¾Ğ½'}, {s:'ğŸŒ›',t:'ĞœÑ–ÑÑÑ†ÑŒ'}, {s:'â­',t:'Ğ—Ñ–Ñ€ĞºĞ°'}, {s:'ğŸª',t:'ĞŸĞ»Ğ°Ğ½ĞµÑ‚Ğ°'}, {s:'ğŸŒŒ',t:'Ğ“Ğ°Ğ»Ğ°ĞºÑ‚Ğ¸ĞºĞ°'}] }
        ];
const megaDefs = {
            'ğŸ•·ï¸': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide_jump', d:'knight'}] },
            'ğŸšœ': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1]]}] },
            'âš”ï¸': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸ˜': { t: 'complex', comps: [{t:'step', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸš€': { t: 'slide', dirs: [[0,-1]] },
            'âš“': { t: 'slide', dirs: [[0,1]] },
            'ğŸ¹': { t: 'slide', dirs: [[-1,-1],[1,-1]] },
            'ğŸ£': { t: 'slide', dirs: [[-1,1],[1,1]] },
            'ğŸ§œ': { t: 'slide', dirs: [[1,0],[-1,0]] },
            'âš¡': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'ğŸ¦¯': { t: 'slide', dirs: [[1,1],[-1,1],[1,-1],[-1,-1]], max: 2 },
            'ğŸ•¯ï¸': { t: 'slide', dirs: [[1,0],[-1,0],[0,1],[0,-1]], max: 3 },
            'ğŸ”±': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'ğŸŒŠ': { t: 'slide', dirs: [[0,-1]] },
            'ğŸ“œ': { t: 'slide', dirs: [[0,1]] },
            'ğŸ§¬': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'ğŸ—¡ï¸': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'ğŸŒµ': { t: 'step', dirs: 'king' },
            'ğŸ„': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'ğŸŒ²': { t: 'step', dirs: [[0,1],[0,-1]] },
            'ğŸ': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'ğŸŒ‹': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'ğŸŒ©ï¸': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'â„ï¸': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'ğŸ”¥': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]], mul:2}] },
            'ğŸ’§': { t: 'complex', comps: [{t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]], mul:2}] },
            'ğŸª¨': { t: 'none' },
            'ğŸ˜º': { t: 'jump', dirs: [[1,-2],[-1,-2]] },
            'ğŸº': { t: 'jump', dirs: 'knight' },
            'ğŸ¦Š': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'ğŸ—': { t: 'jump', dirs: [[0,-2]] },
            'ğŸ¦': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'ğŸƒ': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'ğŸŠ': { t: 'jump', dirs: [[3,3],[3,-3],[-3,3],[-3,-3]] },
            'ğŸŒ': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'ğŸ¦‘': { t: 'jump', dirs: [[4,0],[-4,0],[0,4],[0,-4]] },
            'ğŸ™': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[1,2],[1,-2],[-1,2],[-1,-2]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ğŸ¦‹': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ¢': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'ğŸ•': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'ğŸ¿ï¸': { t: 'jump', dirs: 'knight' },
            'ğŸ†': { t: 'slide', dirs: 'bishop' },
            'ğŸ¦“': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'ğŸ«': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'ğŸ¦’': { t: 'jump', dirs: [[4,1],[4,-1],[-4,1],[-4,-1],[1,4],[1,-4],[-1,4],[-1,-4]] },
            'ğŸ¦—': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0],[2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¦‡': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ¦€': { t: 'step', dirs: [[0,1],[0,-1],[2,0],[-2,0]] },
            'ğŸ§¨': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¦‚': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'step', d:[[0,1],[0,-1],[1,0],[-1,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ğŸ¦–': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ğŸ¦ˆ': { t: 'complex', comps: [{t:'slide', d:[[1,-1],[-1,-1]]}, {t:'slide', d:[[0,1]]}] },
            'ğŸ‘¾': { t: 'jump', dirs: [[1,3],[1,-3],[-1,3],[-1,-3],[3,1],[3,-1],[-3,1],[-3,-1]] },
            'ğŸ§Ÿ': { t: 'step', dirs: 'king' },
            'ğŸ‘º': { t: 'slide', dirs: 'bishop' },
            'ğŸ»': { t: 'step', dirs: 'king' },
            'ğŸ”®': { t: 'jump', dirs: [[2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ’': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,3],[3,-3],[-3,3],[-3,-3]]}] },
            'âš—ï¸': { t: 'jump', dirs: [[1,4],[1,-4],[-1,4],[-1,-4],[4,1],[4,-1],[-4,1],[-4,-1]] },
            'ğŸ’£': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0]] },
            'ğŸ§©': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ²': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[-2,-2]]}, {t:'jump', d:[[3,3],[-3,-3]]}] },
            'âš›ï¸': { t: 'jump', dirs: [[2,2],[-2,-2],[2,-2],[-2,2], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'ğŸ›¡ï¸': { t: 'step', dirs: [[1,0],[-1,0],[0,1],[0,-1]] },
            'ğŸ”ª': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ“¼': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ğŸ¤–': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'slide', d:[[1,1],[-1,1]]}] },
            'ğŸ›¸': { t: 'complex', comps: [{t:'slide', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸŒ›': { t: 'jump', dirs: [[2,3],[2,-3],[-2,3],[-2,-3],[3,2],[3,-2],[-3,2],[-3,-2]] },
            'â­': { t: 'jump', dirs: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2], [2,0],[-2,0],[0,2],[0,-2], [2,2],[-2,-2],[2,-2],[-2,2]] },
            'ğŸª': { t: 'jump', dirs: [[0,3],[0,-3],[3,0],[-3,0]] },
            'ğŸŒŒ': { t: 'jump', dirs: [[3,0],[-3,0],[0,3],[0,-3], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'ğŸ‘¨': { t: 'step', dirs: 'king' },
            'ğŸ‡': { t: 'complex', comps: [{t:'slide_jump', d:[[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'ğŸ‘¸': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸº': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] },
            'ğŸ‘®': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'ğŸŒªï¸': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ§›': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:[[3,0],[-3,0],[0,3],[0,-3]]}] },
            'ğŸ’‚': { t: 'step', dirs: [[0,-1],[1,0],[-1,0],[1,-1],[-1,-1],[1,1],[-1,1]] },
            'ğŸ‘·': { t: 'slide', dirs: 'rook', max: 2 },
            'ğŸ§': { t: 'slide', dirs: 'queen', max: 3 },
            'ğŸ§š': { t: 'slide', dirs: 'bishop', max: 2 },
            'â˜€ï¸': { t: 'slide', dirs: 'queen', max: 2 },
            'ğŸ§™': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]]}] },
            'ğŸ•µï¸': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ¥‹': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[1,-1],[-1,1]]}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'ğŸ¥·': { t: 'jump', dirs: [[1,1],[1,-1],[-1,1],[-1,-1], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¤´': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'rook'}] },
            'ğŸ‘¼': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'bishop'}] },
            'ğŸ¦„': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸ¦…': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'ğŸ²': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] }
        };

        const CHESS_SVGS = {
            'w_â™”': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#101010" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'w_â™•': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#101010" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'w_â™—': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#101010" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'w_â™˜': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#ffffff; stroke:#000000;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#ffffff; stroke:#000000;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#000000; stroke:#000000;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#000000; stroke:#000000;"/></g>`,
            'w_â™–': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#101010" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'w_â™™': `<g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`,
            'b_â™š': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#f9f9f9" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'b_â™›': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#f9f9f9" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'b_â™œ': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#f9f9f9" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'b_â™': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#f9f9f9" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'b_â™': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#000000; stroke:#ffffff;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#000000; stroke:#ffffff;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#ffffff; stroke:#ffffff;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#ffffff; stroke:#ffffff;"/></g>`,
            'b_â™Ÿ': `<g fill="#000" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`
        };

        const CLASSIC_MAP = {
            'â™”':'w_â™”', 'â™•':'w_â™•', 'â™–':'w_â™–', 'â™—':'w_â™—', 'â™˜':'w_â™˜', 'â™™':'w_â™™',
            'â™š':'b_â™š', 'â™›':'b_â™›', 'â™œ':'b_â™œ', 'â™':'b_â™', 'â™':'b_â™', 'â™Ÿ':'b_â™Ÿ'
        };
        const DIRS = {
            rook: [[0,1],[0,-1],[1,0],[-1,0]],
            bishop: [[1,1],[1,-1],[-1,1],[-1,-1]],
            queen: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            knight: [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]],
            king: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
        };

        const GRID_VOID = -999;

        class SmoothChess {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                this.boardSize = 32;
                this.cellSize = 60;

                this.camera = { x: 0, y: 0, zoom: 1 };
                this.targetZoom = 1;
                this.lerpFactor = 0.15;
                this.minZoom = 0.000001;
                this.maxZoom = 5.0;

                this.mouse = { x: 0, y: 0 };
                this.isDragging = false;
                this.isDraggingPiece = false;
                this.draggedPiece = null;
                this.lastMouse = { x: 0, y: 0 };
                this.isPainting = false;
                this.isGenerating = false;

                // --- PROMOTION STATE ---
                this.promotionPending = null;

                // --- KEYBOARD ---
                this.keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

                // Storage for MODIFIED pieces only.
                this.grid = new Map();

                // History for UNDO
                this.moveHistory = [];

                this.virtualGen = null;
                this.virtualProps = { percent: 25, mix: 0 };

                this.generationSeed = 0;

                this.palette = [];
                this.paletteMap = new Map();
                this.pieceCount = 0;
                this.kingPos = { w: null, b: null };

                this.curSymbol = 'â™”';
                this.curColor = 'w';

                this.rulesEnabled = true;
                this.turnModeEnabled = true;
                this.currentTurn = 'w';
                this.gameOver = false;
                this.multiJumpSource = null;

                this.highlightedMoves = [];
                this.kingsInCheck = { w: null, b: null };

                this.colors = {
                    light: '#eeeed2',
                    dark: 'rgba(80, 120, 60, 0.6)',
                    border: '#3a4a2b',
                    whiteP: '#ffffff',
                    blackP: '#000000',
                    neutralP: '#ffcc00',
                    highlight: 'rgba(0, 255, 0, 0.5)',
                    checkHighlight: 'rgba(255, 0, 0, 0.6)',
                    mateHighlight: 'rgba(75, 0, 130, 0.9)'
                };
                this.colors.void = this.colors.light;

                this.checkersSymbols = new Set(['â›€', 'â›', 'â›‚', 'â›ƒ']);
                this.spriteCache = new Map();
                this.lowResCache = new Map();
                this.spriteSize = 100;

                this.initUI();
                this.init();
                this.updateTurnIndicator();
            }

            initUI() {
                const container = document.getElementById('pieceContainer');
                container.innerHTML = '';

                PIECE_CATEGORIES.forEach(cat => {
                    const block = document.createElement('div');
                    block.className = 'category-block';
                    if(cat.bg) block.style.backgroundColor = cat.bg;
                    const header = document.createElement('div');
                    header.className = 'grid-header';
                    header.innerText = cat.name;
                    block.appendChild(header);
                    const grid = document.createElement('div');
                    grid.className = 'piece-grid';

                    cat.items.forEach(item => {
                        const btn = document.createElement('button');
                        btn.className = `piece-btn ${item.cls || ''}`;
                        if(item.s === 'delete') btn.classList.add('eraser');

                        btn.innerText = item.s;
                        btn.title = item.t;
                        btn.dataset.s = item.s;
                        btn.dataset.c = item.color || 'w';
                        btn.addEventListener('click', () => {
                            document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            this.curSymbol = btn.dataset.s;
                            this.curColor = btn.dataset.c;
                        });
                        if(item.s === 'â™”' && item.color !== 'b') btn.classList.add('selected');
                        grid.appendChild(btn);
                    });
                    block.appendChild(grid);
                    container.appendChild(block);
                });
            }

            init() {
                this.setSize(32);
                this.resize();
                window.addEventListener('resize', () => { this.resize(); });
                this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
                this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
                window.addEventListener('mousemove', e => this.onMouseMove(e));
                window.addEventListener('mouseup', e => this.onMouseUp(e));
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());

                window.addEventListener('keydown', e => {
                    if (e.key === 'Delete') {
                        this.undoMove();
                    } else {
                        this.onKeyDown(e);
                        if(this.keys.hasOwnProperty(e.code)) {
                            this.keys[e.code] = true;
                            e.preventDefault();
                        }
                    }
                });
                window.addEventListener('keyup', e => {
                    if(this.keys.hasOwnProperty(e.code)) this.keys[e.code] = false;
                });

                document.getElementById('boardSize').addEventListener('change', e => this.setSize(e.target.value));
                document.getElementById('zoomSlider').addEventListener('input', e => {
                    this.targetZoom = Math.pow(10, parseFloat(e.target.value));
                });
                document.getElementById('fantasyMix').addEventListener('input', (e) => {
                    document.getElementById('fantasyPercentDisplay').innerText = e.target.value + '%';
                });

                this.lastTime = performance.now();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.centerBoard();
            }

            getPaletteId(s, c) {
                const key = s + c;
                if (!this.paletteMap.has(key)) {
                    this.palette.push({ s, c });
                    this.paletteMap.set(key, this.palette.length);
                }
                return this.paletteMap.get(key);
            }

            getKey(c, r) {
                return c + "," + r;
            }

            getCoordString(c, r) {
                let label = "";
                let index = c + 1;
                while (index > 0) {
                    let rem = (index - 1) % 26;
                    label = String.fromCharCode(97 + rem) + label;
                    index = Math.floor((index - 1) / 26);
                }
                return label + (this.boardSize - r);
            }

            addLogToUI(pieceIcon, startCoord, endCoord, isCapture) {
                const list = document.getElementById('logList');
                // Remove default placeholder if exists
                if (list.children.length === 1 && list.children[0].innerText === 'Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ”') {
                    list.innerHTML = '';
                }

                const div = document.createElement('div');
                div.className = 'log-entry';

                const moveText = `<span class="move">${pieceIcon}</span> ${startCoord} â†’ ${endCoord}`;
                const capText = isCapture ? `<span class="capture">âš”ï¸</span>` : '';

                div.innerHTML = `${moveText} ${capText}`;
                list.prepend(div); // Newest first
            }

            removeLastLogEntry() {
                const list = document.getElementById('logList');
                if (list.children.length > 0) {
                    list.removeChild(list.firstElementChild);
                }
                if (list.children.length === 0) {
                    list.innerHTML = '<div class="log-entry" style="color:#999; justify-content:center;">Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ”</div>';
                }
            }

            setSize(n) {
                this.boardSize = Math.max(8, parseInt(n));
                if (this.boardSize > 1000000) this.boardSize = 1000000;
                document.getElementById('boardSize').value = this.boardSize;

                this.grid.clear();
                this.moveHistory = [];
                this.virtualGen = null;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';

                this.resetGame();
                this.centerBoard();
            }

            centerBoard() {
                const boardPx = this.boardSize * this.cellSize;
                const screenW = this.canvas.width;
                const screenH = this.canvas.height;
                const fitScaleX = screenW / boardPx;
                const fitScaleY = screenH / boardPx;
                const fitZoom = Math.min(fitScaleX, fitScaleY);
                this.minZoom = Math.max(0.0000001, fitZoom * 0.1);
                this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, fitZoom * 0.9));
                this.camera.zoom = this.targetZoom;
                this.camera.x = (screenW - boardPx * this.camera.zoom) / 2;
                this.camera.y = (screenH - boardPx * this.camera.zoom) / 2;
            }

            clampCamera() {
                // Allows panning freely on large boards
            }

            onWheel(e) {
                if (this.promotionPending) return;
                e.preventDefault();
                const sensitivity = 0.0015;
                let newZoom = this.targetZoom * (1 - e.deltaY * sensitivity);
                newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));
                this.targetZoom = newZoom;
            }

            isDarkSquare(c, r) { return (c + r) % 2 !== 0; }

            getPieceSprite(symbol, color) {
                const key = `${symbol}_${color}`;
                if (this.spriteCache.has(key)) return this.spriteCache.get(key);

                // Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑƒÑ”Ğ¼Ğ¾ Ñ€Ğ¾Ğ·Ğ´Ñ–Ğ»ÑŒĞ½Ñƒ Ğ·Ğ´Ğ°Ñ‚Ğ½Ñ–ÑÑ‚ÑŒ Ğ´Ğ»Ñ Ñ‡Ñ–Ñ‚ĞºĞ¾ÑÑ‚Ñ–
                this.spriteSize = 256;

                const c = document.createElement('canvas');
                c.width = this.spriteSize;
                c.height = this.spriteSize;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();

                    // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ width/height Ñ– viewBox 0 0 45 45, Ñ‰Ğ¾Ğ± Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ñ€Ğ¾Ğ·Ñ‚ÑĞ³Ğ½ÑƒĞ»Ğ°ÑÑŒ Ğ½Ğ° Ğ²ĞµÑÑŒ ÑĞ¿Ñ€Ğ°Ğ¹Ñ‚
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${this.spriteSize}" height="${this.spriteSize}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0, 0, this.spriteSize, this.spriteSize);
                        ctx.drawImage(img, 0, 0, this.spriteSize, this.spriteSize);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;

                } else {
                    // Ğ”Ğ»Ñ Ñ„ĞµĞ½Ñ‚ĞµĞ·Ñ– Ñ„Ñ–Ğ³ÑƒÑ€
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `bold ${this.spriteSize * 0.8}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.lineWidth = this.spriteSize * 0.05; ctx.lineJoin = 'round';
                    const cx = this.spriteSize / 2; const cy = this.spriteSize / 2 * 1.1;

                    if (isWhite) ctx.strokeStyle = '#000000';
                    else if (isBlack) ctx.strokeStyle = '#ffffff';
                    else ctx.strokeStyle = '#333333';

                    ctx.strokeText(symbol, cx, cy);
                    ctx.fillStyle = isWhite ? this.colors.whiteP : (isBlack ? this.colors.blackP : this.colors.neutralP);
                    ctx.fillText(symbol, cx, cy);
                }

                this.spriteCache.set(key, c);
                return c;
            }

            getLowResSprite(symbol, color) {
                const key = `${symbol}_${color}_lo`;
                if (this.lowResCache.has(key)) return this.lowResCache.get(key);

                // Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑƒÑ”Ğ¼Ğ¾ ÑĞºÑ–ÑÑ‚ÑŒ "Ğ½Ğ¸Ğ·ÑŒĞºĞ¾Ñ— Ñ€Ğ¾Ğ·Ğ´Ñ–Ğ»ÑŒĞ½Ğ¾Ñ— Ğ·Ğ´Ğ°Ñ‚Ğ½Ğ¾ÑÑ‚Ñ–"
                const size = 128;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();
                    // Ğ¢ĞµĞ¶ ÑĞ°Ğ¼Ğµ: Ñ„Ñ–ĞºÑÑƒÑ”Ğ¼Ğ¾ Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€ SVG Ğ¿Ñ–Ğ´ ĞºĞ°Ğ½Ğ²Ğ°Ñ
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0,0,size,size);
                        ctx.drawImage(img, 0, 0, size, size);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;
                } else {
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `${size}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    const cx = size / 2; const cy = size / 2 * 1.1;
                    ctx.fillStyle = isWhite ? '#fff' : (isBlack ? '#000' : '#fa0');
                    ctx.fillText(symbol, cx, cy);
                }

                this.lowResCache.set(key, c);
                return c;
            }

            pseudoRandom(x, y) {
                return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
            }

            getPiece(c, r) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return null;

                const key = this.getKey(c, r);
                const val = this.grid.get(key);

                if (val !== undefined) {
                    if (val === GRID_VOID) return null;
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    return { x: c, y: r, s: p.s, c: p.c, hasMoved: hasMoved };
                }

                if (this.virtualGen) {
                    return this.getVirtualPiece(c, r);
                }

                return null;
            }

            getVirtualPiece(c, r) {
                if (this.virtualGen === 'checkers') {
                     const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                     const armyHeight = rowsCalc;
                     if (!this.isDarkSquare(c, r)) return null;

                     if (r < armyHeight) return { x:c, y:r, s:'â›‚', c:'b' };
                     if (r >= this.boardSize - armyHeight) return { x:c, y:r, s:'â›€', c:'w' };
                     return null;
                }

                const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                const armyHeight = Math.max(2, rowsCalc);
                const whiteStart = this.boardSize - armyHeight;

                let relativeRow = -1;
                let color = '';

                // Identify if this row belongs to an army and normalize row index
                if (r < armyHeight) {
                    color = 'b';
                    relativeRow = r;
                } else if (r >= whiteStart) {
                    color = 'w';
                    relativeRow = (this.boardSize - 1) - r; // Mirror row index
                } else {
                    return null;
                }

                return this.generateProceduralPiece(c, relativeRow, color, armyHeight);
            }

            generateProceduralPiece(c, relativeRow, color, height) {
                // King Safety: Always King at middle column, back rank
                const kingCol = Math.floor(this.boardSize / 2);
                if (c === kingCol && relativeRow === 0) {
                    return { x: c, y: -1, s: color === 'b' ? 'â™š' : 'â™”', c: color };
                }

                // Pawns: Front line (normalized row = height - 1)
                if (relativeRow === height - 1) {
                    return { x: c, y: -1, s: color === 'b' ? 'â™Ÿ' : 'â™™', c: color };
                }

                const classicMajors = ['â™–', 'â™˜', 'â™—', 'â™•'];
                const mirrorMap = { 'â™–': 'â™œ', 'â™˜': 'â™', 'â™—': 'â™', 'â™•': 'â™›' };
                const fantasyMajors = ['ğŸ¦„', 'ğŸ¦…', 'ğŸ²', 'ğŸ•·ï¸', 'ğŸ¢', 'ğŸ§¨', 'ğŸ«', 'ğŸ¦“', 'ğŸ¦’', 'ğŸ˜', 'ğŸšœ', 'âš”ï¸', 'ğŸ›¡ï¸', 'ğŸ‘¨', 'ğŸ¦—', 'ğŸ¦‡', 'ğŸ¹', 'ğŸ»', 'ğŸ•', 'ğŸ¦€', 'ğŸ†', 'ğŸ¿ï¸', 'ğŸ¤´', 'ğŸ‘¼', 'ğŸ‘º', 'ğŸ„', 'ğŸŒµ', 'ğŸŒ²', 'ğŸ', 'ğŸŒ‹', 'ğŸŒŠ', 'ğŸŒªï¸', 'ğŸŒ©ï¸', 'ğŸ¦‚', 'ğŸ', 'ğŸ¦–', 'ğŸ¦ˆ', 'ğŸ', 'ğŸ¦‹', 'ğŸ™', 'ğŸ‘¾', 'ğŸ—¡ï¸', 'ğŸ”®', 'ğŸ“œ', 'ğŸ’', 'âš—ï¸', 'ğŸ’£', 'ğŸ§©', 'ğŸ²', 'ğŸ§¬', 'âš›ï¸', ...Object.keys(megaDefs)];

                // Use seed based on COLUMN and RELATIVE_ROW.
                const seed = c * 49297 + relativeRow * 9301 + this.generationSeed;
                const rnd = Math.abs(Math.sin(seed) * 10000) % 100;

                let symbol;

                if (this.virtualGen === 'fantasy' && rnd < this.virtualProps.mix) {
                    // Fantasy Piece
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 5) * fantasyMajors.length);
                    symbol = fantasyMajors[idx];
                } else {
                    // Classic Piece
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 7) * classicMajors.length);
                    let base = classicMajors[idx];
                    // Apply color mapping for Classic
                    if (color === 'b') symbol = mirrorMap[base];
                    else symbol = base;
                }

                return { x: c, y: -1, s: symbol, c: color };
            }

            setPiece(c, r, data) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return;
                const key = this.getKey(c, r);

                if (!data) {
                    if (this.virtualGen) {
                        this.grid.set(key, GRID_VOID);
                    } else {
                        this.grid.delete(key);
                    }
                    return;
                }

                const paletteId = this.getPaletteId(data.s, data.c);
                const hasMovedBit = (data.hasMoved ? 1 : 0) << 16;
                this.grid.set(key, paletteId | hasMovedBit);

                if (data.s === 'â™”' && data.c === 'w') this.kingPos.w = {c, r};
                if (data.s === 'â™š' && data.c === 'b') this.kingPos.b = {c, r};
            }

            removePiece(c, r) { this.setPiece(c, r, null); }
            
            updateLogUI() {
                const tbody = document.getElementById('logTableBody');
                if (!tbody) return;
                tbody.innerHTML = '';
                
                let moveCount = 1;
                let currentRow = null;

                this.moveHistory.forEach((step) => {
                    const not = step.notation;
                    if (!not) return; // ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ ÑÑ‚Ğ°Ñ€Ñ–/Ğ±Ğ¸Ñ‚Ñ– Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸

                    const moveHTML = `<span class="move-icon">${not.icon}</span><span class="move-coords">${not.start}â†’${not.end}</span>${not.cap ? '<span class="move-cap">x</span>' : ''}`;

                    if (step.turn === 'w') {
                        // Ğ¥Ñ–Ğ´ Ğ±Ñ–Ğ»Ğ¸Ñ… - ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ”Ğ¼Ğ¾ Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ñ€ÑĞ´Ğ¾Ğº
                        currentRow = document.createElement('tr');
                        currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>${moveHTML}</td><td></td>`;
                        tbody.appendChild(currentRow);
                    } else {
                        // Ğ¥Ñ–Ğ´ Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ…
                        if (!currentRow) {
                            // Ğ¯ĞºÑ‰Ğ¾ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ğ¿Ğ¾Ñ‡Ğ°Ğ»Ğ°ÑÑ Ğ· Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ… (Ñ€Ñ–Ğ´ĞºÑ–ÑĞ½Ğ¸Ğ¹ Ğ²Ğ¸Ğ¿Ğ°Ğ´Ğ¾Ğº)
                            currentRow = document.createElement('tr');
                            currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>...</td><td></td>`;
                            tbody.appendChild(currentRow);
                        }
                        currentRow.children[2].innerHTML = moveHTML;
                        moveCount++;
                        currentRow = null;
                    }
                });
                
                // ĞŸÑ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ° Ğ²Ğ½Ğ¸Ğ·
                const container = document.getElementById('logContainer');
                if(container) container.scrollTop = container.scrollHeight;
            }

            resetGame() {
                this.grid.clear();
                this.moveHistory = [];
                this.pieceCount = 0;
                this.currentTurn = 'w'; this.gameOver = false;
                this.multiJumpSource = null;
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.updateUI(); 
                this.updateTurnIndicator();
                this.updateLogUI(); // <--- Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ–
            }

            fillCheckers() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.virtualGen = 'checkers';
                this.virtualProps.percent = percent;
                this.updateUI();
            }

            fillClassic() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'classic';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = 0;
                this.updateUI();
            }

            fillFantasy() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                let mix = parseFloat(document.getElementById('fantasyMix').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'fantasy';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = mix;
                this.updateUI();
            }

            clear() {
                this.virtualGen = null;
                this.resetGame();
            }

            saveGame() {
                const pieces = [];
                for (const [key, val] of this.grid) {
                    const coord = key.split(',').map(Number);
                    if (val === GRID_VOID) {
                        pieces.push({ x: coord[0], y: coord[1], void: true });
                        continue;
                    }
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    pieces.push({
                        x: coord[0], y: coord[1], s: p.s, c: p.c, m: hasMoved ? 1 : 0
                    });
                }

                const saveData = {
                    format: "MegaChess_v4_History", // ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ° Ğ²ĞµÑ€ÑÑ–Ñ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñƒ
                    timestamp: Date.now(),
                    boardSize: this.boardSize,
                    turn: this.currentTurn,
                    virtualGen: this.virtualGen,
                    virtualProps: this.virtualProps,
                    generationSeed: this.generationSeed,
                    moveHistory: this.moveHistory, // <-- Ğ”ĞĞ”ĞĞĞ Ğ¦Ğ•
                    pieces: pieces
                };

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(saveData));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                const date = new Date().toISOString().slice(0,10);
                downloadAnchorNode.setAttribute("download", `megachess_${this.boardSize}x_${date}.json`);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            loadGame(inputElement) {
                const file = inputElement.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.applyLoadedData(data);
                    } catch (err) {
                        alert("ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ñ„Ğ°Ğ¹Ğ»Ñƒ! ĞŸĞµÑ€ĞµĞºĞ¾Ğ½Ğ°Ğ¹Ñ‚ĞµÑÑ, Ñ‰Ğ¾ Ñ†Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¸Ğ¹ JSON.");
                        console.error(err);
                    }
                    inputElement.value = '';
                };
                reader.readAsText(file);
            }

            applyLoadedData(data) {
                this.grid.clear();
                this.moveHistory = [];
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;

                if (data.boardSize) {
                    document.getElementById('boardSize').value = data.boardSize;
                    this.boardSize = data.boardSize;
                }

                this.virtualGen = data.virtualGen || null;
                if (data.virtualProps) this.virtualProps = data.virtualProps;
                if (data.generationSeed) this.generationSeed = data.generationSeed;

                this.currentTurn = data.turn || 'w';

                // 1. Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ„Ñ–Ğ³ÑƒÑ€
                if (Array.isArray(data.pieces)) {
                    data.pieces.forEach(p => {
                        if (p.x >= 0 && p.x < this.boardSize && p.y >= 0 && p.y < this.boardSize) {
                            if (p.void) {
                                this.grid.set(this.getKey(p.x, p.y), GRID_VOID);
                            } else {
                                this.setPiece(p.x, p.y, { s: p.s, c: p.c, hasMoved: !!p.m });
                            }
                        }
                    });
                }

                // 2. Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ñ‚Ğ° Ğ²Ñ–Ğ´Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ² Ğ»Ğ¾Ğ·Ñ–
                const logList = document.getElementById('logList');
                logList.innerHTML = ''; // ĞÑ‡Ğ¸Ñ‰ÑƒÑ”Ğ¼Ğ¾ Ğ»Ğ¾Ğ³ Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½ÑĞ¼

                if (data.moveHistory && Array.isArray(data.moveHistory)) {
                    this.moveHistory = data.moveHistory;

                    // ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¿Ğ¾ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ñ– Ğ´Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ² UI
                    // Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾: addLogToUI Ğ´Ğ¾Ğ´Ğ°Ñ” Ğ·Ğ²ĞµÑ€Ñ…Ñƒ (prepend), Ñ‚Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¼Ğ°ÑĞ¸Ğ² Ğ²Ñ–Ğ´ Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºÑƒ Ğ´Ğ¾ ĞºÑ–Ğ½Ñ†Ñ
                    this.moveHistory.forEach(step => {
                        if (step.notation) {
                            this.addLogToUI(
                                step.notation.icon,
                                step.notation.start,
                                step.notation.end,
                                step.notation.cap
                            );
                        }
                    });
                } else {
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ğ½ĞµĞ¼Ğ°Ñ” (ÑÑ‚Ğ°Ñ€Ğ¸Ğ¹ Ñ„Ğ°Ğ¹Ğ»), Ğ¿Ğ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºÑƒ
                    logList.innerHTML = '<div class="log-entry" style="color:#999; justify-content:center;">Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ” (ĞĞ±Ğ¾ Ñ„Ğ°Ğ¹Ğ» Ğ±ĞµĞ· Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ—)</div>';
                }

                this.updateTurnIndicator();
                this.centerBoard();
                this.updateUI();

                // Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ğµ Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ½Ñ Ğ² Ğ»Ğ¾Ğ³ Ğ¿Ñ€Ğ¾ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğµ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.style.color = 'green';
                div.style.background = '#e8f5e9';
                div.innerText = `ğŸ“‚ Ğ¤Ğ°Ğ¹Ğ» Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ¾ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾`;
                logList.prepend(div);
            }

            getFileLabel(index) { let label = ""; index++; while (index > 0) { let rem = (index - 1) % 26; label = String.fromCharCode(97 + rem) + label; index = Math.floor((index - 1) / 26); } return label; }
            isPathClear(c1, r1, c2, r2) { const dx = Math.sign(c2 - c1); const dy = Math.sign(r2 - r1); let x = c1 + dx; let y = r1 + dy; while (x !== c2 || y !== r2) { if (this.getPiece(x,y)) return false; x += dx; y += dy; } return true; }

            getCheckersMoves(piece, cx, cy, onlyCaptures = false) {
                const moves = [];
                const captures = [];
                const isWhite = piece.c === 'w';
                const isKing = ['â›', 'â›ƒ'].includes(piece.s);
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                for (const d of dirs) {
                    if (!isKing) {
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;
                        if (landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);
                            if (enemy && enemy.c !== piece.c && !landing) {
                                captures.push({ c: landX, r: landY, isCapture: true, captured: {x: enemyX, y: enemyY} });
                            }
                        }
                        if (!onlyCaptures) {
                            const forward = isWhite ? -1 : 1;
                            if (d[1] === forward) {
                                if (enemyX >= 0 && enemyX < this.boardSize && enemyY >= 0 && enemyY < this.boardSize) {
                                     if (!this.getPiece(enemyX, enemyY)) {
                                         moves.push({ c: enemyX, r: enemyY });
                                     }
                                }
                            }
                        }
                    } else {
                        let dist = 1;
                        let foundEnemy = null;
                        while (true) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;
                            const target = this.getPiece(tx, ty);
                            if (!foundEnemy) {
                                if (target) {
                                    if (target.c !== piece.c) foundEnemy = { x: tx, y: ty };
                                    else break;
                                } else {
                                    if (!onlyCaptures) moves.push({ c: tx, r: ty });
                                }
                            } else {
                                if (target) break;
                                captures.push({ c: tx, r: ty, isCapture: true, captured: foundEnemy });
                            }
                            dist++;
                        }
                    }
                }
                if (captures.length > 0) return captures;
                return moves;
            }

            validateMove(piece, c1, r1, c2, r2, checkingAttack = false) {
                if (!this.rulesEnabled) return true;
                if (this.checkersSymbols.has(piece.s) && !checkingAttack) {
                    const legalMoves = this.generatePotentialMoves(piece, c1, r1);
                    return legalMoves.some(m => m.c === c2 && m.r === r2);
                }
                const dx = c2 - c1; const dy = r2 - r1;
                if (dx === 0 && dy === 0) return false;
                const target = this.getPiece(c2, r2);
                if (!checkingAttack && target && target.c === piece.c) return false;
                const absDx = Math.abs(dx); const absDy = Math.abs(dy);
                const type = piece.s; const isWhite = piece.c === 'w';

                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const checkComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && (['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'].includes(type))) { dirY = -dirY; }
                            if (comp.t === 'slide' || def.t === 'slide') {
                                if (dirX === 0) { if (dx === 0 && Math.sign(dy) === Math.sign(dirY) && absDy <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else if (dirY === 0) { if (dy === 0 && Math.sign(dx) === Math.sign(dirX) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else { if (absDx === absDy && Math.sign(dx) === Math.sign(dirX) && Math.sign(dy) === Math.sign(dirY) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                            }
                            else if (comp.t === 'jump' || def.t === 'jump') { if (dx === dirX && dy === dirY) return true; }
                            else if (comp.t === 'step' || def.t === 'step') { let mul = comp.mul || 1; if (dx === dirX*mul && dy === dirY*mul) return true; }
                            else if (comp.t === 'slide_jump') { if (dx % dirX === 0 && dy % dirY === 0) { const steps = dx / dirX; if (steps === dy / dirY && steps > 0) { let cx = c1 + dirX, cy = r1 + dirY; while (cx !== c2 || cy !== r2) { if (this.getPiece(cx, cy)) return false; cx += dirX; cy += dirY; } return true; } } }
                        }
                        return false;
                    };
                    if (def.t === 'complex') { return def.comps.some(c => checkComp(c)); } else { return checkComp(def); }
                }

                const isRook = (dx === 0 || dy === 0) && this.isPathClear(c1, r1, c2, r2);
                const isBishop = (absDx === absDy) && this.isPathClear(c1, r1, c2, r2);
                const isKnight = (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                if (['â™–','â™œ','â™•','â™›','ğŸ¦…','ğŸ²','ğŸ¤´','ğŸ„'].includes(type)) { if (isRook) return true; }
                if (['â™—','â™','â™•','â™›','â›','â›ƒ','ğŸ¦„','ğŸ²','ğŸ‘¼','ğŸ†','ğŸ‘º'].includes(type)) { if (isBishop) return true; }
                if (['â™˜','â™','ğŸ¦„','ğŸ¦…','ğŸ²','ğŸ¿ï¸'].includes(type)) { if (isKnight) return true; }
                if (['â™”','â™š','ğŸ‘¨','ğŸ»','ğŸ¤´','ğŸ‘¼'].includes(type)) return absDx <= 1 && absDy <= 1;
                if (type === 'â™™' || type === 'â™Ÿ') { const dir = isWhite ? -1 : 1; if (dx === 0 && dy === dir) return !target && !checkingAttack; if (dx === 0 && dy === dir * 2) { return !piece.hasMoved && !target && !checkingAttack && !this.getPiece(c1, r1 + dir); } if (absDx === 1 && dy === dir) return checkingAttack || (target && target.c !== piece.c); return false; }
                if (['ğŸ¢','ğŸ•'].includes(type)) return (absDx + absDy === 1) || (absDx===0 && dy===(isWhite?-1:1));
                return false;
            }

            switchTurn() {
                if (!this.turnModeEnabled || this.gameOver) return;
                this.currentTurn = this.currentTurn === 'w' ? 'b' : 'w';
                this.updateTurnIndicator();

                if (this.rulesEnabled) {
                    this.updateKingCheckStatus('w');
                    this.updateKingCheckStatus('b');

                    if (this.kingsInCheck[this.currentTurn]) {
                        const kingPos = this.kingsInCheck[this.currentTurn];
                        const kingPiece = this.getPiece(kingPos.c, kingPos.r);

                        let canEscape = false;
                        if (kingPiece) {
                            const moves = this.generatePotentialMoves(kingPiece, kingPos.c, kingPos.r);
                            for (const m of moves) {
                                if (this.simulateMoveAndCheckSafety(kingPiece, kingPos.c, kingPos.r, m.c, m.r)) {
                                    canEscape = true;
                                    break;
                                }
                            }
                        }

                        if (!canEscape) {
                            this.endGame();
                        }
                    }
                }
            }

            endGame() {
                this.gameOver = true;
                const winner = this.currentTurn === 'w' ? "Ğ§Ğ¾Ñ€Ğ½Ñ–" : "Ğ‘Ñ–Ğ»Ñ–";
                const icon = this.currentTurn === 'w' ? "â™š" : "â™”";
                document.getElementById('winnerTxt').innerText = `ĞŸĞµÑ€ĞµĞ¼Ğ¾Ğ³Ğ°: ${winner}`;
                document.getElementById('winnerIcon').innerText = icon;
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }

            updateTurnIndicator() {
                const ind = document.getElementById('turnIndicator');
                const txt = document.getElementById('turnText');
                const icon = document.getElementById('turnIcon');
                if (!this.turnModeEnabled) { ind.style.display = 'none'; return; }
                ind.style.display = 'flex';
                if (this.currentTurn === 'w') {
                    ind.style.background = 'rgba(255, 255, 255, 0.9)'; ind.style.color = '#000';
                    ind.style.borderColor = (this.kingsInCheck.w) ? 'red' : '#000';
                    txt.innerText = (this.kingsInCheck.w) ? "Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ– (Ğ¨ĞĞ¥!)" : "Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ–";
                    icon.innerText = "â™”";
                } else {
                    ind.style.background = 'rgba(0, 0, 0, 0.9)'; ind.style.color = '#fff';
                    ind.style.borderColor = (this.kingsInCheck.b) ? 'red' : '#fff';
                    txt.innerText = (this.kingsInCheck.b) ? "Ğ¥Ñ–Ğ´: Ğ§Ğ¾Ñ€Ğ½Ñ– (Ğ¨ĞĞ¥!)" : "Ğ¥Ñ–Ğ´: Ğ§Ğ¾Ñ€Ğ½Ñ–";
                    icon.innerText = "â™š";
                }
            }

            toggleRules() { this.rulesEnabled = !this.rulesEnabled; if(!this.rulesEnabled) this.kingsInCheck = { w: null, b: null }; document.getElementById('rulesBtn').innerText = this.rulesEnabled ? "ğŸŸ¢ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°" : "ğŸ”´ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°"; }
            toggleTurnMode() { this.turnModeEnabled = !this.turnModeEnabled; this.updateTurnIndicator(); document.getElementById('turnBtn').innerText = this.turnModeEnabled ? "ğŸŸ¢ Ğ¥Ñ–Ğ´ (Ğ’ĞšĞ›)" : "ğŸ”´ Ğ¥Ñ–Ğ´ (Ğ’Ğ˜ĞšĞ›)"; }

            findKing(color) {
                if(color === 'w' && this.kingPos.w) return this.kingPos.w;
                if(color === 'b' && this.kingPos.b) return this.kingPos.b;

                if (this.virtualGen === 'classic' || this.virtualGen === 'fantasy') {
                     const kingCol = Math.floor(this.boardSize/2);
                     if (color === 'b') return {c: kingCol, r:0};
                     if (color === 'w') return {c: kingCol, r:this.boardSize-1};
                }

                const kingSymbol = color === 'w' ? 'â™”' : 'â™š';
                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    if(p.s === kingSymbol && p.c === color) {
                         const parts = key.split(',');
                         return {c: parseInt(parts[0]), r: parseInt(parts[1])};
                    }
                }
                return null;
            }

            isSquareAttacked(targetC, targetR, byOpponentOfColor) {
                const enemyQueen = byOpponentOfColor === 'w' ? 'â™•' : 'â™›';
                const enemyRook = byOpponentOfColor === 'w' ? 'â™–' : 'â™œ';
                const enemyBishop = byOpponentOfColor === 'w' ? 'â™—' : 'â™';
                const enemyKnight = byOpponentOfColor === 'w' ? 'â™˜' : 'â™';
                const enemyPawn = byOpponentOfColor === 'w' ? 'â™™' : 'â™Ÿ';

                const knights = [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]];
                for (const [dx, dy] of knights) {
                    const p = this.getPiece(targetC + dx, targetR + dy);
                    if (p && p.c === byOpponentOfColor && (p.s === enemyKnight || p.s === 'ğŸ¦„')) return true;
                }

                const pawnDy = byOpponentOfColor === 'w' ? 1 : -1;
                if (this.getPiece(targetC + 1, targetR + pawnDy)?.s === enemyPawn && this.getPiece(targetC + 1, targetR + pawnDy)?.c === byOpponentOfColor) return true;
                if (this.getPiece(targetC - 1, targetR + pawnDy)?.s === enemyPawn && this.getPiece(targetC - 1, targetR + pawnDy)?.c === byOpponentOfColor) return true;

                // --- Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ¢Ğ£Ğ¢: Ğ¼ĞµĞ½ÑĞµĞ¼ 30 Ğ½Ğ° this.boardSize ---
                const MAX_RAY = this.boardSize;
                // ----------------------------------------------------

                const checkRay = (dx, dy, types) => {
                    let x = targetC + dx;
                    let y = targetR + dy;
                    let dist = 0;
                    while (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize && dist < MAX_RAY) {
                        const p = this.getPiece(x, y);
                        if (p) {
                            if (p.c === byOpponentOfColor) {
                                if (types.includes(p.s)) return true;
                                if (types.includes(enemyQueen) && ['ğŸ§œ','ğŸ”±','ğŸ¦…'].includes(p.s)) return true;
                            }
                            return false;
                        }
                        x += dx; y += dy;
                        dist++;
                    }
                    return false;
                };

                if (checkRay(0, 1, [enemyRook, enemyQueen])) return true;
                if (checkRay(0, -1, [enemyRook, enemyQueen])) return true;
                if (checkRay(1, 0, [enemyRook, enemyQueen])) return true;
                if (checkRay(-1, 0, [enemyRook, enemyQueen])) return true;

                if (checkRay(1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRay(1, -1, [enemyBishop, enemyQueen])) return true;
                if (checkRay(-1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRay(-1, -1, [enemyBishop, enemyQueen])) return true;

                return false;
            }

            isInCheck(kingColor) { const kingPos = this.findKing(kingColor); if (!kingPos) return false; return this.isSquareAttacked(kingPos.c, kingPos.r, kingColor === 'w' ? 'b' : 'w'); }
            updateKingCheckStatus(color) { this.kingsInCheck[color] = this.isInCheck(color) ? this.findKing(color) : null; }

            hasAnyLegalMoves(color) { return true; }
            _resolveDirs(d) { return typeof d === 'string' ? DIRS[d] : d; }

            generatePotentialMoves(piece, cx, cy) {
                if (this.checkersSymbols.has(piece.s)) {
                    if (!this.multiJumpSource && this.rulesEnabled) return this.getCheckersMoves(piece, cx, cy);
                    else if (this.multiJumpSource) {
                        if (cx !== this.multiJumpSource.c || cy !== this.multiJumpSource.r) return [];
                        return this.getCheckersMoves(piece, cx, cy, true);
                    }
                    return this.getCheckersMoves(piece, cx, cy);
                }

                let moves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                const addStep = (dx, dy) => {
                    let x = cx + dx; let y = cy + dy;
                    if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) moves.push({c: x, r: y});
                };

                // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ğ¹ Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€ Ğ´Ğ¾ÑˆĞºĞ¸, Ñ‰Ğ¾Ğ± Ğ»Ñ–Ğ½Ñ–Ñ Ğ¹ÑˆĞ»Ğ° Ğ´Ğ¾ ĞºÑ–Ğ½Ñ†Ñ
                const MAX_SLIDE = this.boardSize;

                const addTrace = (dx, dy, maxSteps = MAX_SLIDE) => {
                    let x = cx + dx; let y = cy + dy;
                    let steps = 0;
                    while (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize && steps < maxSteps) {
                        const target = this.getPiece(x, y);
                        if (target) {
                            if (target.c !== piece.c) moves.push({c: x, r: y});
                            break;
                        }
                        // Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ ĞšĞĞ–ĞĞ£ Ñ‚Ğ¾Ñ‡ĞºÑƒ, Ñ‰Ğ¾Ğ± Ğ»Ñ–Ğ½Ñ–Ñ Ğ±ÑƒĞ»Ğ° ÑÑƒÑ†Ñ–Ğ»ÑŒĞ½Ğ¾Ñ
                        moves.push({c: x, r: y});
                        x += dx; y += dy;
                        steps++;
                    }
                };

                if (['â™–','â™œ','â™•','â™›'].includes(type)) { addTrace(1,0); addTrace(-1,0); addTrace(0,1); addTrace(0,-1); }
                if (['â™—','â™','â™•','â™›'].includes(type)) { addTrace(1,1); addTrace(-1,1); addTrace(1,-1); addTrace(-1,-1); }
                if (['â™˜','â™'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => addStep(d[0], d[1])); }
                if (['â™”','â™š'].includes(type)) { for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i||j) addStep(i,j); }
                if (['â™™','â™Ÿ'].includes(type)) {
                    const d = isWhite ? -1 : 1;
                    if (!this.getPiece(cx, cy + d)) addStep(0, d);
                    if (!this.getPiece(cx, cy + d*2) && !this.getPiece(cx, cy + d) && !piece.hasMoved) addStep(0, d*2);
                    const t1 = this.getPiece(cx + 1, cy + d); if (t1 && t1.c !== piece.c) addStep(1, d);
                    const t2 = this.getPiece(cx - 1, cy + d); if (t2 && t2.c !== piece.c) addStep(-1, d);
                }
                if (['ğŸ¢', 'ğŸ•'].includes(type)) { [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => addStep(d[0], d[1])); }

                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const FLIP_Y_LIST = ['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'];
                    const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            if (moveType === 'slide' || moveType === 'slide_jump') addTrace(dirX, dirY, Math.min(limit, MAX_SLIDE));
                            else { let mul = comp.mul || 1; addStep(dirX * mul, dirY * mul); }
                        }
                    };
                    if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }
                return moves;
            }

            simulateMoveAndCheckSafety(piece, startC, startR, targetC, targetR) {
                if (!this.validateMove(piece, startC, startR, targetC, targetR)) return false;

                const keyStart = this.getKey(startC, startR);
                const keyTarget = this.getKey(targetC, targetR);

                const valStart = this.grid.get(keyStart);
                const valTarget = this.grid.get(keyTarget);

                const wasKingW = this.kingPos.w;
                const wasKingB = this.kingPos.b;

                if (valStart === undefined && this.virtualGen) {
                    const p = this.getVirtualPiece(startC, startR);
                    const pid = this.getPaletteId(p.s, p.c);
                    this.grid.set(keyTarget, pid);
                    this.grid.set(keyStart, GRID_VOID);
                } else {
                    this.grid.set(keyTarget, valStart);
                    this.grid.delete(keyStart);
                }

                if(piece.s === 'â™”') this.kingPos.w = {c: targetC, r: targetR};
                if(piece.s === 'â™š') this.kingPos.b = {c: targetC, r: targetR};

                const isSafe = !this.isInCheck(piece.c);

                if (valTarget === undefined) this.grid.delete(keyTarget); else this.grid.set(keyTarget, valTarget);
                if (valStart === undefined) this.grid.delete(keyStart); else this.grid.set(keyStart, valStart);

                this.kingPos.w = wasKingW;
                this.kingPos.b = wasKingB;

                return isSafe;
            }

            calculateHighlights(piece, cx, cy) {
                if (!this.rulesEnabled) return;
                this.highlightedMoves = [];
                const potentialMoves = this.generatePotentialMoves(piece, cx, cy);

                // Ğ¯ĞºÑ‰Ğ¾ Ñ…Ğ¾Ğ´Ñ–Ğ² Ğ´ÑƒĞ¶Ğµ Ğ±Ğ°Ğ³Ğ°Ñ‚Ğ¾ (Ğ²ĞµĞ»Ğ¸ĞºĞ° Ğ´Ğ¾ÑˆĞºĞ°), Ğ¼Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ Ğ²Ğ°Ğ¶ĞºÑƒ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ Ğ±ĞµĞ·Ğ¿ĞµĞºĞ¸ Ğ´Ğ»Ñ Ğ’Ğ†Ğ—Ğ£ĞĞ›Ğ†Ğ—ĞĞ¦Ğ†Ğ‡.
                // Ğ¦Ğµ Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑÑ” Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ¾ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ Ñ…Ğ¾Ğ´Ğ¸.
                const skipSafetyCheck = potentialMoves.length > 200;

                for (const move of potentialMoves) {
                    if (skipSafetyCheck) {
                        this.highlightedMoves.push(move);
                    } else {
                        if (this.simulateMoveAndCheckSafety(piece, cx, cy, move.c, move.r)) {
                            this.highlightedMoves.push(move);
                        }
                    }
                }
            }

            onMouseDown(e) {
                if (this.gameOver || this.isGenerating || this.promotionPending) return;
                const w = this.screenToWorld(e.clientX, e.clientY);
                const c = Math.floor(w.x / this.cellSize); const r = Math.floor(w.y / this.cellSize);
                if (e.button === 0) {
                    const piece = this.getPiece(c, r);
                    if (piece) {
                        if (this.turnModeEnabled && piece.c !== this.currentTurn) return;
                        this.isDraggingPiece = true;
                        this.draggedPiece = { data: piece, startC: c, startR: r };
                        this.calculateHighlights(piece, c, r);
                    } else { this.isDragging = true; this.lastMouse = { x: e.clientX, y: e.clientY }; }
                } else if (e.button === 2) { if (this.turnModeEnabled) return; this.isPainting = true; this.tryPlacePiece(c, r); }
            }

            onMouseMove(e) {
                this.mouse.x = e.clientX; this.mouse.y = e.clientY;
                if (this.promotionPending) return;

                if (this.isDragging) { this.camera.x += e.clientX - this.lastMouse.x; this.camera.y += e.clientY - this.lastMouse.y; this.lastMouse = { x: e.clientX, y: e.clientY }; this.clampCamera(); }
                const w = this.screenToWorld(e.clientX, e.clientY); const c = Math.floor(w.x / this.cellSize); const r = Math.floor(w.y / this.cellSize);
                if (this.isPainting) this.tryPlacePiece(c, r);
                if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) { const file = this.getFileLabel(c); const rank = this.boardSize - r; document.getElementById('coord').innerText = `${file}${rank}`; }
            }

            tryPlacePiece(c, r) { if(c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) { if (this.curSymbol === 'delete') { this.removePiece(c, r); this.updateUI(); return; } this.setPiece(c, r, { s: this.curSymbol, c: this.curColor }); this.updateUI(); } }

            onMouseUp(e) {
                if (e.button === 2) this.isPainting = false;
                if (this.promotionPending) return;

                if (this.isDraggingPiece && this.draggedPiece) {
                    const w = this.screenToWorld(e.clientX, e.clientY);
                    const c = Math.floor(w.x / this.cellSize);
                    const r = Math.floor(w.y / this.cellSize);

                    let moveSuccessful = false;
                    let turnEnded = true;

                    if(c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) {
                        const isChecker = this.checkersSymbols.has(this.draggedPiece.data.s);
                        let capturedMoveInfo = null;

                        if (isChecker && this.rulesEnabled) {
                             const legalMoves = this.generatePotentialMoves(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR);
                             capturedMoveInfo = legalMoves.find(m => m.c === c && m.r === r);
                        }

                        let isValid = false;
                        if (isChecker && this.rulesEnabled) isValid = !!capturedMoveInfo;
                        else isValid = this.validateMove(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR, c, r);

                        if (isValid) {
                            let isMoveSafe = true;
                            if (this.rulesEnabled && !isChecker) {
                                isMoveSafe = this.simulateMoveAndCheckSafety(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR, c, r);
                            }

                            if (isMoveSafe) {
                                // --- PROMOTION CHECK ---
                                const isWhite = this.draggedPiece.data.c === 'w';
                                const isPawn = this.draggedPiece.data.s === 'â™™' || this.draggedPiece.data.s === 'â™Ÿ';
                                const promotionRow = isWhite ? 0 : this.boardSize - 1;

                                if (isPawn && r === promotionRow && !isChecker) {
                                    this.promotionPending = {
                                        piece: this.draggedPiece.data,
                                        startC: this.draggedPiece.startC,
                                        startR: this.draggedPiece.startR,
                                        endC: c,
                                        endR: r,
                                        capturedInfo: capturedMoveInfo
                                    };
                                    this.showPromotionDialog(this.draggedPiece.data.c);
                                    this.draggedPiece = null;
                                    this.isDraggingPiece = false;
                                    this.highlightedMoves = [];
                                    return;
                                }

                                // --- Ğ—ĞĞŸĞ˜Ğ¡ Ğ†Ğ¡Ğ¢ĞĞ Ğ†Ğ‡ (Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ) ---
                                const startCoord = this.getCoordString(this.draggedPiece.startC, this.draggedPiece.startR);
                                const endCoord = this.getCoordString(c, r);
                                const isCap = (capturedMoveInfo && capturedMoveInfo.isCapture) || this.getPiece(c,r);

                                const historyStep = {
                                    turn: this.currentTurn,
                                    prevKingPos: { w: this.kingPos.w ? {...this.kingPos.w} : null, b: this.kingPos.b ? {...this.kingPos.b} : null },
                                    multiJumpSource: this.multiJumpSource ? {...this.multiJumpSource} : null,
                                    changes: [],
                                    // Ğ”ĞĞ”ĞĞ„ĞœĞ ĞĞĞ¢ĞĞ¦Ğ†Ğ®, Ğ©ĞĞ‘ Ğ¢ĞĞ‘Ğ›Ğ˜Ğ¦Ğ¯ ĞŸĞ ĞĞ¦Ğ®Ğ’ĞĞ›Ğ
                                    notation: {
                                        icon: this.draggedPiece.data.s,
                                        start: startCoord,
                                        end: endCoord,
                                        cap: !!isCap
                                    }
                                };
                                const recordState = (c, r) => {
                                    const k = this.getKey(c, r);
                                    const v = this.grid.get(k);
                                    historyStep.changes.push({ key: k, value: v });
                                };
                                recordState(this.draggedPiece.startC, this.draggedPiece.startR);
                                recordState(c, r);
                                if (capturedMoveInfo && capturedMoveInfo.isCapture) {
                                    recordState(capturedMoveInfo.captured.x, capturedMoveInfo.captured.y);
                                }
                                this.moveHistory.push(historyStep);
                                this.updateLogUI(); // <--- ĞĞĞĞ’Ğ›Ğ®Ğ„ĞœĞ Ğ¢ĞĞ‘Ğ›Ğ˜Ğ¦Ğ®
                                // -------------------------------

                                if (capturedMoveInfo && capturedMoveInfo.isCapture) {
                                    this.removePiece(capturedMoveInfo.captured.x, capturedMoveInfo.captured.y);
                                }

                                this.removePiece(this.draggedPiece.startC, this.draggedPiece.startR);

                                this.draggedPiece.data.x = c;
                                this.draggedPiece.data.y = r;
                                this.draggedPiece.data.hasMoved = true;

                                if (isChecker) {
                                    const promotionRowChecker = isWhite ? 0 : this.boardSize - 1;
                                    if (r === promotionRowChecker) {
                                        if (this.draggedPiece.data.s === 'â›‚') this.draggedPiece.data.s = 'â›ƒ';
                                        if (this.draggedPiece.data.s === 'â›€') this.draggedPiece.data.s = 'â›';
                                    }
                                }

                                this.setPiece(c, r, this.draggedPiece.data);
                                moveSuccessful = true;

                                if (isChecker && capturedMoveInfo && capturedMoveInfo.isCapture) {
                                    const moreCaptures = this.getCheckersMoves(this.draggedPiece.data, c, r, true);
                                    if (moreCaptures.length > 0) {
                                        this.multiJumpSource = { c: c, r: r };
                                        turnEnded = false;
                                    } else {
                                        this.multiJumpSource = null;
                                    }
                                } else {
                                    this.multiJumpSource = null;
                                }

                                if (turnEnded && (c !== this.draggedPiece.startC || r !== this.draggedPiece.startR)) {
                                    setTimeout(() => this.switchTurn(), 0);
                                }
                            }
                        }
                    }

                    this.draggedPiece = null;
                    this.isDraggingPiece = false;
                    if (turnEnded) this.highlightedMoves = [];
                    this.updateUI();
                }
                this.isDragging = false;
            }

            showPromotionDialog(color) {
                const overlay = document.getElementById('promotionOverlay');
                const grid = document.getElementById('promotionGrid');
                grid.innerHTML = '';

                // Determine if we are in strict classic mode
                const isClassicMode = this.virtualGen === 'classic';

                PIECE_CATEGORIES.forEach(cat => {
                    // Skip Tools and Checkers
                    if (cat.name === "Ğ†Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¸" || cat.name === "Ğ¨Ğ°ÑˆĞºĞ¸") return;

                    // IF CLASSIC MODE: Skip any category that isn't Classic
                    if (isClassicMode && !cat.name.includes("ĞšĞ»Ğ°ÑĞ¸ĞºĞ°")) return;

                    cat.items.forEach(item => {
                        // Skip Kings, Pawns, and utility buttons
                        if (['â™”','â™š','â™™','â™Ÿ','delete','eraser'].includes(item.s)) return;

                        // If color specific category, ensure it matches
                        if (cat.name.includes("ĞšĞ»Ğ°ÑĞ¸ĞºĞ°")) {
                           if (color === 'w' && cat.name.includes("Ğ§Ğ¾Ñ€Ğ½Ñ–")) return;
                           if (color === 'b' && cat.name.includes("Ğ‘Ñ–Ğ»Ñ–")) return;
                        }

                        const btn = document.createElement('button');
                        btn.className = 'promo-btn';
                        btn.innerText = item.s;
                        btn.title = item.t;
                        btn.onclick = () => this.finalizePromotion(item.s);
                        grid.appendChild(btn);
                    });
                });

                overlay.style.display = 'flex';
            }

            finalizePromotion(symbol) {
                if (!this.promotionPending) return;

                const pp = this.promotionPending;
                const startCoord = this.getCoordString(pp.startC, pp.startR);
                const endCoord = this.getCoordString(pp.endC, pp.endR);

                // --- HISTORY ---
                const historyStep = {
                    turn: this.currentTurn,
                    prevKingPos: { w: this.kingPos.w ? {...this.kingPos.w} : null, b: this.kingPos.b ? {...this.kingPos.b} : null },
                    multiJumpSource: null,
                    changes: []
                };
                const recordState = (c, r) => {
                    const k = this.getKey(c, r);
                    const v = this.grid.get(k);
                    historyStep.changes.push({ key: k, value: v });
                };
                recordState(pp.startC, pp.startR);
                recordState(pp.endC, pp.endR);
                this.moveHistory.push(historyStep);
                // --------------

                // Execute logic
                this.removePiece(pp.startC, pp.startR);

                const newPieceData = {
                    x: pp.endC,
                    y: pp.endR,
                    s: symbol,
                    c: pp.piece.c,
                    hasMoved: true
                };

                // Capture if needed
                const target = this.getPiece(pp.endC, pp.endR);
                const isCap = !!target;

                this.setPiece(pp.endC, pp.endR, newPieceData);
                this.addLogToUI(`${pp.piece.s}â${symbol}`, startCoord, endCoord, isCap);

                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                this.updateUI();
                this.switchTurn();
            }

            undoMove() {
                if (this.moveHistory.length === 0) return;
                const last = this.moveHistory.pop();

                last.changes.forEach(change => {
                    if (change.value === undefined) this.grid.delete(change.key);
                    else this.grid.set(change.key, change.value);
                });

                this.currentTurn = last.turn;
                this.kingPos = last.prevKingPos;
                this.multiJumpSource = last.multiJumpSource;
                this.gameOver = false;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.highlightedMoves = [];
                this.updateTurnIndicator();
                this.updateUI();
                this.updateLogUI(); // <--- Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ
            }

            onKeyDown(e) {
                if (this.gameOver || this.turnModeEnabled || this.promotionPending) return;
                if (e.key === 'Delete') {
                    // Default delete key behavior is now Undo via main listener
                } else if (e.shiftKey && e.key === 'Delete') {
                    // Eraser tool
                    const w = this.screenToWorld(this.mouse.x, this.mouse.y);
                    const c = Math.floor(w.x / this.cellSize);
                    const r = Math.floor(w.y / this.cellSize);
                    this.removePiece(c, r);
                    this.updateUI();
                }
            }

            screenToWorld(sx, sy) { return { x: (sx - this.camera.x) / this.camera.zoom, y: (sy - this.camera.y) / this.camera.zoom }; }

            update() {
                const moveSpeed = 15;
                if (this.keys.ArrowLeft) this.camera.x += moveSpeed;
                if (this.keys.ArrowRight) this.camera.x -= moveSpeed;
                if (this.keys.ArrowUp) this.camera.y += moveSpeed;
                if (this.keys.ArrowDown) this.camera.y -= moveSpeed;

                if (Math.abs(this.camera.zoom - this.targetZoom) > 0.0000001) {
                    const oldZoom = this.camera.zoom; this.camera.zoom += (this.targetZoom - this.camera.zoom) * this.lerpFactor;
                    const factor = this.camera.zoom / oldZoom;
                    this.camera.x = this.mouse.x - (this.mouse.x - this.camera.x) * factor; this.camera.y = this.mouse.y - (this.mouse.y - this.camera.y) * factor;
                    this.clampCamera(); document.getElementById('zoomSlider').value = Math.log10(this.camera.zoom);
                    let disp = Math.round(this.camera.zoom * 100) + '%';
                    if(this.camera.zoom < 0.01) disp = this.camera.zoom.toExponential(2);
                    document.getElementById('zoomDisplay').innerText = disp;
                }
            }

            render() {
                const ctx = this.ctx;
                const width = this.canvas.width; const height = this.canvas.height;
                const cs = this.cellSize * this.camera.zoom;

                // 1. ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ ĞµĞºÑ€Ğ°Ğ½Ñƒ (ĞŸĞĞ’Ğ•Ğ ĞĞ£Ğ’ ĞĞ Ğ˜Ğ“Ğ†ĞĞĞ›Ğ¬ĞĞ˜Ğ™ ĞšĞĞ›Ğ†Ğ )
                ctx.fillStyle = this.colors.void;
                ctx.fillRect(0, 0, width, height);

                const bx = this.camera.x; const by = this.camera.y;
                const startCol = Math.max(0, Math.floor((-this.camera.x) / cs));
                const endCol = Math.min(this.boardSize, Math.floor((width - this.camera.x) / cs) + 1);
                const startRow = Math.max(0, Math.floor((-this.camera.y) / cs));
                const endRow = Math.min(this.boardSize, Math.floor((height - this.camera.y) / cs) + 1);
                const boardPixelW = this.boardSize * cs; const boardPixelH = this.boardSize * cs;

                // 2. ĞœĞĞ›Ğ®Ğ’ĞĞĞĞ¯ Ğ”ĞĞ¨ĞšĞ˜
                if (bx < width && by < height && bx + boardPixelW > 0 && by + boardPixelH > 0) {

                     // Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¸Ğ¹ Ñ„Ğ¾Ğ½ Ğ´Ğ¾ÑˆĞºĞ¸
                     ctx.fillStyle = this.colors.light;
                     ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), Math.min(boardPixelW, width), Math.min(boardPixelH, height));

                     ctx.fillStyle = this.colors.dark;

                     if (cs > 0.8) {
                         // === Ğ‘Ğ›Ğ˜Ğ—Ğ¬ĞšĞ: Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ° ÑÑ–Ñ‚ĞºĞ° ===
                         ctx.beginPath();
                         const gridSkip = (cs < 2) ? 2 : 1;
                         for (let r = startRow; r < endRow; r += gridSkip) {
                             let c = startCol;
                             // --- Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯: Ğ†ĞĞ’Ğ•Ğ Ğ¡Ğ†Ğ¯ ĞšĞĞ›Ğ¬ĞĞ Ğ†Ğ’ ---
                             if ((r % 2) !== 0) {
                                if (c % 2 !== 0) c++; // Ğ¯ĞºÑ‰Ğ¾ Ñ€ÑĞ´ Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğ¸Ğ¹, Ğ¿Ğ¾Ñ‡Ğ¸Ğ½Ğ°Ñ”Ğ¼Ğ¾ Ğ· Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğ¾Ğ³Ğ¾ (Ñ‰Ğ¾Ğ± Ğ½Ğ°Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ½Ğ° Ğ¿Ğ°Ñ€Ğ½Ğ¾Ğ¼Ñƒ)
                             } else {
                                if (c % 2 === 0) c++; // Ğ¯ĞºÑ‰Ğ¾ Ñ€ÑĞ´ Ğ¿Ğ°Ñ€Ğ½Ğ¸Ğ¹, Ğ¿Ğ¾Ñ‡Ğ¸Ğ½Ğ°Ñ”Ğ¼Ğ¾ Ğ· Ğ¿Ğ°Ñ€Ğ½Ğ¾Ğ³Ğ¾ (Ñ‰Ğ¾Ğ± Ğ½Ğ°Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ½Ğ° Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğ¾Ğ¼Ñƒ)
                             }
                             // ----------------------------------------
                             for (; c < endCol; c += 2) {
                                 ctx.rect((bx + c * cs) | 0, (by + r * cs) | 0, Math.ceil(cs), Math.ceil(cs));
                             }
                         }
                         ctx.fill();
                     } else {
                         // === Ğ”ĞĞ›Ğ•ĞšĞ: Ğ¢Ğ¾Ğ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ ===
                         // Ğ¦Ğµ Ğ²Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾: Ğ½Ğ°ĞºĞ»Ğ°Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ½Ğ°Ğ¿Ñ–Ğ²Ğ¿Ñ€Ğ¾Ğ·Ğ¾Ñ€Ğ¸Ğ¹ Ñ‚ĞµĞ¼Ğ½Ğ¸Ğ¹ ÑˆĞ°Ñ€.
                         // Ğ¢ĞµĞ¿ĞµÑ€ Ğ´Ğ¾ÑˆĞºĞ° Ğ±ÑƒĞ´Ğµ Ğ²Ğ¸Ğ³Ğ»ÑĞ´Ğ°Ñ‚Ğ¸ Ñ‚ĞµĞ¼Ğ½Ñ–ÑˆĞ¾Ñ Ğ·Ğ° Ğ¾Ñ€Ğ¸Ğ³Ñ–Ğ½Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ñ„Ğ¾Ğ½, Ñ– Ğ²Ğ¸ Ñ—Ñ— Ñ‡Ñ–Ñ‚ĞºĞ¾ Ğ¿Ğ¾Ğ±Ğ°Ñ‡Ğ¸Ñ‚Ğµ.
                         ctx.globalAlpha = 0.5;
                         ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), Math.min(boardPixelW, width), Math.min(boardPixelH, height));
                         ctx.globalAlpha = 1.0;
                     }

                     // Ğ Ğ°Ğ¼ĞºĞ°
                     ctx.strokeStyle = this.colors.border;
                     ctx.lineWidth = Math.max(2, cs * 0.1);
                     ctx.strokeRect(bx, by, boardPixelW, boardPixelH);
                }

                // 3. ĞŸÑ–Ğ´ÑĞ²Ñ–Ñ‚ĞºĞ° (Ğ¨Ğ°Ñ…/ĞœĞ°Ñ‚)
                if (this.rulesEnabled && cs > 2) {
                    for (const color of ['w', 'b']) {
                        if (this.kingsInCheck[color]) {
                            const k = this.kingsInCheck[color];
                            ctx.fillStyle = (this.gameOver && this.currentTurn === color)
                                ? this.colors.mateHighlight : this.colors.checkHighlight;
                            if (k.c >= startCol && k.c < endCol && k.r >= startRow && k.r < endRow) {
                                ctx.fillRect(bx + k.c * cs, by + k.r * cs, cs, cs);
                            }
                        }
                    }
                }

                // 4. ĞŸÑ–Ğ´ÑĞ²Ñ–Ñ‚ĞºĞ° Ñ…Ğ¾Ğ´Ñ–Ğ²
                if (this.highlightedMoves.length > 0) {
                    const dotSize = Math.max(cs * 0.3, 2);
                    ctx.fillStyle = this.colors.highlight;
                    ctx.beginPath();
                    for (const move of this.highlightedMoves) {
                        if (move.c < startCol || move.c >= endCol || move.r < startRow || move.r >= endRow) continue;
                        const hx = bx + move.c * cs + cs/2;
                        const hy = by + move.r * cs + cs/2;
                        ctx.moveTo(hx, hy);
                        ctx.arc(hx, hy, dotSize, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }

                // 5. ĞšĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ¸
                if (cs > 25) {
                    const fontSize = Math.max(cs * 0.25, 12); ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; const labelX = bx - 5;
                    for(let r = startRow; r < endRow; r++) {
                        const rankVal = this.boardSize - r; const labelY = by + r*cs + cs/2;
                        if(labelY > 0 && labelY < height) { ctx.fillStyle = '#ccc'; ctx.fillText(rankVal.toString(), labelX, labelY); }
                    }
                    ctx.textAlign = 'center'; ctx.textBaseline = 'top'; const labelYBottom = by + this.boardSize*cs + 5;
                    for(let c = startCol; c < endCol; c++) {
                        const labelXPos = bx + c*cs + cs/2;
                        if(labelXPos > 0 && labelXPos < width) { ctx.fillStyle = '#ccc'; ctx.fillText(this.getFileLabel(c), labelXPos, labelYBottom); }
                    }
                }

                // --- 6. Ğ¤Ğ†Ğ“Ğ£Ğ Ğ˜ (Ğ§Ñ–Ñ‚ĞºÑ– Ñ–ĞºĞ¾Ğ½ĞºĞ¸) ---
                const visibleCellsW = endCol - startCol;
                const visibleCellsH = endRow - startRow;
                const totalVisible = visibleCellsW * visibleCellsH;

                let skip = 1;
                if (totalVisible > 50000) skip = Math.ceil(Math.sqrt(totalVisible / 50000));

                const minDrawSize = 12;
                const drawSize = Math.max(cs, minDrawSize);

                const useLowRes = true;

                for (let r = startRow; r < endRow; r += skip) {
                    for (let c = startCol; c < endCol; c += skip) {
                        if (this.isDraggingPiece && this.draggedPiece && this.draggedPiece.startC === c && this.draggedPiece.startR === r) continue;

                        const piece = this.getPiece(c, r);
                        if (!piece) continue;

                        const px = (bx + c * cs + cs/2) | 0;
                        const py = (by + r * cs + cs/2) | 0;

                        const sprite = this.getLowResSprite(piece.s, piece.c);
                        ctx.drawImage(sprite, px - drawSize/2, py - drawSize/2, drawSize, drawSize);
                    }
                }

                if (this.isDraggingPiece && this.draggedPiece) {
                    this.drawPiece(ctx, this.draggedPiece.data, this.mouse.x | 0, this.mouse.y | 0, Math.max(cs, 40));
                }
            }

            drawPiece(ctx, pieceData, x, y, size) {
                const sprite = this.getPieceSprite(pieceData.s, pieceData.c);
                const drawSize = size * 0.85;
                ctx.drawImage(sprite, (x - drawSize/2) | 0, (y - drawSize/2) | 0, drawSize | 0, drawSize | 0);
            }

            updateUI() {
                if (this.virtualGen) {
                    document.getElementById('count').innerText = "Infinite";
                } else {
                    document.getElementById('count').innerText = this.grid.size;
                }
            }

            animate() {
                const now = performance.now();
                if (Math.random() < 0.05) document.getElementById('fps').innerText = Math.round(1000 / (now - this.renderTime || 16));
                this.renderTime = now;
                this.update();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }

        const game = new SmoothChess();
    </script>
</body>
</html>