<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mega Chess: Color Fix</title>
    <style>
        /* --- STYLES --- */
        body { margin: 0; padding: 0; overflow: hidden; font-family: "Segoe UI", Arial, sans-serif; background: #eeeed2; user-select: none; }
        #canvas { display: block; cursor: grab; }
        #canvas:active { cursor: grabbing; }

        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.94);
            padding: 12px; border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            width: 380px;
            max-height: 95vh;
            overflow-y: auto;
            backdrop-filter: blur(8px); z-index: 10;
            transition: opacity 0.3s;
            display: flex; flex-direction: column; gap: 10px;
        }
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 4px; }
        #controls::-webkit-scrollbar-thumb { background: #bbb; border-radius: 4px; }

        #turnIndicator {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px);
            color: #333; padding: 8px 25px; border-radius: 50px; font-size: 20px;
            font-weight: bold; border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); pointer-events: none;
            display: flex; align-items: center; gap: 10px; transition: 0.3s; z-index: 10;
        }

        #loadingOverlay {
            position: absolute; bottom: 20px; right: 20px; width: 300px;
            background: rgba(0,0,0,0.8); display: none; padding: 15px; border-radius: 10px;
            flex-direction: column; justify-content: center; align-items: flex-start;
            z-index: 200; color: white; backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        .progress-bar { width: 100%; height: 6px; background: #444; border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.1s; }

        /* --- PROMOTION OVERLAY STYLES --- */
        #promotionOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center;
            z-index: 150; backdrop-filter: blur(8px); animation: fadeIn 0.3s;
        }
        .promo-card {
            background: white; padding: 25px; border-radius: 16px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 2px solid #3498db;
            width: 500px; max-height: 80vh; display: flex; flex-direction: column;
            animation: popIn 0.3s forwards;
        }
        .promo-header { font-size: 24px; margin-bottom: 15px; color: #2c3e50; font-weight: bold; }
        .promo-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 8px;
            overflow-y: auto; padding: 10px; border: 1px solid #eee; border-radius: 8px; background: #f9f9f9;
        }

        .promo-btn {
            font-size: 30px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
            padding: 5px;
            color: #000 !important;
            line-height: 1;
        }
        .promo-btn:hover { background: #e3f2fd; transform: scale(1.1); border-color: #3498db; }

        #gameOverOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center;
            z-index: 100; backdrop-filter: blur(5px); animation: fadeIn 0.5s;
        }
        .victory-card {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 4px solid #f1c40f;
            min-width: 300px; transform: scale(0.9); animation: popIn 0.3s forwards;
        }
        .victory-card h1 { margin: 0; color: #e74c3c; font-size: 48px; text-transform: uppercase; }
        .victory-card h2 { margin: 10px 0 30px 0; color: #2c3e50; font-size: 24px; }
        .victory-card .winner-icon { font-size: 60px; margin: 10px 0; display: block; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes popIn { to { transform: scale(1); } }

        h3 { margin: 0 0 5px 0; color: #2c3e50; font-size: 18px; border-bottom: 1px solid #ddd; padding-bottom: 8px; }
        .control-group { margin-bottom: 5px; }
        label { display: block; margin-bottom: 4px; font-size: 12px; font-weight: 700; color: #555; text-transform: uppercase; }
        input, button { width: 100%; padding: 6px; box-sizing: border-box; border-radius: 6px; border: 1px solid #ccc; font-size: 13px; }

        .btn-row { display: flex; gap: 4px; margin-top: 4px; }
        button { background: #769656; color: white; border: none; cursor: pointer; font-weight: 600; transition: 0.1s; }
        button:hover { background: #5d7c40; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        button.secondary { background: #9ca3af; }
        button.secondary:hover { background: #6b7280; }
        button.danger { background: #e74c3c; }
        button.danger:hover { background: #c0392b; }
        button.action { background: #f39c12; }
        button.action:hover { background: #d35400; }
        button.checkers { background: #8e44ad; }
        button.checkers:hover { background: #732d91; }
        button.classic { background: #3498db; }
        button.classic:hover { background: #2980b9; }
        button.undo-btn { background: #555; }
        button.undo-btn:hover { background: #333; }

        /* --- LOG STYLES --- */
         #logContainer {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-top: 5px;
            height: 140px;
            overflow-y: auto;
            position: relative;
        }
        #logContainer::-webkit-scrollbar { width: 6px; }
        #logContainer::-webkit-scrollbar-thumb { background: #ccc; }

        #logTable {
            width: 100%;
            border-collapse: collapse;
            font-family: "Segoe UI Mono", monospace;
            font-size: 12px;
            table-layout: fixed;
        }
        #logTable th {
            position: sticky; top: 0;
            background: #e0e0e0;
            color: #555;
            padding: 4px;
            font-size: 11px;
            z-index: 2;
            text-align: center;
            border-bottom: 1px solid #ccc;
        }
        #logTable td {
            padding: 3px 5px;
            border-bottom: 1px solid #f0f0f0;
            color: #333;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }
        #logTable tr:nth-child(even) { background: #f9f9f9; }
        
        .log-num { width: 30px; color: #999; font-weight: bold; border-right: 1px solid #eee; background: #fafafa; }
        .move-icon { font-weight: bold; color: #2c3e50; margin-right: 2px; }
        .move-cap { color: #c0392b; font-weight: bold; margin-left: 2px; font-size: 10px; }
        .move-coords { color: #444; }

        .piece-container { display: flex; flex-direction: column; gap: 8px; }
        .category-block { background: rgba(0,0,0,0.03); border-radius: 6px; padding: 6px; border: 1px solid rgba(0,0,0,0.05); }
        .grid-header { font-size: 11px; font-weight: bold; text-transform: uppercase; color: #666; margin-bottom: 4px; text-align: center; background: #e0e0e0; border-radius: 3px; padding: 2px; }
        .piece-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; }
        .piece-btn { aspect-ratio: 1; padding: 0; font-size: 22px; background: #fff; color: #333; border: 1px solid #ccc; cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: transform 0.1s, background 0.1s; }
        .piece-btn:hover { background: #fff; transform: scale(1.15); z-index: 5; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .piece-btn.selected { background: #769656; color: white; border-color: #4b6334; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        .piece-btn.eraser { 
            background: #ffebee; 
            color: #c0392b; 
            border-color: #e74c3c; 
            font-size: 22px; /* Ğ—Ğ±Ñ–Ğ»ÑŒÑˆĞ¸Ğ¼Ğ¾ Ñ–ĞºĞ¾Ğ½ĞºÑƒ */
            font-weight: bold;
        }
        .piece-btn.eraser:hover {
            background: #ffcdd2;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        .piece-btn.black-piece { background: #333; color: #eee; border-color: #000; }
        .piece-btn.black-piece:hover { background: #555; }

        .info-panel { margin-top: 10px; padding: 8px; background: rgba(241, 242, 246, 0.8); border-radius: 6px; font-size: 12px; color: #555; text-align: center;}
        #debug { position: absolute; top: 10px; right: 10px; color: #555; background: rgba(255,255,255,0.5); padding: 5px 10px; border-radius: 4px; font-family: monospace; pointer-events: none; z-index: 5; }

        .input-row { display: flex; gap: 5px; align-items: center; justify-content: space-between; margin-bottom: 5px;}
        .input-row input[type="number"] { width: 60px; }
        .input-row span { font-size: 12px; font-weight: bold; }
        input[type=range] { padding: 0; margin: 5px 0; }
        .separator { border-top: 1px dashed #ccc; margin: 5px 0; }
        .gen-panel { background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; border: 1px solid rgba(0,0,0,0.1); }

        #opt-warning { color: #d35400; font-weight: bold; display: none; margin-top: 5px; font-size: 11px; text-align: center;}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="loadingOverlay">
        <strong id="loadingText">Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ ÑĞ²Ñ–Ñ‚Ñƒ...</strong>
        <div class="progress-bar">
            <div id="loadingProgress" class="progress-fill"></div>
        </div>
        <div style="font-size: 10px; margin-top: 5px; color: #ccc">ĞĞ¿Ñ‚Ğ¸Ğ¼Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ...</div>
    </div>

    <!-- PROMOTION OVERLAY -->
    <div id="promotionOverlay">
        <div class="promo-card">
            <div class="promo-header">âœ¨ ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ âœ¨</div>
            <div id="promotionGrid" class="promo-grid">
                <!-- Buttons will be injected here -->
            </div>
            <div style="margin-top:10px; font-size:12px; color:#777;">ĞĞ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ Ğ½Ğ° Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ</div>
        </div>
    </div>

    <div id="turnIndicator">
        <span id="turnIcon" style="font-size: 30px;">â™”</span>
        <span id="turnText">Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ–</span>
    </div>

    <div id="gameOverOverlay">
        <div class="victory-card">
            <h1>ĞœĞĞ¢!</h1>
            <span class="winner-icon" id="winnerIcon">ğŸ†</span>
            <h2 id="winnerTxt">ĞŸĞµÑ€ĞµĞ¼Ğ¾Ğ³Ğ° Ğ‘Ñ–Ğ»Ğ¸Ñ…</h2>
            <button class="action" onclick="game.resetGame()">ğŸ”„ ĞĞ¾Ğ²Ğ° Ğ³Ñ€Ğ°</button>
        </div>
    </div>

    <div id="controls">
        <h3>ğŸš€ Mega Chess: Unlimited</h3>

        <div class="control-group">
            <label>Ğ Ğ¾Ğ·Ğ¼Ñ–Ñ€ Ğ´Ğ¾ÑˆĞºĞ¸:</label>
            <input type="number" id="boardSize" value="32" min="2">
            <div class="btn-row">
                <button class="secondary" onclick="game.setSize(100)">100</button>
                <button class="secondary" onclick="game.setSize(1000)">1K</button>
                <button class="secondary" onclick="game.setSize(50000)">50K</button>
                <button class="secondary" onclick="game.setSize(1000000)">1M</button>
            </div>
        </div>

        <div class="control-group gen-panel">
             <label>âš”ï¸ Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ:</label>
             <div class="input-row">
                 <span>Ğ—Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½Ñ (%):</span>
                 <input type="number" id="fillPercent" value="25" min="1" max="50">
             </div>
             <div class="input-row">
                <span>Ğ¤ĞµĞ½Ñ‚ĞµĞ·Ñ– %:</span>
                <span id="fantasyPercentDisplay">40%</span>
             </div>
             <input type="range" id="fantasyMix" min="0" max="100" value="40" step="10">

             <div class="btn-row">
                 <button class="classic" onclick="game.fillClassic()">â™Ÿï¸ ĞšĞ»Ğ°Ñ.</button>
                 <button class="classic" onclick="game.fillChess960()">ğŸ² 960</button>
                 <button class="danger" onclick="game.fillArmy()">âš”ï¸ ĞÑ€Ğ¼Ñ–Ñ</button>
                 <button class="action" onclick="game.fillFantasy()">ğŸ² ĞœÑ–ĞºÑ</button>
                 <button class="checkers" onclick="game.fillCheckers()">âšªâš« Ğ¨Ğ°ÑˆĞºĞ¸</button>
             </div>

        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>Ğ ĞµĞ¶Ğ¸Ğ¼Ğ¸:</label>
             <div class="btn-row">
                 <button class="undo-btn" onclick="game.undoMove()">â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ (Del)</button>
                 <button id="rulesBtn" onclick="game.toggleRules()">ğŸŸ¢ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°</button>
             </div>
             <div class="btn-row">
                 <button id="turnBtn" onclick="game.toggleTurnMode()">ğŸŸ¢ Ğ¥Ñ–Ğ´ (Ğ’ĞšĞ›)</button>
             </div>
        </div>

        <div class="control-group">
            <label>ğŸ“œ Ğ—Ğ°Ğ¿Ğ¸Ñ Ñ…Ğ¾Ğ´Ñ–Ğ²:</label>
            <div id="logContainer">
                <table id="logTable">
                    <thead>
                        <tr>
                            <th class="log-num">#</th>
                            <th>Ğ‘Ñ–Ğ»Ñ–</th>
                            <th>Ğ§Ğ¾Ñ€Ğ½Ñ–</th>
                        </tr>
                    </thead>
                    <tbody id="logTableBody">
                        <!-- Ğ¥Ğ¾Ğ´Ğ¸ Ğ±ÑƒĞ´ÑƒÑ‚ÑŒ Ñ‚ÑƒÑ‚ -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>ğŸ¨ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ (Ğ’ÑÑ– Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸):</label>
             <div id="pieceContainer" class="piece-container"></div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±: <span id="zoomDisplay">100%</span></label>
             <input type="range" id="zoomSlider" min="-3" max="2" step="0.01">
        </div>
        <div class="separator"></div>
        <div class="control-group">
            <label>ğŸ’¾ Ğ¤Ğ°Ğ¹Ğ» Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ—:</label>
            <div class="btn-row">
                <button class="action" onclick="game.saveGame()">ğŸ“¥ Ğ—Ğ±ĞµÑ€ĞµĞ³Ñ‚Ğ¸ (.json)</button>
                <button class="classic" onclick="document.getElementById('fileInput').click()">ğŸ“‚ Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸</button>
                <!-- ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ñ–Ğ½Ğ¿ÑƒÑ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ -->
                <input type="file" id="fileInput" style="display:none" accept=".json" onchange="game.loadGame(this)">
            </div>
        </div>
        <div class="btn-row">
            <button onclick="game.centerBoard()">ğŸ  Ğ¦ĞµĞ½Ñ‚Ñ€</button>
            <button class="danger" onclick="game.clear()">ğŸ—‘ï¸ ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚Ğ¸</button>
        </div>

        <div class="info-panel">
            <span id="coord" style="font-weight:bold; margin-right: 10px">-</span>
            <span id="count"></span>
        </div>
    </div>

    <div id="debug">FPS: <span id="fps">60</span></div>

    <script>
        const PIECE_CATEGORIES = [
            { name: "Ğ†Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¸", bg: "#fff", items: [{ s: 'âŒ', t: 'Ğ“ÑƒĞ¼ĞºĞ°', c: 'eraser' }] },
            { name: "ĞšĞ»Ğ°ÑĞ¸ĞºĞ° (Ğ‘Ñ–Ğ»Ñ–)", bg: "#f0f0f0", items: [{s:'â™”',t:'ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ'}, {s:'â™•',t:'Ğ¤ĞµÑ€Ğ·ÑŒ'}, {s:'â™–',t:'Ğ¢ÑƒÑ€Ğ°'}, {s:'â™—',t:'Ğ¡Ğ»Ğ¾Ğ½'}, {s:'â™˜',t:'ĞšÑ–Ğ½ÑŒ'}, {s:'â™™',t:'ĞŸÑ–ÑˆĞ°Ğº'}] },
            { name: "ĞšĞ»Ğ°ÑĞ¸ĞºĞ° (Ğ§Ğ¾Ñ€Ğ½Ñ–)", bg: "#ddd", items: [{s:'â™š',t:'ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ', cls:'black-piece', color:'b'}, {s:'â™›',t:'Ğ¤ĞµÑ€Ğ·ÑŒ', cls:'black-piece', color:'b'}, {s:'â™œ',t:'Ğ¢ÑƒÑ€Ğ°', cls:'black-piece', color:'b'}, {s:'â™',t:'Ğ¡Ğ»Ğ¾Ğ½', cls:'black-piece', color:'b'}, {s:'â™',t:'ĞšÑ–Ğ½ÑŒ', cls:'black-piece', color:'b'}, {s:'â™Ÿ',t:'ĞŸÑ–ÑˆĞ°Ğº', cls:'black-piece', color:'b'}] },
            { name: "Ğ¨Ğ°ÑˆĞºĞ¸", bg: "#e0e0e0", items: [{s:'â›€',t:'Ğ‘Ñ–Ğ»Ğ° ÑˆĞ°ÑˆĞºĞ°', color:'w'}, {s:'â›',t:'Ğ‘Ñ–Ğ»Ğ° Ğ´Ğ°Ğ¼ĞºĞ°', color:'w'}, {s:'â›‚',t:'Ğ§Ğ¾Ñ€Ğ½Ğ° ÑˆĞ°ÑˆĞºĞ°', color:'b', cls:'black-piece'}, {s:'â›ƒ',t:'Ğ§Ğ¾Ñ€Ğ½Ğ° Ğ´Ğ°Ğ¼ĞºĞ°', color:'b', cls:'black-piece'}] },
            { name: "Mega: Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ğ¸", bg: "#e8daef", items: [{s:'ğŸš€',t:'Ğ Ğ°ĞºĞµÑ‚Ğ°'}, {s:'âš“',t:'Ğ¯ĞºÑ–Ñ€'}, {s:'ğŸ¹',t:'Ğ›ÑƒĞº'}, {s:'ğŸ£',t:'Ğ’ÑƒĞ´ĞºĞ°'}, {s:'ğŸ§œ',t:'Ğ ÑƒÑĞ°Ğ»ĞºĞ°'}, {s:'âš¡',t:'Ğ‘Ğ»Ğ¸ÑĞºĞ°Ğ²ĞºĞ°'}, {s:'ğŸ”±',t:'Ğ¢Ñ€Ğ¸Ğ·ÑƒĞ±'}, {s:'ğŸ¦¯',t:'Ğ¢Ñ€Ğ¾ÑÑ‚Ğ¸Ğ½Ğ°'}, {s:'ğŸ•¯ï¸',t:'Ğ¡Ğ²Ñ–Ñ‡ĞºĞ°'}, {s:'ğŸ“¼',t:'Ğ¢Ğ°Ğ½Ğº'}, {s:'ğŸ“œ',t:'Ğ¡ÑƒĞ²Ñ–Ğ¹'}, {s:'ğŸŒŠ',t:'Ğ¦ÑƒĞ½Ğ°Ğ¼Ñ–'}, {s:'ğŸ§¬',t:'Ğ”ĞĞš'}, {s:'ğŸ—¡ï¸',t:'ĞœĞµÑ‡'}] },
            { name: "Mega: Ğ¡Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ğ¸ (Ğ¢Ğ²Ğ°Ñ€Ğ¸Ğ½Ğ¸)", bg: "#d4e6f1", items: [{s:'ğŸ˜º',t:'ĞšÑ–Ñ‚'}, {s:'ğŸº',t:'Ğ’Ğ¾Ğ²Ğº'}, {s:'ğŸ¦Š',t:'Ğ›Ğ¸Ñ'}, {s:'ğŸ—',t:'ĞšĞ°Ğ±Ğ°Ğ½'}, {s:'ğŸ¦',t:'Ğ“Ğ¾Ñ€Ğ¸Ğ»Ğ°'}, {s:'ğŸƒ',t:'Ğ‘ÑƒĞ¹Ğ²Ğ¾Ğ»'}, {s:'ğŸŠ',t:'ĞšÑ€Ğ¾ĞºĞ¾Ğ´Ğ¸Ğ»'}, {s:'ğŸŒ',t:'Ğ Ğ°Ğ²Ğ»Ğ¸Ğº'}, {s:'ğŸ¦‘',t:'ĞšĞ°Ğ»ÑŒĞ¼Ğ°Ñ€'}, {s:'ğŸ™',t:'Ğ’Ğ¾ÑÑŒĞ¼Ğ¸Ğ½Ñ–Ğ³'}, {s:'ğŸ',t:'Ğ‘Ğ´Ğ¶Ğ¾Ğ»Ğ°'}, {s:'ğŸ¦‹',t:'ĞœĞµÑ‚ĞµĞ»Ğ¸Ğº'}, {s:'ğŸ«',t:'Ğ’ĞµÑ€Ğ±Ğ»ÑĞ´'}, {s:'ğŸ¦“',t:'Ğ—ĞµĞ±Ñ€Ğ°'}, {s:'ğŸ¦’',t:'Ğ–Ğ¸Ñ€Ğ°Ñ„Ğ°'}, {s:'ğŸ•',t:'ĞŸĞµÑ'}, {s:'ğŸ¦€',t:'ĞšÑ€Ğ°Ğ±'}, {s:'ğŸ†',t:'Ğ›ĞµĞ¾Ğ¿Ğ°Ñ€Ğ´'}, {s:'ğŸ¿ï¸',t:'Ğ‘Ñ–Ğ»ĞºĞ°'}, {s:'ğŸ¦‡',t:'ĞšĞ°Ğ¶Ğ°Ğ½'}, {s:'ğŸ¦—',t:'ĞšĞ¾Ğ½Ğ¸Ğº'}] },
            { name: "Mega: ĞšĞ¾Ğ¼Ğ±Ñ–Ğ½Ğ¾Ğ²Ğ°Ğ½Ñ– & Ğ Ğ¾Ğ»Ñ–", bg: "#f9e79f", items: [{s:'ğŸ',t:'Ğ†Ğ¼Ğ¿ĞµÑ€Ğ°Ñ‚Ñ€Ğ¸Ñ†Ñ'}, {s:'ğŸ‘¸',t:'ĞŸÑ€Ğ¸Ğ½Ñ†ĞµÑĞ°'}, {s:'ğŸº',t:'ĞĞ¼Ğ°Ğ·Ğ¾Ğ½ĞºĞ°'}, {s:'ğŸ‘®',t:'ĞŸĞ¾Ğ»Ñ–Ñ†Ñ–Ñ'}, {s:'ğŸ¤–',t:'Ğ Ğ¾Ğ±Ğ¾Ñ‚'}, {s:'ğŸ›¸',t:'ĞĞ›Ğ'}, {s:'ğŸ‡',t:'Ğ’ĞµÑ€ÑˆĞ½Ğ¸Ğº'}, {s:'ğŸŒªï¸',t:'Ğ¢Ğ¾Ñ€Ğ½Ğ°Ğ´Ğ¾'}, {s:'ğŸ§›',t:'Ğ’Ğ°Ğ¼Ğ¿Ñ–Ñ€'}, {s:'ğŸ’‚',t:'Ğ“Ğ²Ğ°Ñ€Ğ´Ñ–Ñ”Ñ†ÑŒ'}, {s:'ğŸ‘·',t:'Ğ‘ÑƒĞ´Ñ–Ğ²ĞµĞ»ÑŒĞ½Ğ¸Ğº'}, {s:'ğŸ§',t:'Ğ”Ğ¶Ğ¸Ğ½'}, {s:'ğŸ§š',t:'Ğ¤ĞµÑ'}, {s:'â˜€ï¸',t:'Ğ¡Ğ¾Ğ½Ñ†Ğµ'}, {s:'ğŸ§™',t:'ĞœĞ°Ğ³'}, {s:'ğŸ•µï¸',t:'Ğ¨Ğ¿Ğ¸Ğ³ÑƒĞ½'}, {s:'ğŸ¥‹',t:'Ğ¡Ğ°Ğ¼ÑƒÑ€Ğ°Ğ¹'}, {s:'ğŸ¥·',t:'ĞÑ–Ğ½Ğ´Ğ·Ñ'}, {s:'ğŸ‘¨',t:'Ğ§Ğ¾Ğ»Ğ¾Ğ²Ñ–Ğº'}, {s:'ğŸ¤´',t:'ĞŸÑ€Ğ¸Ğ½Ñ†'}, {s:'ğŸ‘¼',t:'ĞĞ½Ğ³ĞµĞ»'}] },
            { name: "Mega: ĞÑ€ÑĞµĞ½Ğ°Ğ» & ĞœĞ¾Ğ½ÑÑ‚Ñ€Ğ¸", bg: "#fadbd8", items: [{s:'ğŸ›¡ï¸',t:'Ğ©Ğ¸Ñ‚'}, {s:'ğŸ”ª',t:'ĞšĞ¸Ğ½Ğ´Ğ¶Ğ°Ğ»'}, {s:'ğŸ”¥',t:'Ğ’Ğ¾Ğ³Ğ¾Ğ½ÑŒ'}, {s:'ğŸ’§',t:'Ğ’Ğ¾Ğ´Ğ°'}, {s:'â„ï¸',t:'Ğ¡Ğ½Ñ–Ğ³'}, {s:'ğŸ§Ÿ',t:'Ğ—Ğ¾Ğ¼Ğ±Ñ–'}, {s:'ğŸª¨',t:'ĞšĞ°Ğ¼Ñ–Ğ½ÑŒ'}, {s:'ğŸ§¨',t:'Ğ”Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‚'}, {s:'ğŸ’£',t:'Ğ‘Ğ¾Ğ¼Ğ±Ğ°'}, {s:'âš—ï¸',t:'Ğ—Ñ–Ğ»Ğ»Ñ'}, {s:'ğŸ’',t:'ĞšÑ–Ğ»ÑŒÑ†Ğµ'}, {s:'ğŸ”®',t:'Ğ¡Ñ„ĞµÑ€Ğ°'}, {s:'ğŸ¦‚',t:'Ğ¡ĞºĞ¾Ñ€Ğ¿Ñ–Ğ¾Ğ½'}, {s:'ğŸ',t:'Ğ—Ğ¼Ñ–Ñ'}, {s:'ğŸ¦–',t:'Ğ¢Ñ–-Ğ ĞµĞºÑ'}, {s:'ğŸ¦ˆ',t:'ĞĞºÑƒĞ»Ğ°'}, {s:'ğŸ‘¾',t:'Ğ§ÑƒĞ¶Ğ¸Ğ¹'}, {s:'ğŸ‘º',t:'Ğ“Ğ¾Ğ±Ğ»Ñ–Ğ½'}, {s:'ğŸ²',t:'Ğ”Ñ€Ğ°ĞºĞ¾Ğ½'}, {s:'ğŸ¦„',t:'Ğ„Ğ´Ğ¸Ğ½Ğ¾Ñ€Ñ–Ğ³'}, {s:'ğŸ¦…',t:'Ğ“Ñ€Ğ¸Ñ„Ğ¾Ğ½'}, {s:'ğŸ•·ï¸',t:'ĞŸĞ°Ğ²ÑƒĞº'}, {s:'ğŸ¢',t:'Ğ§ĞµÑ€ĞµĞ¿Ğ°Ñ…Ğ°'}] },
            { name: "Mega: ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ñ–Ñ & ĞŸÑ€Ğ¸Ñ€Ğ¾Ğ´Ğ°", bg: "#d5f5e3", items: [{s:'ğŸŒµ',t:'ĞšĞ°ĞºÑ‚ÑƒÑ'}, {s:'ğŸ„',t:'Ğ“Ñ€Ğ¸Ğ±'}, {s:'ğŸŒ²',t:'Ğ”ĞµÑ€ĞµĞ²Ğ¾'}, {s:'ğŸ',t:'Ğ›Ğ¸ÑÑ‚'}, {s:'ğŸŒ‹',t:'Ğ’ÑƒĞ»ĞºĞ°Ğ½'}, {s:'ğŸŒ©ï¸',t:'Ğ“Ñ€Ğ¾Ğ·Ğ°'}, {s:'ğŸ§©',t:'ĞŸĞ°Ğ·Ğ»'}, {s:'ğŸ²',t:'ĞšÑƒĞ±Ğ¸Ğº'}, {s:'âš›ï¸',t:'ĞÑ‚Ğ¾Ğ¼'}, {s:'ğŸšœ',t:'Ğ¢Ñ€Ğ°ĞºÑ‚Ğ¾Ñ€'}, {s:'âš”ï¸',t:'ĞœĞµÑ‡Ñ–'}, {s:'ğŸ˜',t:'Ğ¡Ğ»Ğ¾Ğ½'}, {s:'ğŸŒ›',t:'ĞœÑ–ÑÑÑ†ÑŒ'}, {s:'â­',t:'Ğ—Ñ–Ñ€ĞºĞ°'}, {s:'ğŸª',t:'ĞŸĞ»Ğ°Ğ½ĞµÑ‚Ğ°'}, {s:'ğŸŒŒ',t:'Ğ“Ğ°Ğ»Ğ°ĞºÑ‚Ğ¸ĞºĞ°'}] }
        ];
const megaDefs = {
            'ğŸ•·ï¸': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide_jump', d:'knight'}] },
            'ğŸšœ': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1]]}] },
            'âš”ï¸': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸ˜': { t: 'complex', comps: [{t:'step', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸš€': { t: 'slide', dirs: [[0,-1]] },
            'âš“': { t: 'slide', dirs: [[0,1]] },
            'ğŸ¹': { t: 'slide', dirs: [[-1,-1],[1,-1]] },
            'ğŸ£': { t: 'slide', dirs: [[-1,1],[1,1]] },
            'ğŸ§œ': { t: 'slide', dirs: [[1,0],[-1,0]] },
            'âš¡': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'ğŸ¦¯': { t: 'slide', dirs: [[1,1],[-1,1],[1,-1],[-1,-1]], max: 2 },
            'ğŸ•¯ï¸': { t: 'slide', dirs: [[1,0],[-1,0],[0,1],[0,-1]], max: 3 },
            'ğŸ”±': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'ğŸŒŠ': { t: 'slide', dirs: [[0,-1]] },
            'ğŸ“œ': { t: 'slide', dirs: [[0,1]] },
            'ğŸ§¬': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'ğŸ—¡ï¸': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'ğŸŒµ': { t: 'step', dirs: 'king' },
            'ğŸ„': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'ğŸŒ²': { t: 'step', dirs: [[0,1],[0,-1]] },
            'ğŸ': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'ğŸŒ‹': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'ğŸŒ©ï¸': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'â„ï¸': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'ğŸ”¥': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]], mul:2}] },
            'ğŸ’§': { t: 'complex', comps: [{t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]], mul:2}] },
            'ğŸª¨': { t: 'none' },
            'ğŸ˜º': { t: 'jump', dirs: [[1,-2],[-1,-2]] },
            'ğŸº': { t: 'jump', dirs: 'knight' },
            'ğŸ¦Š': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'ğŸ—': { t: 'jump', dirs: [[0,-2]] },
            'ğŸ¦': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'ğŸƒ': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'ğŸŠ': { t: 'jump', dirs: [[3,3],[3,-3],[-3,3],[-3,-3]] },
            'ğŸŒ': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'ğŸ¦‘': { t: 'jump', dirs: [[4,0],[-4,0],[0,4],[0,-4]] },
            'ğŸ™': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[1,2],[1,-2],[-1,2],[-1,-2]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ğŸ¦‹': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ¢': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'ğŸ•': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'ğŸ¿ï¸': { t: 'jump', dirs: 'knight' },
            'ğŸ†': { t: 'slide', dirs: 'bishop' },
            'ğŸ¦“': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'ğŸ«': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'ğŸ¦’': { t: 'jump', dirs: [[4,1],[4,-1],[-4,1],[-4,-1],[1,4],[1,-4],[-1,4],[-1,-4]] },
            'ğŸ¦—': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0],[2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¦‡': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ¦€': { t: 'step', dirs: [[0,1],[0,-1],[2,0],[-2,0]] },
            'ğŸ§¨': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¦‚': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'step', d:[[0,1],[0,-1],[1,0],[-1,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ğŸ¦–': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ğŸ¦ˆ': { t: 'complex', comps: [{t:'slide', d:[[1,-1],[-1,-1]]}, {t:'slide', d:[[0,1]]}] },
            'ğŸ‘¾': { t: 'jump', dirs: [[1,3],[1,-3],[-1,3],[-1,-3],[3,1],[3,-1],[-3,1],[-3,-1]] },
            'ğŸ§Ÿ': { t: 'step', dirs: 'king' },
            'ğŸ‘º': { t: 'slide', dirs: 'bishop' },
            'ğŸ»': { t: 'step', dirs: 'king' },
            'ğŸ”®': { t: 'jump', dirs: [[2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ’': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,3],[3,-3],[-3,3],[-3,-3]]}] },
            'âš—ï¸': { t: 'jump', dirs: [[1,4],[1,-4],[-1,4],[-1,-4],[4,1],[4,-1],[-4,1],[-4,-1]] },
            'ğŸ’£': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0]] },
            'ğŸ§©': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ²': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[-2,-2]]}, {t:'jump', d:[[3,3],[-3,-3]]}] },
            'âš›ï¸': { t: 'jump', dirs: [[2,2],[-2,-2],[2,-2],[-2,2], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'ğŸ›¡ï¸': { t: 'step', dirs: [[1,0],[-1,0],[0,1],[0,-1]] },
            'ğŸ”ª': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ“¼': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ğŸ¤–': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'slide', d:[[1,1],[-1,1]]}] },
            'ğŸ›¸': { t: 'complex', comps: [{t:'slide', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸŒ›': { t: 'jump', dirs: [[2,3],[2,-3],[-2,3],[-2,-3],[3,2],[3,-2],[-3,2],[-3,-2]] },
            'â­': { t: 'jump', dirs: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2], [2,0],[-2,0],[0,2],[0,-2], [2,2],[-2,-2],[2,-2],[-2,2]] },
            'ğŸª': { t: 'jump', dirs: [[0,3],[0,-3],[3,0],[-3,0]] },
            'ğŸŒŒ': { t: 'jump', dirs: [[3,0],[-3,0],[0,3],[0,-3], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'ğŸ‘¨': { t: 'step', dirs: 'king' },
            'ğŸ‡': { t: 'complex', comps: [{t:'slide_jump', d:[[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'ğŸ‘¸': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸº': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] },
            'ğŸ‘®': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'ğŸŒªï¸': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ§›': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:[[3,0],[-3,0],[0,3],[0,-3]]}] },
            'ğŸ’‚': { t: 'step', dirs: [[0,-1],[1,0],[-1,0],[1,-1],[-1,-1],[1,1],[-1,1]] },
            'ğŸ‘·': { t: 'slide', dirs: 'rook', max: 2 },
            'ğŸ§': { t: 'slide', dirs: 'queen', max: 3 },
            'ğŸ§š': { t: 'slide', dirs: 'bishop', max: 2 },
            'â˜€ï¸': { t: 'slide', dirs: 'queen', max: 2 },
            'ğŸ§™': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]]}] },
            'ğŸ•µï¸': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ¥‹': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[1,-1],[-1,1]]}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'ğŸ¥·': { t: 'jump', dirs: [[1,1],[1,-1],[-1,1],[-1,-1], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¤´': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'rook'}] },
            'ğŸ‘¼': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'bishop'}] },
            'ğŸ¦„': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸ¦…': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'ğŸ²': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] }
        };

        const CHESS_SVGS = {
            'w_â™”': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#101010" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'w_â™•': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#101010" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'w_â™—': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#101010" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'w_â™˜': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#ffffff; stroke:#000000;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#ffffff; stroke:#000000;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#000000; stroke:#000000;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#000000; stroke:#000000;"/></g>`,
            'w_â™–': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#101010" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'w_â™™': `<g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`,
            'b_â™š': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#f9f9f9" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'b_â™›': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#f9f9f9" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'b_â™œ': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#f9f9f9" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'b_â™': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#f9f9f9" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'b_â™': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#000000; stroke:#ffffff;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#000000; stroke:#ffffff;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#ffffff; stroke:#ffffff;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#ffffff; stroke:#ffffff;"/></g>`,
            'b_â™Ÿ': `<g fill="#000" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`
        };

        const CLASSIC_MAP = {
            'â™”':'w_â™”', 'â™•':'w_â™•', 'â™–':'w_â™–', 'â™—':'w_â™—', 'â™˜':'w_â™˜', 'â™™':'w_â™™',
            'â™š':'b_â™š', 'â™›':'b_â™›', 'â™œ':'b_â™œ', 'â™':'b_â™', 'â™':'b_â™', 'â™Ÿ':'b_â™Ÿ'
        };
        const DIRS = {
            rook: [[0,1],[0,-1],[1,0],[-1,0]],
            bishop: [[1,1],[1,-1],[-1,1],[-1,-1]],
            queen: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            knight: [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]],
            king: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
        };

        const GRID_VOID = -999;

        class SmoothChess {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                this.boardSize = 32;
                this.cellSize = 60;

                this.camera = { x: 0, y: 0, zoom: 1 };
                
                // Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ targetCamera Ğ´Ğ»Ñ ÑÑ‚Ğ°Ğ±Ñ–Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ—
                this.targetCamera = { x: 0, y: 0, zoom: 1 }; 
                
                this.lerpFactor = 0.1;
                this.minZoom = 0.000001;
                this.maxZoom = 5.0;

                this.mouse = { x: 0, y: 0 };
                this.isDragging = false;
                this.isDraggingPiece = false;
                this.draggedPiece = null;
                this.lastMouse = { x: 0, y: 0 };
                this.isPainting = false;
                this.isGenerating = false;

                this.customArrows = []; // ĞœĞ°ÑĞ¸Ğ² ÑÑ‚Ñ€Ñ–Ğ»Ğ¾Ğº
                this.rmbStart = null;   // Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºÑƒ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ
                // --- PROMOTION STATE ---
                this.promotionPending = null;

                // --- KEYBOARD ---
                this.keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

                // Storage for MODIFIED pieces only.
                this.grid = new Map();

                // History for UNDO
                this.moveHistory = [];

                this.virtualGen = null;
                this.virtualProps = { percent: 25, mix: 0 };

                this.generationSeed = 0;

                this.palette = [];
                this.paletteMap = new Map();
                this.pieceCount = 0;
                this.kingPos = { w: null, b: null };

                this.curSymbol = 'â™”';
                this.curColor = 'w';

                this.rulesEnabled = true;
                this.turnModeEnabled = true;
                this.currentTurn = 'w';
                this.gameOver = false;
                this.multiJumpSource = null;

                this.highlightedMoves = [];
                this.kingsInCheck = { w: null, b: null };

                this.colors = {
                    light: '#eeeed2',
                    dark: 'rgba(80, 120, 60, 0.6)',
                    border: '#3a4a2b',
                    whiteP: '#ffffff',
                    blackP: '#000000',
                    neutralP: '#ffcc00',
                    highlight: 'rgba(0, 255, 0, 0.5)',
                    checkHighlight: 'rgba(255, 0, 0, 0.6)',
                    mateHighlight: 'rgba(75, 0, 130, 0.9)'
                };
                this.colors.void = this.colors.light;

                this.checkersSymbols = new Set(['â›€', 'â›', 'â›‚', 'â›ƒ']);
                this.spriteCache = new Map();
                this.lowResCache = new Map();
                this.spriteSize = 100;

                this.initUI();
                this.init();
                this.updateTurnIndicator();
            }
            // ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´: ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ĞºĞ¾Ğ½ĞµÑ† Ğ¿ÑƒÑ‚Ğ¸, Ğ¿ĞµÑ€ĞµĞ¿Ñ€Ñ‹Ğ³Ğ¸Ğ²Ğ°Ñ Ñ‡ĞµÑ€ĞµĞ· Ğ¿ÑƒÑÑ‚Ğ¾Ñ‚Ñƒ
            findRayEnd(cx, cy, dx, dy, maxSteps) {
                // 1. Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ğ¼ĞµĞ¶Ñ– "Ğ¿Ğ¾Ñ€Ğ¾Ğ¶Ğ½ĞµÑ‡Ñ–"
                let jumpStart = -1, jumpEnd = -1;
                let hasVoid = false;

                if (this.virtualGen && this.virtualGen !== 'chess960') {
                     const rows = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                     jumpStart = rows; 
                     jumpEnd = this.boardSize - rows;
                     if (jumpEnd > jumpStart) hasVoid = true;
                }

                let x = cx;
                let y = cy;
                
                // Ğ¯Ğº Ğ´Ğ°Ğ»ĞµĞºĞ¾ Ğ´Ğ¾ ĞºÑ€Ğ°Ñ Ğ´Ğ¾ÑˆĞºĞ¸ Ğ² Ñ†ÑŒĞ¾Ğ¼Ñƒ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ĞºÑƒ?
                let distToEdge = this.boardSize;
                if (dx > 0) distToEdge = this.boardSize - 1 - cx;
                else if (dx < 0) distToEdge = cx;
                
                if (dy > 0) distToEdge = Math.min(distToEdge, this.boardSize - 1 - cy);
                else if (dy < 0) distToEdge = Math.min(distToEdge, cy);

                // --- Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯: Ğ’Ñ€Ğ°Ñ…Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ¾Ğ±Ğ¼ĞµĞ¶ĞµĞ½Ğ½Ñ ĞºÑ€Ğ¾ĞºÑ–Ğ² (maxSteps) ---
                if (maxSteps) {
                    distToEdge = Math.min(distToEdge, maxSteps);
                }
                // -----------------------------------------------------------

                let endX = cx + dx * distToEdge;
                let endY = cy + dy * distToEdge;
                
                // ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ: Ğ§Ğ¸ Ğ¿ĞµÑ€ĞµÑ‚Ğ¸Ğ½Ğ°Ñ”Ğ¼Ğ¾ Ğ¼Ğ¸ Ğ·Ğ¾Ğ½Ñƒ, Ğ´Ğµ Ğ¼Ğ¾Ğ¶ÑƒÑ‚ÑŒ Ğ±ÑƒÑ‚Ğ¸ Ğ²Ğ¾Ñ€Ğ¾Ğ³Ğ¸
                if (hasVoid) {
                    if (dy > 0 && y < jumpEnd) {
                        const distToArmy = jumpEnd - y;
                        if (distToEdge >= distToArmy) {
                            const hitX = x + dx * distToArmy;
                            const hitY = y + dy * distToArmy;
                            return { x: hitX, y: hitY, hit: true, ally: false }; 
                        }
                    }
                    else if (dy < 0 && y >= jumpStart) {
                        const distToArmy = y - (jumpStart - 1);
                        if (distToEdge >= distToArmy) {
                            const hitX = x + dx * distToArmy;
                            const hitY = y + dy * distToArmy;
                            return { x: hitX, y: hitY, hit: true, ally: false };
                        }
                    }
                }

                return { x: endX, y: endY, hit: false, edge: true };
            }

            initUI() {
                const container = document.getElementById('pieceContainer');
                container.innerHTML = '';

                PIECE_CATEGORIES.forEach(cat => {
                    const block = document.createElement('div');
                    block.className = 'category-block';
                    if(cat.bg) block.style.backgroundColor = cat.bg;
                    const header = document.createElement('div');
                    header.className = 'grid-header';
                    header.innerText = cat.name;
                    block.appendChild(header);
                    const grid = document.createElement('div');
                    grid.className = 'piece-grid';

                    cat.items.forEach(item => {
                        const btn = document.createElement('button');
                        btn.className = `piece-btn ${item.cls || ''}`;
                        if(item.s === 'âŒ') btn.classList.add('eraser');

                        btn.innerText = item.s;
                        btn.title = item.t;
                        btn.dataset.s = item.s;
                        btn.dataset.c = item.color || 'w';
                        btn.addEventListener('click', () => {
                            document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            this.curSymbol = btn.dataset.s;
                            this.curColor = btn.dataset.c;
                        });
                        if(item.s === 'â™”' && item.color !== 'b') btn.classList.add('selected');
                        grid.appendChild(btn);
                    });
                    block.appendChild(grid);
                    container.appendChild(block);
                });
            }

            init() {
                this.setSize(32);
                this.resize();
                window.addEventListener('resize', () => { this.resize(); });
                this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
                this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
                window.addEventListener('mousemove', e => this.onMouseMove(e));
                window.addEventListener('mouseup', e => this.onMouseUp(e));
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());

                window.addEventListener('keydown', e => {
                    if (e.key === 'Delete') {
                        this.undoMove();
                    } else {
                        this.onKeyDown(e);
                        if(this.keys.hasOwnProperty(e.code)) {
                            this.keys[e.code] = true;
                            e.preventDefault();
                        }
                    }
                });
                window.addEventListener('keyup', e => {
                    if(this.keys.hasOwnProperty(e.code)) this.keys[e.code] = false;
                });

                document.getElementById('boardSize').addEventListener('change', e => this.setSize(e.target.value));
                document.getElementById('zoomSlider').addEventListener('input', e => {
                    this.targetZoom = Math.pow(10, parseFloat(e.target.value));
                });
                document.getElementById('fantasyMix').addEventListener('input', (e) => {
                    document.getElementById('fantasyPercentDisplay').innerText = e.target.value + '%';
                });

                this.lastTime = performance.now();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.centerBoard();
            }

            getPaletteId(s, c) {
                const key = s + c;
                if (!this.paletteMap.has(key)) {
                    this.palette.push({ s, c });
                    this.paletteMap.set(key, this.palette.length);
                }
                return this.paletteMap.get(key);
            }

            getKey(c, r) {
                return c + "," + r;
            }

            getCoordString(c, r) {
                let label = "";
                let index = c + 1;
                while (index > 0) {
                    let rem = (index - 1) % 26;
                    label = String.fromCharCode(97 + rem) + label;
                    index = Math.floor((index - 1) / 26);
                }
                return label + (this.boardSize - r);
            }

            addLogToUI(pieceIcon, startCoord, endCoord, isCapture) {
                const list = document.getElementById('logList');
                // Remove default placeholder if exists
                if (list.children.length === 1 && list.children[0].innerText === 'Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ”') {
                    list.innerHTML = '';
                }

                const div = document.createElement('div');
                div.className = 'log-entry';

                const moveText = `<span class="move">${pieceIcon}</span> ${startCoord} â†’ ${endCoord}`;
                const capText = isCapture ? `<span class="capture">âš”ï¸</span>` : '';

                div.innerHTML = `${moveText} ${capText}`;
                list.prepend(div); // Newest first
            }

            removeLastLogEntry() {
                const list = document.getElementById('logList');
                if (list.children.length > 0) {
                    list.removeChild(list.firstElementChild);
                }
                if (list.children.length === 0) {
                    list.innerHTML = '<div class="log-entry" style="color:#999; justify-content:center;">Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ”</div>';
                }
            }

            setSize(n) {
                // ĞŸÑ€Ğ¸Ğ±Ğ¸Ñ€Ğ°Ñ”Ğ¼Ğ¾ Ğ²ĞµÑ€Ñ…Ğ½Ñ” Ğ¾Ğ±Ğ¼ĞµĞ¶ĞµĞ½Ğ½Ñ. 
                // Ğ—Ğ°Ğ»Ğ¸ÑˆĞ°Ñ”Ğ¼Ğ¾ Ğ»Ğ¸ÑˆĞµ Ğ¼Ñ–Ğ½Ñ–Ğ¼Ğ°Ğ»ÑŒĞ½Ğµ (2), Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ·Ğ»Ğ°Ğ¼Ğ°Ñ‚Ğ¸ Ğ³Ñ€Ñƒ Ğ²Ñ–Ğ´'Ñ”Ğ¼Ğ½Ğ¸Ğ¼Ğ¸ Ñ‡Ğ¸ÑĞ»Ğ°Ğ¼Ğ¸.
                this.boardSize = Math.max(2, parseInt(n) || 32);
                
                // ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ Ğ² Ğ¿Ğ¾Ğ»Ñ– Ğ²Ğ²Ğ¾Ğ´Ñƒ
                document.getElementById('boardSize').value = this.boardSize;

                this.grid.clear();
                this.moveHistory = [];
                this.virtualGen = null;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';

                this.resetGame();
                this.centerBoard();
            }

            centerBoard() {
                const boardPx = this.boardSize * this.cellSize;
                const screenW = this.canvas.width;
                const screenH = this.canvas.height;
                
                const fitScaleX = screenW / boardPx;
                const fitScaleY = screenH / boardPx;
                const fitZoom = Math.min(fitScaleX, fitScaleY);

                this.minZoom = fitZoom * 0.8; 
                if (this.minZoom > this.maxZoom) this.minZoom = this.maxZoom / 2;

                const startZoom = fitZoom * 0.95;
                
                // Ğ¦ĞµĞ½Ñ‚Ñ€ÑƒÑ”Ğ¼Ğ¾
                const startX = (screenW - boardPx * startZoom) / 2;
                const startY = (screenH - boardPx * startZoom) / 2;

                // Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ¾
                this.camera.x = startX;
                this.camera.y = startY;
                this.camera.zoom = startZoom;

                // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğ¶ Ñ†Ñ–Ğ»Ñ–
                this.targetCamera.x = startX;
                this.targetCamera.y = startY;
                this.targetCamera.zoom = startZoom;

                const slider = document.getElementById('zoomSlider');
                slider.min = Math.log10(this.minZoom);
                slider.value = Math.log10(startZoom);
            }

            clampCamera() {
                // Ğ’Ğ†Ğ›Ğ¬ĞĞ• ĞŸĞ•Ğ Ğ•ĞœĞ†Ğ©Ğ•ĞĞĞ¯ Ğ— ĞœĞ•Ğ–ĞĞœĞ˜ (ĞĞĞ¢Ğ˜-ĞŸĞ£Ğ¡Ğ¢ĞĞ¢Ğ)
                
                const boardPx = this.boardSize * this.cellSize * this.camera.zoom;
                const screenW = this.canvas.width;
                const screenH = this.canvas.height;

                // "Ğ¡Ñ‚Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ñ‚Ñ€Ğ¾Ñ":
                // ĞœĞ¸ Ñ…Ğ¾Ñ‡ĞµĞ¼Ğ¾, Ñ‰Ğ¾Ğ± Ñ…Ğ¾Ñ‡Ğ° Ğ± 150 Ğ¿Ñ–ĞºÑĞµĞ»Ñ–Ğ² Ğ´Ğ¾ÑˆĞºĞ¸ (Ğ°Ğ±Ğ¾ Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ğ° Ñ—Ñ— Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€Ñƒ, ÑĞºÑ‰Ğ¾ Ğ²Ğ¾Ğ½Ğ° Ğ´ÑƒĞ¶Ğµ Ğ¼Ğ°Ğ»Ğ°)
                // Ğ·Ğ°Ğ²Ğ¶Ğ´Ğ¸ Ğ·Ğ°Ğ»Ğ¸ÑˆĞ°Ğ»Ğ¸ÑÑ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¸Ğ¼Ğ¸ Ğ½Ğ° ĞµĞºÑ€Ğ°Ğ½Ñ–.
                const safeZone = Math.min(150, boardPx / 2);

                // Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº Ğ¼ĞµĞ¶:
                // 1. Min X: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ Ğ´Ğ¾ÑˆĞºĞ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğµ Ğ¿Ñ–Ñ‚Ğ¸ Ğ·Ğ° Ğ»Ñ–Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ ĞµĞºÑ€Ğ°Ğ½Ñƒ (Ğ·Ğ°Ğ»Ğ¸ÑˆĞ°Ñ”Ğ¼Ğ¾ safeZone)
                //    Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: camera.x + boardPx >= safeZone  =>  camera.x >= safeZone - boardPx
                const minX = safeZone - boardPx;

                // 2. Max X: Ğ›Ñ–Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ Ğ´Ğ¾ÑˆĞºĞ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğµ Ğ¿Ñ–Ñ‚Ğ¸ Ğ·Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ ĞµĞºÑ€Ğ°Ğ½Ñƒ
                //    Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: camera.x <= screenW - safeZone
                const maxX = screenW - safeZone;

                // 3. Ğ¢Ğµ ÑĞ°Ğ¼Ğµ Ğ´Ğ»Ñ Y (Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒ)
                const minY = safeZone - boardPx;
                const maxY = screenH - safeZone;

                // Ğ—Ğ°ÑÑ‚Ğ¾ÑĞ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ¼Ñ–Ñ‚Ğ¸ Ğ´Ğ¾ Ğ¦Ğ†Ğ›Ğ† (Ğ´Ğ»Ñ Ğ°Ğ½Ñ–Ğ¼Ğ°Ñ†Ñ–Ñ—)
                if (this.targetCamera.x < minX) this.targetCamera.x = minX;
                if (this.targetCamera.x > maxX) this.targetCamera.x = maxX;
                if (this.targetCamera.y < minY) this.targetCamera.y = minY;
                if (this.targetCamera.y > maxY) this.targetCamera.y = maxY;

                // Ğ—Ğ°ÑÑ‚Ğ¾ÑĞ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ¼Ñ–Ñ‚Ğ¸ Ğ´Ğ¾ ĞŸĞĞ¢ĞĞ§ĞĞĞ‡ ĞºĞ°Ğ¼ĞµÑ€Ğ¸ (Ğ´Ğ»Ñ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ¾Ñ— Ñ€ĞµĞ°ĞºÑ†Ñ–Ñ— Ğ¼Ğ¸ÑˆĞºĞ¸)
                if (this.camera.x < minX) this.camera.x = minX;
                if (this.camera.x > maxX) this.camera.x = maxX;
                if (this.camera.y < minY) this.camera.y = minY;
                if (this.camera.y > maxY) this.camera.y = maxY;
            }
            onWheel(e) {
                if (this.promotionPending) return;
                e.preventDefault();

                // 1. Ğ”Ğµ Ğ¼Ğ¸ÑˆĞºĞ° Ğ·Ğ°Ñ€Ğ°Ğ· (Ğ½Ğ° ĞµĞºÑ€Ğ°Ğ½Ñ–)
                const mx = e.clientX;
                const my = e.clientY;

                // 2. Ğ”Ğµ Ğ¼Ğ¸ÑˆĞºĞ° Ñƒ "Ğ¡Ğ²Ñ–Ñ‚Ñ–" (Ğ½Ğ° Ğ´Ğ¾ÑˆÑ†Ñ–) Ğ· ĞŸĞĞ¢ĞĞ§ĞĞ˜Ğœ Ğ·ÑƒĞ¼Ğ¾Ğ¼
                // Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸ this.camera (Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğµ), Ğ° Ğ½Ğµ target
                const worldX = (mx - this.camera.x) / this.camera.zoom;
                const worldY = (my - this.camera.y) / this.camera.zoom;

                // 3. Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ ĞĞĞ’Ğ˜Ğ™ Ğ·ÑƒĞ¼
                const sensitivity = 0.0015; // Ğ§ÑƒÑ‚Ğ»Ğ¸Ğ²Ñ–ÑÑ‚ÑŒ
                let newZoom = this.targetCamera.zoom * (1 - e.deltaY * sensitivity);
                newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));

                // 4. ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ñ†Ñ–Ğ»ÑŒ Ğ´Ğ»Ñ Ğ·ÑƒĞ¼Ñƒ
                this.targetCamera.zoom = newZoom;

                // 5. ĞœĞĞ“Ğ†Ğ¯ Ğ¡Ğ¢ĞĞ‘Ğ†Ğ›Ğ†Ğ—ĞĞ¦Ğ†Ğ‡:
                // Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾, Ğ´Ğµ Ğ¿Ğ¾Ğ²Ğ¸Ğ½Ğ½Ğ° Ğ±ÑƒÑ‚Ğ¸ ĞºĞ°Ğ¼ĞµÑ€Ğ° (X, Y), Ñ‰Ğ¾Ğ± Ñ‚Ğ¾Ñ‡ĞºĞ° worldX 
                // Ğ·Ğ°Ğ»Ğ¸ÑˆĞ¸Ğ»Ğ°ÑÑ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ–Ğ´ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼ (mx) Ğ¿Ñ€Ğ¸ ĞĞĞ’ĞĞœĞ£ Ğ·ÑƒĞ¼Ñ– (newZoom).
                // Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: Screen = Cam + World * Zoom  =>  Cam = Screen - World * Zoom
                
                this.targetCamera.x = mx - worldX * newZoom;
                this.targetCamera.y = my - worldY * newZoom;
            }

            isDarkSquare(c, r) { return (c + r) % 2 !== 0; }

            getPieceSprite(symbol, color) {
                const key = `${symbol}_${color}`;
                if (this.spriteCache.has(key)) return this.spriteCache.get(key);

                // Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑƒÑ”Ğ¼Ğ¾ Ñ€Ğ¾Ğ·Ğ´Ñ–Ğ»ÑŒĞ½Ñƒ Ğ·Ğ´Ğ°Ñ‚Ğ½Ñ–ÑÑ‚ÑŒ Ğ´Ğ»Ñ Ñ‡Ñ–Ñ‚ĞºĞ¾ÑÑ‚Ñ–
                this.spriteSize = 256;

                const c = document.createElement('canvas');
                c.width = this.spriteSize;
                c.height = this.spriteSize;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();

                    // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ width/height Ñ– viewBox 0 0 45 45, Ñ‰Ğ¾Ğ± Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ñ€Ğ¾Ğ·Ñ‚ÑĞ³Ğ½ÑƒĞ»Ğ°ÑÑŒ Ğ½Ğ° Ğ²ĞµÑÑŒ ÑĞ¿Ñ€Ğ°Ğ¹Ñ‚
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${this.spriteSize}" height="${this.spriteSize}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0, 0, this.spriteSize, this.spriteSize);
                        ctx.drawImage(img, 0, 0, this.spriteSize, this.spriteSize);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;

                } else {
                    // Ğ”Ğ»Ñ Ñ„ĞµĞ½Ñ‚ĞµĞ·Ñ– Ñ„Ñ–Ğ³ÑƒÑ€
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `bold ${this.spriteSize * 0.8}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.lineWidth = this.spriteSize * 0.05; ctx.lineJoin = 'round';
                    const cx = this.spriteSize / 2; const cy = this.spriteSize / 2 * 1.1;

                    if (isWhite) ctx.strokeStyle = '#000000';
                    else if (isBlack) ctx.strokeStyle = '#ffffff';
                    else ctx.strokeStyle = '#333333';

                    ctx.strokeText(symbol, cx, cy);
                    ctx.fillStyle = isWhite ? this.colors.whiteP : (isBlack ? this.colors.blackP : this.colors.neutralP);
                    ctx.fillText(symbol, cx, cy);
                }

                this.spriteCache.set(key, c);
                return c;
            }

            getLowResSprite(symbol, color) {
                const key = `${symbol}_${color}_lo`;
                if (this.lowResCache.has(key)) return this.lowResCache.get(key);

                // Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑƒÑ”Ğ¼Ğ¾ ÑĞºÑ–ÑÑ‚ÑŒ "Ğ½Ğ¸Ğ·ÑŒĞºĞ¾Ñ— Ñ€Ğ¾Ğ·Ğ´Ñ–Ğ»ÑŒĞ½Ğ¾Ñ— Ğ·Ğ´Ğ°Ñ‚Ğ½Ğ¾ÑÑ‚Ñ–"
                const size = 128;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();
                    // Ğ¢ĞµĞ¶ ÑĞ°Ğ¼Ğµ: Ñ„Ñ–ĞºÑÑƒÑ”Ğ¼Ğ¾ Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€ SVG Ğ¿Ñ–Ğ´ ĞºĞ°Ğ½Ğ²Ğ°Ñ
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0,0,size,size);
                        ctx.drawImage(img, 0, 0, size, size);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;
                } else {
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `${size}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    const cx = size / 2; const cy = size / 2 * 1.1;
                    ctx.fillStyle = isWhite ? '#fff' : (isBlack ? '#000' : '#fa0');
                    ctx.fillText(symbol, cx, cy);
                }

                this.lowResCache.set(key, c);
                return c;
            }

            pseudoRandom(x, y) {
                return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
            }

            getPiece(c, r) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return null;

                const key = this.getKey(c, r);
                const val = this.grid.get(key);

                if (val !== undefined) {
                    if (val === GRID_VOID) return null;
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    return { x: c, y: r, s: p.s, c: p.c, hasMoved: hasMoved };
                }

                if (this.virtualGen) {
                    return this.getVirtualPiece(c, r);
                }

                return null;
            }

            getVirtualPiece(c, r) {
                if (this.virtualGen === 'checkers') {
                     const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                     const armyHeight = rowsCalc;
                     if (!this.isDarkSquare(c, r)) return null;

                     if (r < armyHeight) return { x:c, y:r, s:'â›‚', c:'b' };
                     if (r >= this.boardSize - armyHeight) return { x:c, y:r, s:'â›€', c:'w' };
                     return null;
                }

                const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                const armyHeight = Math.max(2, rowsCalc);
                const whiteStart = this.boardSize - armyHeight;

                let relativeRow = -1;
                let color = '';

                // Identify if this row belongs to an army and normalize row index
                if (r < armyHeight) {
                    color = 'b';
                    relativeRow = r;
                } else if (r >= whiteStart) {
                    color = 'w';
                    relativeRow = (this.boardSize - 1) - r; // Mirror row index
                } else {
                    return null;
                }

                return this.generateProceduralPiece(c, relativeRow, color, armyHeight);
            }

            generateProceduralPiece(c, relativeRow, color, height) {
                // 1. Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€ Ğ´Ğ»Ñ ĞšĞ¾Ñ€Ğ¾Ğ»Ñ (Ğ±ĞµĞ·Ğ¿ĞµĞºĞ°)
                let armyCenterCol = Math.floor(this.boardSize / 2);

                if (this.virtualGen === '3player') {
                    if (color === 'b') armyCenterCol = Math.floor((this.boardSize / 2) / 2);
                    else if (color === 'r') {
                        const mid = Math.floor(this.boardSize / 2);
                        armyCenterCol = mid + Math.floor((this.boardSize - mid) / 2);
                    }
                }

                // Ğ—Ğ°Ğ²Ğ¶Ğ´Ğ¸ ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ "Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾" ĞºĞ¾Ñ€Ğ¾Ğ»Ñ Ğ¿Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ñƒ (Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ñ–ĞºĞ¸ Ğ³Ñ€Ğ¸)
                if (c === armyCenterCol && relativeRow === 0) {
                    return { x: c, y: -1, s: color === 'w' ? 'â™”' : 'â™š', c: color };
                }
                
                // --- ĞĞĞ’Ğ Ğ›ĞĞ“Ğ†ĞšĞ Ğ”Ğ›Ğ¯ ĞĞ ĞœĞ†Ğ‡ (Ğ©Ğ¾Ğ± Ğ½Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ°Ğ»Ğ¾) ---
                if (this.virtualGen === 'army') {
                    // ĞŸĞ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ğ° Ñ€ÑĞ´Ñ–Ğ² - Ğ¾Ñ„Ñ–Ñ†ĞµÑ€Ğ¸, Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ğ° - Ğ¿Ñ–ÑˆĞ°ĞºĞ¸
                    const officerRows = Math.floor(height / 2);
                    
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ– Ñ€ÑĞ´Ğ¸ - ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ ĞŸÑ–ÑˆĞ°ĞºÑ–Ğ²
                    if (relativeRow >= officerRows) {
                         return { x: c, y: -1, s: color === 'w' ? 'â™™' : 'â™Ÿ', c: color };
                    }
                    
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ·Ğ°Ğ´Ğ½Ñ– Ñ€ÑĞ´Ğ¸ - ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ğ¿Ğ°Ñ‚ĞµÑ€Ğ½ ĞÑ„Ñ–Ñ†ĞµÑ€Ñ–Ğ²
                    const pattern = ['â™–', 'â™˜', 'â™—', 'â™•', 'â™”', 'â™—', 'â™˜', 'â™–'];
                    const mirrorMap = { 'â™–':'â™œ', 'â™˜':'â™', 'â™—':'â™', 'â™•':'â™›', 'â™”':'â™š' };
                    
                    let sym = pattern[c % 8]; // ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ¶Ğ½Ñ– 8 ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ğ¾Ğº
                    if (color !== 'w') sym = mirrorMap[sym]; // Ğ”Ğ»Ñ Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ…/Ñ‡ĞµÑ€Ğ²Ğ¾Ğ½Ğ¸Ñ…
                    
                    return { x: c, y: -1, s: sym, c: color };
                }
                // -----------------------------------------------

                // Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ– Ğ¿Ñ–ÑˆĞ°ĞºĞ¸ Ğ´Ğ»Ñ Ñ–Ğ½ÑˆĞ¸Ñ… Ñ€ĞµĞ¶Ğ¸Ğ¼Ñ–Ğ² (Classic/Fantasy)
                if (relativeRow === height - 1) {
                    return { x: c, y: -1, s: color === 'w' ? 'â™™' : 'â™Ÿ', c: color };
                }

                // Ğ›Ğ¾Ğ³Ñ–ĞºĞ° Ğ´Ğ»Ñ Classic/Fantasy (Random)
                const classicMajors = ['â™–', 'â™˜', 'â™—', 'â™•'];
                const mirrorMap = { 'â™–': 'â™œ', 'â™˜': 'â™', 'â™—': 'â™', 'â™•': 'â™›' };
                const fantasyMajors = ['ğŸ¦„', 'ğŸ¦…', 'ğŸ²', 'ğŸ•·ï¸', 'ğŸ¢', 'ğŸ§¨', 'ğŸ«', 'ğŸ¦“', 'ğŸ¦’', 'ğŸ˜', 'ğŸšœ', 'âš”ï¸', 'ğŸ›¡ï¸', 'ğŸ‘¨', 'ğŸ¦—', 'ğŸ¦‡', 'ğŸ¹', 'ğŸ»', 'ğŸ•', 'ğŸ¦€', 'ğŸ†', 'ğŸ¿ï¸', 'ğŸ¤´', 'ğŸ‘¼', 'ğŸ‘º', 'ğŸ„', 'ğŸŒµ', 'ğŸŒ²', 'ğŸ', 'ğŸŒ‹', 'ğŸŒŠ', 'ğŸŒªï¸', 'ğŸŒ©ï¸', 'ğŸ¦‚', 'ğŸ', 'ğŸ¦–', 'ğŸ¦ˆ', 'ğŸ', 'ğŸ¦‹', 'ğŸ™', 'ğŸ‘¾', 'ğŸ—¡ï¸', 'ğŸ”®', 'ğŸ“œ', 'ğŸ’', 'âš—ï¸', 'ğŸ’£', 'ğŸ§©', 'ğŸ²', 'ğŸ§¬', 'âš›ï¸', ...Object.keys(megaDefs)];
                
                const seed = c * 49297 + relativeRow * 9301 + this.generationSeed;
                const rnd = Math.abs(Math.sin(seed) * 10000) % 100;
                let symbol;

                if (this.virtualGen === 'fantasy' && rnd < this.virtualProps.mix) {
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 5) * fantasyMajors.length);
                    symbol = fantasyMajors[idx];
                } else {
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 7) * classicMajors.length);
                    let base = classicMajors[idx];
                    if (color !== 'w') symbol = mirrorMap[base];
                    else symbol = base;
                }
                return { x: c, y: -1, s: symbol, c: color };
            }

            setPiece(c, r, data) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return;
                const key = this.getKey(c, r);

                if (!data) {
                    if (this.virtualGen) {
                        this.grid.set(key, GRID_VOID);
                    } else {
                        this.grid.delete(key);
                    }
                    return;
                }

                const paletteId = this.getPaletteId(data.s, data.c);
                const hasMovedBit = (data.hasMoved ? 1 : 0) << 16;
                this.grid.set(key, paletteId | hasMovedBit);

                if (data.s === 'â™”' && data.c === 'w') this.kingPos.w = {c, r};
                if (data.s === 'â™š' && data.c === 'b') this.kingPos.b = {c, r};
            }

            removePiece(c, r) { this.setPiece(c, r, null); }
            
            updateLogUI() {
                const tbody = document.getElementById('logTableBody');
                if (!tbody) return;
                tbody.innerHTML = '';
                
                let moveCount = 1;
                let currentRow = null;

                this.moveHistory.forEach((step) => {
                    const not = step.notation;
                    if (!not) return; // ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ ÑÑ‚Ğ°Ñ€Ñ–/Ğ±Ğ¸Ñ‚Ñ– Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸

                    const moveHTML = `<span class="move-icon">${not.icon}</span><span class="move-coords">${not.start}â†’${not.end}</span>${not.cap ? '<span class="move-cap">x</span>' : ''}`;

                    if (step.turn === 'w') {
                        // Ğ¥Ñ–Ğ´ Ğ±Ñ–Ğ»Ğ¸Ñ… - ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ”Ğ¼Ğ¾ Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ñ€ÑĞ´Ğ¾Ğº
                        currentRow = document.createElement('tr');
                        currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>${moveHTML}</td><td></td>`;
                        tbody.appendChild(currentRow);
                    } else {
                        // Ğ¥Ñ–Ğ´ Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ…
                        if (!currentRow) {
                            // Ğ¯ĞºÑ‰Ğ¾ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ğ¿Ğ¾Ñ‡Ğ°Ğ»Ğ°ÑÑ Ğ· Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ… (Ñ€Ñ–Ğ´ĞºÑ–ÑĞ½Ğ¸Ğ¹ Ğ²Ğ¸Ğ¿Ğ°Ğ´Ğ¾Ğº)
                            currentRow = document.createElement('tr');
                            currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>...</td><td></td>`;
                            tbody.appendChild(currentRow);
                        }
                        currentRow.children[2].innerHTML = moveHTML;
                        moveCount++;
                        currentRow = null;
                    }
                });
                
                // ĞŸÑ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ° Ğ²Ğ½Ğ¸Ğ·
                const container = document.getElementById('logContainer');
                if(container) container.scrollTop = container.scrollHeight;
            }

            resetGame() {
                this.customArrows = [];

                this.grid.clear();
                this.moveHistory = [];
                this.pieceCount = 0;
                this.currentTurn = 'w'; this.gameOver = false;
                this.multiJumpSource = null;
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.updateUI(); 
                this.updateTurnIndicator();
                this.updateLogUI(); // <--- Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ–
            }

            fillCheckers() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.virtualGen = 'checkers';
                this.virtualProps.percent = percent;
                this.updateUI();
            }

            fillClassic() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'classic';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = 0;
                this.updateUI();
            }
            fillArmy() {
                // ĞÑ‚Ñ€Ğ¸Ğ¼ÑƒÑ”Ğ¼Ğ¾ Ğ²Ñ–Ğ´ÑĞ¾Ñ‚Ğ¾Ğº Ğ·Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½Ñ
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; 
                if (percent > 50) percent = 50;

                this.resetGame();
                
                // Ğ’ĞœĞ˜ĞšĞĞ„ĞœĞ Ğ’Ğ†Ğ Ğ¢Ğ£ĞĞ›Ğ¬ĞĞ£ Ğ“Ğ•ĞĞ•Ğ ĞĞ¦Ğ†Ğ® Ğ—ĞĞœĞ†Ğ¡Ğ¢Ğ¬ Ğ¦Ğ˜ĞšĞ›Ğ£
                this.virtualGen = 'army'; 
                this.virtualProps.percent = percent;
                
                this.updateUI();
                console.log("Mode: Army (Optimized/Virtual)");
            }
            fillChess960() {
                this.resetGame();
                this.virtualGen = null; // Ğ’Ğ¸Ğ¼Ğ¸ĞºĞ°Ñ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ´ÑƒÑ€Ğ½Ñƒ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ

                // Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¸ Ñ€ÑĞ´Ñ–Ğ²
                const whiteRow = this.boardSize - 1;
                const whitePawnRow = this.boardSize - 2;
                const blackRow = 0;
                const blackPawnRow = 1;

                // Ğ¯ĞºÑ‰Ğ¾ Ğ´Ğ¾ÑˆĞºĞ° ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ° (8 ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ğ¾Ğº) â€” ĞºĞ»Ğ°ÑĞ¸Ñ‡Ğ½Ğ¸Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ 960
                // Ğ¯ĞºÑ‰Ğ¾ Ğ²ĞµĞ»Ğ¸ĞºĞ° â€” Ñ€Ğ¾Ğ·ÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼
                const width = this.boardSize;
                let rank = new Array(width).fill(null);
                let available = Array.from({length: width}, (_, i) => i);

                // --- Ğ›ĞĞ“Ğ†ĞšĞ Ğ“Ğ•ĞĞ•Ğ ĞĞ¦Ğ†Ğ‡ ---

                // 1. ĞšĞĞ ĞĞ›Ğ¬: Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ğ´ĞµÑÑŒ Ğ±Ğ»Ğ¸Ğ¶Ñ‡Ğµ Ğ´Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ñƒ
                // Ğ©Ğ¾Ğ± Ğ½Ğµ Ğ·Ğ°Ğ³Ğ½Ğ°Ñ‚Ğ¸ Ğ¹Ğ¾Ğ³Ğ¾ Ğ² ĞºÑƒÑ‚ Ğ½Ğ° Ğ´Ğ¾ÑˆÑ†Ñ– 100Ñ…100
                const centerStart = Math.floor(width * 0.3);
                const centerEnd = Math.floor(width * 0.7);
                const possibleKingSpots = available.filter(i => i >= centerStart && i <= centerEnd);
                
                const kIdx = Math.floor(Math.random() * possibleKingSpots.length);
                const kPos = possibleKingSpots[kIdx];
                rank[kPos] = 'â™”';
                
                // Ğ’Ğ¸Ğ´Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ Ğ·Ñ– ÑĞ¿Ğ¸ÑĞºÑƒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ñ…
                available = available.filter(i => i !== kPos);

                // 2. Ğ¢Ğ£Ğ Ğ˜: ĞœÑ–Ğ½Ñ–Ğ¼ÑƒĞ¼ Ğ¾Ğ´Ğ½Ğ° Ğ·Ğ»Ñ–Ğ²Ğ° Ñ– Ğ¾Ğ´Ğ½Ğ° ÑĞ¿Ñ€Ğ°Ğ²Ğ° Ğ²Ñ–Ğ´ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ
                const leftSide = available.filter(i => i < kPos);
                const rightSide = available.filter(i => i > kPos);

                if (leftSide.length === 0 || rightSide.length === 0) {
                    // Ğ¦Ğµ Ñ‚ĞµĞ¾Ñ€ĞµÑ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ½ĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ centerStart, Ğ°Ğ»Ğµ Ğ¿Ñ€Ğ¾ Ğ²ÑÑĞº Ğ²Ğ¸Ğ¿Ğ°Ğ´Ğ¾Ğº
                    alert("ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ— (Ğ·Ğ°Ğ¼Ğ°Ğ»Ğ° Ğ´Ğ¾ÑˆĞºĞ°)"); 
                    return;
                }

                const r1 = leftSide[Math.floor(Math.random() * leftSide.length)];
                const r2 = rightSide[Math.floor(Math.random() * rightSide.length)];
                rank[r1] = 'â™–';
                rank[r2] = 'â™–';
                
                // ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ available
                available = available.filter(i => i !== r1 && i !== r2);

                // 3. Ğ¡Ğ›ĞĞĞ˜: Ğ“ĞµĞ½ĞµÑ€ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼Ğ¸ (Ñ€Ñ–Ğ·Ğ½Ğ¾ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ğ¾Ğ²Ğ¸Ğ¼Ğ¸)
                // ĞĞ° Ğ²ĞµĞ»Ğ¸ĞºĞ¸Ñ… Ğ´Ğ¾ÑˆĞºĞ°Ñ… ÑĞ»Ğ¾Ğ½Ñ–Ğ² Ğ¼Ğ°Ñ” Ğ±ÑƒÑ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ. Ğ¡ĞºĞ°Ğ¶Ñ–Ğ¼Ğ¾, ~15% Ñ„Ñ–Ğ³ÑƒÑ€.
                let bishopsCount = Math.max(2, Math.floor(width * 0.15));
                if (bishopsCount % 2 !== 0) bishopsCount++; // Ğ Ğ¾Ğ±Ğ¸Ğ¼Ğ¾ Ğ¿Ğ°Ñ€Ğ½Ğ¸Ğ¼

                // Ğ Ğ¾Ğ·Ğ´Ñ–Ğ»ÑÑ”Ğ¼Ğ¾ Ğ²Ñ–Ğ»ÑŒĞ½Ñ– ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸ Ğ½Ğ° Ğ±Ñ–Ğ»Ñ– Ñ‚Ğ° Ñ‡Ğ¾Ñ€Ğ½Ñ– (Ğ¿Ğ°Ñ€Ğ½Ñ–/Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ñ– Ñ–Ğ½Ğ´ĞµĞºÑĞ¸)
                // Ğ£Ğ²Ğ°Ğ³Ğ°: Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ñƒ Ğ·Ğ°Ğ»ĞµĞ¶Ğ¸Ñ‚ÑŒ Ğ²Ñ–Ğ´ (col + row), Ğ°Ğ»Ğµ Ğ¾ÑĞºÑ–Ğ»ÑŒĞºĞ¸ row Ğ¾Ğ´Ğ½Ğ°ĞºĞ¾Ğ²Ğ¸Ğ¹, 
                // Ñ‚Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½ÑŒĞ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ‚Ğ¸ Ğ¿Ğ°Ñ€Ğ½Ñ–ÑÑ‚ÑŒ Ñ–Ğ½Ğ´ĞµĞºÑÑƒ column.
                let evens = available.filter(i => i % 2 === 0);
                let odds = available.filter(i => i % 2 !== 0);

                for (let i = 0; i < bishopsCount / 2; i++) {
                    if (evens.length > 0 && odds.length > 0) {
                        // Ğ‘ĞµÑ€ĞµĞ¼Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ğ· Ğ¿Ğ°Ñ€Ğ½Ğ¾Ğ³Ğ¾
                        const eIdx = Math.floor(Math.random() * evens.length);
                        const ePos = evens[eIdx];
                        rank[ePos] = 'â™—';
                        evens.splice(eIdx, 1);

                        // Ğ‘ĞµÑ€ĞµĞ¼Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ğ· Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğ¾Ğ³Ğ¾
                        const oIdx = Math.floor(Math.random() * odds.length);
                        const oPos = odds[oIdx];
                        rank[oPos] = 'â™—';
                        odds.splice(oIdx, 1);
                    }
                }

                // Ğ—Ğ±Ğ¸Ñ€Ğ°Ñ”Ğ¼Ğ¾ Ğ·Ğ°Ğ»Ğ¸ÑˆĞ¾Ğº available Ğ· Ğ½ĞµĞ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ¸Ñ… Ğ¿Ğ°Ñ€Ğ½Ğ¸Ñ…/Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğ¸Ñ…
                available = [...evens, ...odds];

                // 4. Ğ—ĞĞŸĞĞ’ĞĞ•ĞĞĞ¯ (Ğ¤ĞµÑ€Ğ·Ñ–, ĞšĞ¾Ğ½Ñ– Ñ‚Ğ° Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ñ– Ğ¢ÑƒÑ€Ğ¸)
                // ĞĞ° Ğ²ĞµĞ»Ğ¸ĞºĞ¸Ñ… Ğ´Ğ¾ÑˆĞºĞ°Ñ… Ğ´Ğ¾Ğ´Ğ°Ğ¼Ğ¾ Ñ‚Ñ€Ğ¾Ñ…Ğ¸ Ñ€Ñ–Ğ·Ğ½Ğ¾Ğ¼Ğ°Ğ½Ñ–Ñ‚Ñ‚Ñ
                available.forEach(pos => {
                    const rand = Math.random();
                    if (rand < 0.45) rank[pos] = 'â™˜';       // 45% ĞšÑ–Ğ½ÑŒ
                    else if (rand < 0.80) rank[pos] = 'â™•';  // 35% Ğ¤ĞµÑ€Ğ·ÑŒ
                    else rank[pos] = 'â™–';                   // 20% Ğ”Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ğ° Ğ¢ÑƒÑ€Ğ°
                });

                // --- Ğ ĞĞ—ĞœĞ†Ğ©Ğ•ĞĞĞ¯ ĞĞ Ğ”ĞĞ¨Ğ¦Ğ† ---
                const blackMirror = { 'â™–':'â™œ', 'â™˜':'â™', 'â™—':'â™', 'â™•':'â™›', 'â™”':'â™š' };

                for (let c = 0; c < width; c++) {
                    const wSym = rank[c];
                    const bSym = blackMirror[wSym];

                    // Ğ‘Ñ–Ğ»Ñ–
                    this.setPiece(c, whiteRow, { s: wSym, c: 'w' });
                    this.setPiece(c, whitePawnRow, { s: 'â™™', c: 'w' });

                    // Ğ§Ğ¾Ñ€Ğ½Ñ– (Ğ´Ğ·ĞµÑ€ĞºĞ°Ğ»ÑŒĞ½Ğ¾)
                    this.setPiece(c, blackRow, { s: bSym, c: 'b' });
                    this.setPiece(c, blackPawnRow, { s: 'â™Ÿ', c: 'b' });
                }

                this.updateUI();
                console.log(`Mega 960 Generated: Size ${width}`);
            }

            fillFantasy() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                let mix = parseFloat(document.getElementById('fantasyMix').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'fantasy';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = mix;
                this.updateUI();
            }

            clear() {
                this.virtualGen = null;
                this.resetGame();
            }

            saveGame() {
                const pieces = [];
                for (const [key, val] of this.grid) {
                    const coord = key.split(',').map(Number);
                    if (val === GRID_VOID) {
                        pieces.push({ x: coord[0], y: coord[1], void: true });
                        continue;
                    }
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    pieces.push({
                        x: coord[0], y: coord[1], s: p.s, c: p.c, m: hasMoved ? 1 : 0
                    });
                }

                const saveData = {
                    format: "MegaChess_v4_History", // ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ° Ğ²ĞµÑ€ÑÑ–Ñ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñƒ
                    timestamp: Date.now(),
                    boardSize: this.boardSize,
                    turn: this.currentTurn,
                    virtualGen: this.virtualGen,
                    virtualProps: this.virtualProps,
                    generationSeed: this.generationSeed,
                    moveHistory: this.moveHistory, // <-- Ğ”ĞĞ”ĞĞĞ Ğ¦Ğ•
                    pieces: pieces
                };

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(saveData));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                const date = new Date().toISOString().slice(0,10);
                downloadAnchorNode.setAttribute("download", `megachess_${this.boardSize}x_${date}.json`);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            loadGame(inputElement) {
                const file = inputElement.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.applyLoadedData(data);
                    } catch (err) {
                        alert("ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ñ„Ğ°Ğ¹Ğ»Ñƒ! ĞŸĞµÑ€ĞµĞºĞ¾Ğ½Ğ°Ğ¹Ñ‚ĞµÑÑ, Ñ‰Ğ¾ Ñ†Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¸Ğ¹ JSON.");
                        console.error(err);
                    }
                    inputElement.value = '';
                };
                reader.readAsText(file);
            }

            applyLoadedData(data) {
                this.grid.clear();
                this.moveHistory = [];
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;

                if (data.boardSize) {
                    document.getElementById('boardSize').value = data.boardSize;
                    this.boardSize = data.boardSize;
                }

                this.virtualGen = data.virtualGen || null;
                if (data.virtualProps) this.virtualProps = data.virtualProps;
                if (data.generationSeed) this.generationSeed = data.generationSeed;

                this.currentTurn = data.turn || 'w';

                // 1. Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ„Ñ–Ğ³ÑƒÑ€
                if (Array.isArray(data.pieces)) {
                    data.pieces.forEach(p => {
                        if (p.x >= 0 && p.x < this.boardSize && p.y >= 0 && p.y < this.boardSize) {
                            if (p.void) {
                                this.grid.set(this.getKey(p.x, p.y), GRID_VOID);
                            } else {
                                this.setPiece(p.x, p.y, { s: p.s, c: p.c, hasMoved: !!p.m });
                            }
                        }
                    });
                }

                // 2. Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ñ‚Ğ° Ğ²Ñ–Ğ´Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ² Ğ»Ğ¾Ğ·Ñ–
                const logList = document.getElementById('logList');
                logList.innerHTML = ''; // ĞÑ‡Ğ¸Ñ‰ÑƒÑ”Ğ¼Ğ¾ Ğ»Ğ¾Ğ³ Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½ÑĞ¼

                if (data.moveHistory && Array.isArray(data.moveHistory)) {
                    this.moveHistory = data.moveHistory;

                    // ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¿Ğ¾ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ñ– Ğ´Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ² UI
                    // Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾: addLogToUI Ğ´Ğ¾Ğ´Ğ°Ñ” Ğ·Ğ²ĞµÑ€Ñ…Ñƒ (prepend), Ñ‚Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¼Ğ°ÑĞ¸Ğ² Ğ²Ñ–Ğ´ Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºÑƒ Ğ´Ğ¾ ĞºÑ–Ğ½Ñ†Ñ
                    this.moveHistory.forEach(step => {
                        if (step.notation) {
                            this.addLogToUI(
                                step.notation.icon,
                                step.notation.start,
                                step.notation.end,
                                step.notation.cap
                            );
                        }
                    });
                } else {
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ğ½ĞµĞ¼Ğ°Ñ” (ÑÑ‚Ğ°Ñ€Ğ¸Ğ¹ Ñ„Ğ°Ğ¹Ğ»), Ğ¿Ğ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºÑƒ
                    logList.innerHTML = '<div class="log-entry" style="color:#999; justify-content:center;">Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ” (ĞĞ±Ğ¾ Ñ„Ğ°Ğ¹Ğ» Ğ±ĞµĞ· Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ—)</div>';
                }

                this.updateTurnIndicator();
                this.centerBoard();
                this.updateUI();

                // Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ğµ Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ½Ñ Ğ² Ğ»Ğ¾Ğ³ Ğ¿Ñ€Ğ¾ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğµ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.style.color = 'green';
                div.style.background = '#e8f5e9';
                div.innerText = `ğŸ“‚ Ğ¤Ğ°Ğ¹Ğ» Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ¾ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾`;
                logList.prepend(div);
            }

            getFileLabel(index) { let label = ""; index++; while (index > 0) { let rem = (index - 1) % 26; label = String.fromCharCode(97 + rem) + label; index = Math.floor((index - 1) / 26); } return label; }
            isPathClear(c1, r1, c2, r2) { const dx = Math.sign(c2 - c1); const dy = Math.sign(r2 - r1); let x = c1 + dx; let y = r1 + dy; while (x !== c2 || y !== r2) { if (this.getPiece(x,y)) return false; x += dx; y += dy; } return true; }

            getCheckersMoves(piece, cx, cy, onlyCaptures = false) {
                const moves = [];
                const captures = [];
                const isWhite = piece.c === 'w';
                const isKing = ['â›', 'â›ƒ'].includes(piece.s);
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                for (const d of dirs) {
                    if (!isKing) {
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;
                        if (landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);
                            if (enemy && enemy.c !== piece.c && !landing) {
                                captures.push({ c: landX, r: landY, isCapture: true, captured: {x: enemyX, y: enemyY} });
                            }
                        }
                        if (!onlyCaptures) {
                            const forward = isWhite ? -1 : 1;
                            if (d[1] === forward) {
                                if (enemyX >= 0 && enemyX < this.boardSize && enemyY >= 0 && enemyY < this.boardSize) {
                                     if (!this.getPiece(enemyX, enemyY)) {
                                         moves.push({ c: enemyX, r: enemyY });
                                     }
                                }
                            }
                        }
                    } else {
                        let dist = 1;
                        let foundEnemy = null;
                        while (true) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;
                            const target = this.getPiece(tx, ty);
                            if (!foundEnemy) {
                                if (target) {
                                    if (target.c !== piece.c) foundEnemy = { x: tx, y: ty };
                                    else break;
                                } else {
                                    if (!onlyCaptures) moves.push({ c: tx, r: ty });
                                }
                            } else {
                                if (target) break;
                                captures.push({ c: tx, r: ty, isCapture: true, captured: foundEnemy });
                            }
                            dist++;
                        }
                    }
                }
                if (captures.length > 0) return captures;
                return moves;
            }

            validateMove(piece, c1, r1, c2, r2, checkingAttack = false) {
                if (!this.rulesEnabled) return true;
                if (this.checkersSymbols.has(piece.s) && !checkingAttack) {
                    const legalMoves = this.generatePotentialMoves(piece, c1, r1);
                    return legalMoves.some(m => m.c === c2 && m.r === r2);
                }
                const dx = c2 - c1; const dy = r2 - r1;
                if (dx === 0 && dy === 0) return false;
                const target = this.getPiece(c2, r2);
                if (!checkingAttack && target && target.c === piece.c) return false;
                const absDx = Math.abs(dx); const absDy = Math.abs(dy);
                const type = piece.s; const isWhite = piece.c === 'w';

                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const checkComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && (['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'].includes(type))) { dirY = -dirY; }
                            if (comp.t === 'slide' || def.t === 'slide') {
                                if (dirX === 0) { if (dx === 0 && Math.sign(dy) === Math.sign(dirY) && absDy <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else if (dirY === 0) { if (dy === 0 && Math.sign(dx) === Math.sign(dirX) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else { if (absDx === absDy && Math.sign(dx) === Math.sign(dirX) && Math.sign(dy) === Math.sign(dirY) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                            }
                            else if (comp.t === 'jump' || def.t === 'jump') { if (dx === dirX && dy === dirY) return true; }
                            else if (comp.t === 'step' || def.t === 'step') { let mul = comp.mul || 1; if (dx === dirX*mul && dy === dirY*mul) return true; }
                            else if (comp.t === 'slide_jump') { if (dx % dirX === 0 && dy % dirY === 0) { const steps = dx / dirX; if (steps === dy / dirY && steps > 0) { let cx = c1 + dirX, cy = r1 + dirY; while (cx !== c2 || cy !== r2) { if (this.getPiece(cx, cy)) return false; cx += dirX; cy += dirY; } return true; } } }
                        }
                        return false;
                    };
                    if (def.t === 'complex') { return def.comps.some(c => checkComp(c)); } else { return checkComp(def); }
                }

                const isRook = (dx === 0 || dy === 0) && this.isPathClear(c1, r1, c2, r2);
                const isBishop = (absDx === absDy) && this.isPathClear(c1, r1, c2, r2);
                const isKnight = (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                if (['â™–','â™œ','â™•','â™›','ğŸ¦…','ğŸ²','ğŸ¤´','ğŸ„'].includes(type)) { if (isRook) return true; }
                if (['â™—','â™','â™•','â™›','â›','â›ƒ','ğŸ¦„','ğŸ²','ğŸ‘¼','ğŸ†','ğŸ‘º'].includes(type)) { if (isBishop) return true; }
                if (['â™˜','â™','ğŸ¦„','ğŸ¦…','ğŸ²','ğŸ¿ï¸'].includes(type)) { if (isKnight) return true; }
                if (['â™”','â™š','ğŸ‘¨','ğŸ»','ğŸ¤´','ğŸ‘¼'].includes(type)) return absDx <= 1 && absDy <= 1;
                if (type === 'â™™' || type === 'â™Ÿ') { const dir = isWhite ? -1 : 1; if (dx === 0 && dy === dir) return !target && !checkingAttack; if (dx === 0 && dy === dir * 2) { return !piece.hasMoved && !target && !checkingAttack && !this.getPiece(c1, r1 + dir); } if (absDx === 1 && dy === dir) return checkingAttack || (target && target.c !== piece.c); return false; }
                if (['ğŸ¢','ğŸ•'].includes(type)) return (absDx + absDy === 1) || (absDx===0 && dy===(isWhite?-1:1));
                return false;
            }

            switchTurn() {
                if (!this.turnModeEnabled || this.gameOver) return;
                this.currentTurn = this.currentTurn === 'w' ? 'b' : 'w';
                this.updateTurnIndicator();

                if (this.rulesEnabled) {
                    this.updateKingCheckStatus('w');
                    this.updateKingCheckStatus('b');

                    if (this.kingsInCheck[this.currentTurn]) {
                        const kingPos = this.kingsInCheck[this.currentTurn];
                        const kingPiece = this.getPiece(kingPos.c, kingPos.r);

                        let canEscape = false;
                        if (kingPiece) {
                            const moves = this.generatePotentialMoves(kingPiece, kingPos.c, kingPos.r);
                            for (const m of moves) {
                                if (this.simulateMoveAndCheckSafety(kingPiece, kingPos.c, kingPos.r, m.c, m.r)) {
                                    canEscape = true;
                                    break;
                                }
                            }
                        }

                        if (!canEscape) {
                            this.endGame();
                        }
                    }
                }
            }

            endGame() {
                this.gameOver = true;
                const winner = this.currentTurn === 'w' ? "Ğ§Ğ¾Ñ€Ğ½Ñ–" : "Ğ‘Ñ–Ğ»Ñ–";
                const icon = this.currentTurn === 'w' ? "â™š" : "â™”";
                document.getElementById('winnerTxt').innerText = `ĞŸĞµÑ€ĞµĞ¼Ğ¾Ğ³Ğ°: ${winner}`;
                document.getElementById('winnerIcon').innerText = icon;
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }

            updateTurnIndicator() {
                const ind = document.getElementById('turnIndicator');
                const txt = document.getElementById('turnText');
                const icon = document.getElementById('turnIcon');
                if (!this.turnModeEnabled) { ind.style.display = 'none'; return; }
                ind.style.display = 'flex';
                if (this.currentTurn === 'w') {
                    ind.style.background = 'rgba(255, 255, 255, 0.9)'; ind.style.color = '#000';
                    ind.style.borderColor = (this.kingsInCheck.w) ? 'red' : '#000';
                    txt.innerText = (this.kingsInCheck.w) ? "Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ– (Ğ¨ĞĞ¥!)" : "Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ–";
                    icon.innerText = "â™”";
                } else {
                    ind.style.background = 'rgba(0, 0, 0, 0.9)'; ind.style.color = '#fff';
                    ind.style.borderColor = (this.kingsInCheck.b) ? 'red' : '#fff';
                    txt.innerText = (this.kingsInCheck.b) ? "Ğ¥Ñ–Ğ´: Ğ§Ğ¾Ñ€Ğ½Ñ– (Ğ¨ĞĞ¥!)" : "Ğ¥Ñ–Ğ´: Ğ§Ğ¾Ñ€Ğ½Ñ–";
                    icon.innerText = "â™š";
                }
            }

            toggleRules() { this.rulesEnabled = !this.rulesEnabled; if(!this.rulesEnabled) this.kingsInCheck = { w: null, b: null }; document.getElementById('rulesBtn').innerText = this.rulesEnabled ? "ğŸŸ¢ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°" : "ğŸ”´ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°"; }
            toggleTurnMode() { this.turnModeEnabled = !this.turnModeEnabled; this.updateTurnIndicator(); document.getElementById('turnBtn').innerText = this.turnModeEnabled ? "ğŸŸ¢ Ğ¥Ñ–Ğ´ (Ğ’ĞšĞ›)" : "ğŸ”´ Ğ¥Ñ–Ğ´ (Ğ’Ğ˜ĞšĞ›)"; }

            findKing(color) {
                if(color === 'w' && this.kingPos.w) return this.kingPos.w;
                if(color === 'b' && this.kingPos.b) return this.kingPos.b;

                if (this.virtualGen === 'classic' || this.virtualGen === 'fantasy') {
                     const kingCol = Math.floor(this.boardSize/2);
                     if (color === 'b') return {c: kingCol, r:0};
                     if (color === 'w') return {c: kingCol, r:this.boardSize-1};
                }

                const kingSymbol = color === 'w' ? 'â™”' : 'â™š';
                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    if(p.s === kingSymbol && p.c === color) {
                         const parts = key.split(',');
                         return {c: parseInt(parts[0]), r: parseInt(parts[1])};
                    }
                }
                return null;
            }

            isSquareAttacked(targetC, targetR, byOpponentOfColor) {
                const enemyQueen = byOpponentOfColor === 'w' ? 'â™•' : 'â™›';
                const enemyRook = byOpponentOfColor === 'w' ? 'â™–' : 'â™œ';
                const enemyBishop = byOpponentOfColor === 'w' ? 'â™—' : 'â™';
                const enemyKnight = byOpponentOfColor === 'w' ? 'â™˜' : 'â™';
                const enemyPawn = byOpponentOfColor === 'w' ? 'â™™' : 'â™Ÿ';

                // 1. Ğ¨Ğ²Ğ¸Ğ´ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞšĞ¾Ğ½Ñ–Ğ² (Ğ»Ğ¸ÑˆĞµ 8 Ñ‚Ğ¾Ñ‡Ğ¾Ğº)
                const knights = [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]];
                for (const [dx, dy] of knights) {
                    const p = this.getPiece(targetC + dx, targetR + dy);
                    if (p && p.c === byOpponentOfColor && (p.s === enemyKnight || p.s === 'ğŸ¦„')) return true;
                }

                // 2. Ğ¨Ğ²Ğ¸Ğ´ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞŸÑ–ÑˆĞ°ĞºÑ–Ğ²
                const pawnDy = byOpponentOfColor === 'w' ? 1 : -1;
                const checkPawn = (offset) => {
                     const p = this.getPiece(targetC + offset, targetR + pawnDy);
                     return p && p.c === byOpponentOfColor && p.s === enemyPawn;
                }
                if (checkPawn(1) || checkPawn(-1)) return true;

                // 3. ĞĞŸĞ¢Ğ˜ĞœĞ†Ğ—ĞĞ’ĞĞĞ ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ Ğ›Ğ†ĞĞ†Ğ™ (Raycast)
                // Ğ—Ğ°Ğ¼Ñ–ÑÑ‚ÑŒ Ñ†Ğ¸ĞºĞ»Ñƒ while(dist < 1000000000), Ğ¼Ğ¸ Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ½Ğ°Ğ¹Ğ±Ğ»Ğ¸Ğ¶Ñ‡Ñƒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ Ğ¼Ğ°Ñ‚ĞµĞ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾.
                
                const checkRayOptimized = (dx, dy, types) => {
                    let closestDist = Infinity;
                    let closestPiece = null;

                    // Ğ. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¸Ñ… Ñ„Ñ–Ğ³ÑƒÑ€ (Grid) - O(N), Ğ´Ğµ N - ĞºÑ–Ğ»ÑŒĞºÑ–ÑÑ‚ÑŒ Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ… Ñ„Ñ–Ğ³ÑƒÑ€ (Ğ·Ğ°Ğ·Ğ²Ğ¸Ñ‡Ğ°Ğ¹ Ğ¼Ğ°Ğ»Ğ¾)
                    for (const [key, val] of this.grid) {
                        if (val === GRID_VOID) continue; 
                        
                        // ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ ĞºĞ»ÑÑ‡Ğ° "c,r"
                        const comma = key.indexOf(',');
                        const pc = parseInt(key.substring(0, comma));
                        const pr = parseInt(key.substring(comma + 1));

                        const distC = pc - targetC;
                        const distR = pr - targetR;
                        
                        // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ğ»ĞµĞ¶Ğ¸Ñ‚ÑŒ Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ğ½Ğ° Ğ»Ñ–Ğ½Ñ–Ñ— Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ñ
                        let valid = false;
                        let d = Infinity;
                        
                        if (dx !== 0 && dy !== 0) { // Ğ”Ñ–Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ
                            if (Math.abs(distC) === Math.abs(distR) && Math.sign(distC) === dx && Math.sign(distR) === dy) {
                                valid = true;
                                d = Math.abs(distC);
                            }
                        } else if (dx !== 0) { // Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒ
                            if (distR === 0 && Math.sign(distC) === dx) {
                                valid = true;
                                d = Math.abs(distC);
                            }
                        } else { // Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒ
                            if (distC === 0 && Math.sign(distR) === dy) {
                                valid = true;
                                d = Math.abs(distR);
                            }
                        }

                        if (valid && d < closestDist) {
                            closestDist = d;
                            const id = val & 0xFFFF;
                            const p = this.palette[id-1];
                            closestPiece = p;
                        }
                    }

                    // Ğ‘. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ’Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ñ… ĞÑ€Ğ¼Ñ–Ğ¹ (Ğ¼Ğ°Ñ‚ĞµĞ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ ÑÑ‚Ñ€Ğ¸Ğ±Ğ¾Ğº Ñ‡ĞµÑ€ĞµĞ· Ğ¿Ğ¾Ñ€Ğ¾Ğ¶Ğ½ĞµÑ‡Ñƒ)
                    if (this.virtualGen) {
                         let armyH = 0;
                         if (this.virtualGen === 'chess960') armyH = 2;
                         else if (this.virtualGen !== 'checkers') {
                             armyH = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                             if (armyH < 2) armyH = 2;
                         } else {
                             armyH = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                         }

                         const topBoundary = armyH; 
                         const botBoundary = this.boardSize - armyH;

                         let vDist = Infinity;

                         // Ğ¯ĞºÑ‰Ğ¾ Ñ€ÑƒÑ… Ğ¼Ğ°Ñ” Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñƒ ÑĞºĞ»Ğ°Ğ´Ğ¾Ğ²Ñƒ
                         if (dy !== 0) {
                             if (dy < 0) { // Ğ’Ğ³Ğ¾Ñ€Ñƒ
                                 if (targetR >= topBoundary) vDist = targetR - (topBoundary - 1);
                             } else { // Ğ’Ğ½Ğ¸Ğ·
                                 if (targetR < botBoundary) vDist = botBoundary - targetR;
                             }
                         } else {
                             // Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾. Ğ¯ĞºÑ‰Ğ¾ Ğ¼Ğ¸ Ğ²ÑĞµÑ€ĞµĞ´Ğ¸Ğ½Ñ– Ğ°Ñ€Ğ¼Ñ–Ñ— - Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ ÑÑƒÑÑ–Ğ´Ñ–Ğ² (Ğ´Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ñ–Ñ 1).
                             // Ğ¯ĞºÑ‰Ğ¾ Ğ² Ğ¿Ğ¾Ñ€Ğ¾Ğ¶Ğ½ĞµÑ‡Ñ– - Ğ²Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ñ… Ñ„Ñ–Ğ³ÑƒÑ€ Ğ¿Ğ¾ Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»Ñ– Ğ½ĞµĞ¼Ğ°Ñ”.
                             if (targetR < topBoundary || targetR >= botBoundary) {
                                 vDist = 1;
                             }
                         }

                         if (vDist < closestDist) {
                             // ĞœĞ¸ Ğ²Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ Ñƒ Ğ²Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ğ¹ ÑˆĞ°Ñ€ Ñ€Ğ°Ğ½Ñ–ÑˆĞµ, Ğ½Ñ–Ğ¶ Ñƒ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñƒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ
                             const vx = targetC + dx * vDist;
                             const vy = targetR + dy * vDist;
                             
                             if (vx >= 0 && vx < this.boardSize && vy >= 0 && vy < this.boardSize) {
                                 const vp = this.getPiece(vx, vy);
                                 if (vp) {
                                     closestDist = vDist;
                                     closestPiece = vp;
                                 }
                             }
                         }
                    }

                    // Ğ’. Ğ¤Ñ–Ğ½Ğ°Ğ»ÑŒĞ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾Ñ— Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸
                    if (closestPiece) {
                        if (closestPiece.c === byOpponentOfColor) {
                            if (types.includes(closestPiece.s)) return true;
                            // ĞŸÑ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ĞºĞ° ĞœĞµĞ³Ğ°-Ñ„Ñ–Ğ³ÑƒÑ€, Ñ‰Ğ¾ Ğ±'ÑÑ‚ÑŒ ÑĞº Ğ¤ĞµÑ€Ğ·ÑŒ
                            if (types.includes(enemyQueen) && ['ğŸ§œ','ğŸ”±','ğŸ¦…'].includes(closestPiece.s)) return true;
                        }
                    }
                    return false;
                };

                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° 8 Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ĞºÑ–Ğ² (Ñ‚ĞµĞ¿ĞµÑ€ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ° Ğ½Ğ°Ğ²Ñ–Ñ‚ÑŒ Ğ½Ğ° 1M ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ğ¾Ğº)
                if (checkRayOptimized(0, 1, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(0, -1, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(1, 0, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(-1, 0, [enemyRook, enemyQueen])) return true;

                if (checkRayOptimized(1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(1, -1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(-1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(-1, -1, [enemyBishop, enemyQueen])) return true;

                return false;
            }

            isInCheck(kingColor) { const kingPos = this.findKing(kingColor); if (!kingPos) return false; return this.isSquareAttacked(kingPos.c, kingPos.r, kingColor === 'w' ? 'b' : 'w'); }
            updateKingCheckStatus(color) { this.kingsInCheck[color] = this.isInCheck(color) ? this.findKing(color) : null; }

            hasAnyLegalMoves(color) { return true; }
            _resolveDirs(d) { return typeof d === 'string' ? DIRS[d] : d; }

            generatePotentialMoves(piece, cx, cy, bounds = null) {
                // Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ ÑˆĞ°ÑˆĞºĞ¸, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑÑ‚Ğ°Ñ€ÑƒÑ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ (Ğ¾Ğ½Ğ° Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ°Ñ, Ğ½Ğµ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ°Ñ)
                if (this.checkersSymbols.has(piece.s)) {
                    if (!this.multiJumpSource && this.rulesEnabled) return this.getCheckersMoves(piece, cx, cy);
                    else if (this.multiJumpSource) {
                        if (cx !== this.multiJumpSource.c || cy !== this.multiJumpSource.r) return [];
                        return this.getCheckersMoves(piece, cx, cy, true);
                    }
                    return this.getCheckersMoves(piece, cx, cy);
                }

                let moves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ‚Ğ¾Ñ‡ĞºĞ¸ (Ğ¿Ñ€Ñ‹Ğ¶Ğ¾Ğº ĞºĞ¾Ğ½Ñ, ĞºĞ¾Ñ€Ğ¾Ğ»Ñ)
                const addStep = (dx, dy) => {
                    let x = cx + dx; let y = cy + dy;
                    if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {
                        moves.push({c: x, r: y});
                    }
                };

                // Ğ’ĞĞ–ĞĞ: ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ‚Ñ€Ğ°ÑÑĞ¸Ñ€Ğ¾Ğ²ĞºĞ° (Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ñ‹: Ğ›Ğ°Ğ´ÑŒÑ, Ğ¡Ğ»Ğ¾Ğ½, Ğ¤ĞµÑ€Ğ·ÑŒ)
                const addTrace = (dx, dy) => {
                    let x = cx + dx; 
                    let y = cy + dy;
                    
                    // Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ Ğ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ğ¾Ğ³Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°, Ğ½Ğ¾ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ° ÑĞºÑ€Ğ°Ğ½Ğ¾Ğ¼ Ğ¸Ğ»Ğ¸ Ğ´Ğ¾ÑĞºĞ¾Ğ¹
                    let steps = 0;
                    // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ ÑˆĞ°Ğ³Ğ¾Ğ² Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ¾Ğ¼ Ğ´Ğ¾ÑĞºĞ¸, Ğ½Ğ¾ Ğ¿Ñ€ĞµÑ€Ğ²ĞµĞ¼ Ñ€Ğ°Ğ½ÑŒÑˆĞµ
                    const maxSteps = this.boardSize; 

                    while (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize && steps < maxSteps) {
                        // 1. Ğ’Ğ˜Ğ Ğ¢Ğ£ĞĞ›Ğ¬ĞĞĞ¯ ĞĞŸĞ¢Ğ˜ĞœĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯:
                        // Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ ÑĞºÑ€Ğ°Ğ½Ğ° (bounds) Ğ¸ Ğ¼Ñ‹ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ·Ğ° Ğ½Ğ¸Ñ… â€” ĞŸĞ Ğ•Ğ Ğ«Ğ’ĞĞ•ĞœĞ¡Ğ¯.
                        // ĞĞµÑ‚ ÑĞ¼Ñ‹ÑĞ»Ğ° Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ñ‚Ğ°Ğ¼, Ğ³Ğ´Ğµ Ğ¸Ğ³Ñ€Ğ¾Ğº Ğ½Ğµ Ğ²Ğ¸Ğ´Ğ¸Ñ‚.
                        if (bounds) {
                            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ´Ğ²Ğ¸Ğ¶ĞµĞ¼ÑÑ Ğ»Ğ¸ Ğ¼Ñ‹ ĞĞ¢ Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹ Ğ—Ğ Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‹ ÑĞºÑ€Ğ°Ğ½Ğ°
                            // (Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ¾: ĞµÑĞ»Ğ¸ Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ²Ğ½Ğµ ÑĞºÑ€Ğ°Ğ½Ğ°, Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°ĞµĞ¼ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ)
                            if (x < bounds.minC || x > bounds.maxC || y < bounds.minR || y > bounds.maxR) {
                                // ĞĞ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ¾ÑÑ‚Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ñ‹Ğ¼: ĞµÑĞ»Ğ¸ Ñ„Ğ¸Ğ³ÑƒÑ€Ğ° ÑĞ°Ğ¼Ğ° Ğ·Ğ° ÑĞºÑ€Ğ°Ğ½Ğ¾Ğ¼, Ğ° Ğ±ÑŒĞµÑ‚ Ğ’ ÑĞºÑ€Ğ°Ğ½.
                                // ĞŸĞ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼: ĞµÑĞ»Ğ¸ Ğ¼Ñ‹ Ğ£Ğ–Ğ• Ğ´Ğ°Ğ»ĞµĞºĞ¾ Ğ¾Ñ‚ Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹ Ğ¸ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ·Ğ° ÑĞºÑ€Ğ°Ğ½.
                                if (Math.abs(x - cx) > 50 || Math.abs(y - cy) > 50) break;
                                
                                // Ğ˜Ğ»Ğ¸ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾: ĞµÑĞ»Ğ¸ Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ´Ğ°Ğ»ĞµĞºĞ¾ Ğ·Ğ° Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ğ¼Ğ¸ Ğ²ÑŒÑĞ¿Ğ¾Ñ€Ñ‚Ğ°, break.
                                // Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµĞ¼ Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ "Ğ¾Ğ²ĞµÑ€Ğ´Ñ€Ğ°Ñ„Ñ‚", Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ Ğ½Ğµ Ğ¾Ğ±Ñ€Ñ‹Ğ²Ğ°Ğ»Ğ¸ÑÑŒ Ñ€ĞµĞ·ĞºĞ¾ Ğ¿Ñ€Ğ¸ ÑĞºÑ€Ğ¾Ğ»Ğ»Ğµ
                            }
                        }

                        const target = this.getPiece(x, y);
                        if (target) {
                            // Ğ•ÑĞ»Ğ¸ Ğ²ÑÑ‚Ñ€ĞµÑ‚Ğ¸Ğ»Ğ¸ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ
                            if (target.c !== piece.c) moves.push({c: x, r: y}); // Ğ‘ÑŒĞµĞ¼ Ğ²Ñ€Ğ°Ğ³Ğ°
                            break; // Ğ˜ Ğ¾ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ÑÑ
                        }
                        
                        // Ğ•ÑĞ»Ğ¸ Ğ¿ÑƒÑÑ‚Ğ¾ - Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ…Ğ¾Ğ´
                        moves.push({c: x, r: y});
                        
                        x += dx; y += dy;
                        steps++;
                    }
                };

                // Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ
                if (['â™–','â™œ','â™•','â™›'].includes(type)) { addTrace(1,0); addTrace(-1,0); addTrace(0,1); addTrace(0,-1); }
                if (['â™—','â™','â™•','â™›'].includes(type)) { addTrace(1,1); addTrace(-1,1); addTrace(1,-1); addTrace(-1,-1); }
                if (['â™˜','â™'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => addStep(d[0], d[1])); }
                if (['â™”','â™š'].includes(type)) { for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i||j) addStep(i,j); }
                
                // ĞŸĞµÑˆĞºĞ¸
                if (['â™™','â™Ÿ'].includes(type)) {
                    const d = isWhite ? -1 : 1;
                    if (!this.getPiece(cx, cy + d)) addStep(0, d);
                    if (!this.getPiece(cx, cy + d*2) && !this.getPiece(cx, cy + d) && !piece.hasMoved) addStep(0, d*2);
                    const t1 = this.getPiece(cx + 1, cy + d); if (t1 && t1.c !== piece.c) addStep(1, d);
                    const t2 = this.getPiece(cx - 1, cy + d); if (t2 && t2.c !== piece.c) addStep(-1, d);
                }
                
                // ĞœĞµĞ³Ğ°-Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹
                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const FLIP_Y_LIST = ['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'];
                    const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            
                            if (moveType === 'slide' || moveType === 'slide_jump') {
                                // Ğ—Ğ´ĞµÑÑŒ Ğ¼Ñ‹ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ limit, Ñ‚Ğ°Ğº ĞºĞ°Ğº addTrace Ñ‚ĞµĞ¿ĞµÑ€ÑŒ ÑĞ°Ğ¼ Ñ€ĞµÑˆĞ°ĞµÑ‚ ĞºĞ¾Ğ³Ğ´Ğ° Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ
                                // ĞĞ¾ Ğ´Ğ»Ñ "ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ñ…" ÑĞ»Ğ°Ğ¹Ğ´ĞµÑ€Ğ¾Ğ² (Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ½Ñ‹Ñ… max), Ğ¼Ñ‹ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ‚ÑŒ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸
                                // Ğ”Ğ»Ñ ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ¸Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ¾Ñ‚ Ğ¶Ğµ addTrace, Ğ¾Ğ½ ÑĞ°Ğ¼ Ğ¾Ğ±Ñ€ĞµĞ¶ĞµÑ‚ÑÑ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°Ğ¼Ğ¸ ÑĞºÑ€Ğ°Ğ½Ğ°
                                addTrace(dirX, dirY); 
                            } else { 
                                let mul = comp.mul || 1; 
                                addStep(dirX * mul, dirY * mul); 
                            }
                        }
                    };
                    if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }
                return moves;
            }

            simulateMoveAndCheckSafety(piece, startC, startR, targetC, targetR) {
                if (!this.validateMove(piece, startC, startR, targetC, targetR)) return false;

                const keyStart = this.getKey(startC, startR);
                const keyTarget = this.getKey(targetC, targetR);

                const valStart = this.grid.get(keyStart);
                const valTarget = this.grid.get(keyTarget);

                const wasKingW = this.kingPos.w;
                const wasKingB = this.kingPos.b;

                if (valStart === undefined && this.virtualGen) {
                    const p = this.getVirtualPiece(startC, startR);
                    const pid = this.getPaletteId(p.s, p.c);
                    this.grid.set(keyTarget, pid);
                    this.grid.set(keyStart, GRID_VOID);
                } else {
                    this.grid.set(keyTarget, valStart);
                    this.grid.delete(keyStart);
                }

                if(piece.s === 'â™”') this.kingPos.w = {c: targetC, r: targetR};
                if(piece.s === 'â™š') this.kingPos.b = {c: targetC, r: targetR};

                const isSafe = !this.isInCheck(piece.c);

                if (valTarget === undefined) this.grid.delete(keyTarget); else this.grid.set(keyTarget, valTarget);
                if (valStart === undefined) this.grid.delete(keyStart); else this.grid.set(keyStart, valStart);

                this.kingPos.w = wasKingW;
                this.kingPos.b = wasKingB;

                return isSafe;
            }

              calculateHighlights(piece, cx, cy) {
                if (!this.rulesEnabled) return;
                
                this.highlightedMoves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // --- 1. Ğ¤Ğ£ĞĞšĞ¦Ğ†Ğ‡ (ĞĞŸĞ¢Ğ˜ĞœĞ†Ğ—ĞĞ’ĞĞĞ†) ---
                
                // Ğ”Ğ»Ñ Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ñ–Ğ² (Ğ¢ÑƒÑ€Ğ°, Ğ¡Ğ»Ğ¾Ğ½, Ğ¤ĞµÑ€Ğ·ÑŒ) - Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ "ĞŸÑ€Ğ¾Ğ¼ĞµĞ½Ñ–"
                const castRay = (dx, dy, maxLimit = this.boardSize) => {
                    const end = this.findRayEnd(cx, cy, dx, dy, maxLimit);
                    
                    // ĞĞ±Ñ‡Ğ¸ÑĞ»ÑÑ”Ğ¼Ğ¾ Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ñƒ Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ñ Ğ´Ğ¾ Ğ¿ĞµÑ€ĞµÑˆĞºĞ¾Ğ´Ğ¸
                    let dist = Math.max(0, Math.abs(end.x - cx + end.y - cy));

                    // Ğ¯ĞºÑ‰Ğ¾ Ğ²Ğ¿ĞµÑ€Ğ»Ğ¸ÑÑ Ğ² Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ (ÑĞ²Ğ¾Ñ Ñ‡Ğ¸ Ñ‡ÑƒĞ¶Ñƒ) - Ğ·Ğ¼ĞµĞ½ÑˆÑƒÑ”Ğ¼Ğ¾ Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ñƒ Ğ½Ğ° 1,
                    // Ñ‰Ğ¾Ğ± Ğ·ĞµĞ»ĞµĞ½Ğ° Ğ»Ñ–Ğ½Ñ–Ñ Ğ½Ğµ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ»Ğ°ÑÑ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸.
                    if (end.hit || end.ally) dist--;

                    if (dist > 0) {
                        this.highlightedMoves.push({
                            type: 'ray', cx: cx, cy: cy, dx: dx, dy: dy, len: dist
                        });
                    }

                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ²Ğ¾Ñ€Ğ¾Ğ³ - Ğ´Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ¾ĞºÑ€ĞµĞ¼Ñƒ Ñ‡ĞµÑ€Ğ²Ğ¾Ğ½Ñƒ Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ°Ñ‚Ğ°ĞºĞ¸
                    if (end.hit && !end.ally) {
                        this.highlightedMoves.push({ type: 'point', c: end.x, r: end.y, capture: true });
                    }
                };

                // Ğ”Ğ»Ñ Ğ¡Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ñ–Ğ² (ĞšÑ–Ğ½ÑŒ, ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ)
                const checkJump = (dx, dy) => {
                    const tx = cx + dx; const ty = cy + dy;
                    if (tx >= 0 && tx < this.boardSize && ty >= 0 && ty < this.boardSize) {
                        const target = this.getPiece(tx, ty);
                        if (!target) {
                             this.highlightedMoves.push({ type: 'point', c: tx, r: ty });
                        } else if (target.c !== piece.c) {
                             this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: true });
                        }
                    }
                };

                // --- 2. Ğ›ĞĞ“Ğ†ĞšĞ Ğ¤Ğ†Ğ“Ğ£Ğ  ---

                // Ğ. Ğ¨Ğ°ÑˆĞºĞ¸ (Ğ¼Ğ°ÑÑ‚ÑŒ Ğ¿Ñ€Ñ–Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚ Ñ– Ğ²Ğ¸Ñ…Ğ¾Ğ´ÑÑ‚ÑŒ Ğ· Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—)
                if (this.checkersSymbols.has(type)) {
                    const moves = this.generatePotentialMoves(piece, cx, cy);
                    moves.forEach(m => this.highlightedMoves.push({ type: 'point', c: m.c, r: m.r, capture: !!m.isCapture }));
                    return;
                }

                // Ğ‘. ĞšĞ»Ğ°ÑĞ¸Ñ‡Ğ½Ñ– Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸
                if (['â™–','â™œ','â™•','â™›'].includes(type)) { castRay(1,0); castRay(-1,0); castRay(0,1); castRay(0,-1); }
                if (['â™—','â™','â™•','â™›'].includes(type)) { castRay(1,1); castRay(-1,1); castRay(1,-1); castRay(-1,-1); }
                if (['â™˜','â™'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => checkJump(d[0], d[1])); }
                if (['â™”','â™š'].includes(type)) { for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i||j) checkJump(i,j); }

                // Ğ’. Mega / Fantasy Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸
                if (megaDefs[type]) {
                     const def = megaDefs[type];
                     const FLIP_Y_LIST = ['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'];
                     const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0], dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            
                            if (moveType === 'slide' || moveType === 'slide_jump') castRay(dirX, dirY, limit);
                            else { let mul = comp.mul || 1; checkJump(dirX * mul, dirY * mul); }
                        }
                     };
                     if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }

                // Ğ“. ĞŸĞ†Ğ¨ĞĞšĞ˜ (Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ)
                if (['â™™','â™Ÿ'].includes(type)) {
                    const dir = isWhite ? -1 : 1;
                    
                    // 1. Ğ ÑƒÑ… Ğ²Ğ¿ĞµÑ€ĞµĞ´ Ğ½Ğ° 1 ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºÑƒ (Ğ¢Ñ–Ğ»ÑŒĞºĞ¸ ÑĞºÑ‰Ğ¾ ĞŸĞ£Ğ¡Ğ¢Ğ)
                    const fwd1 = this.getPiece(cx, cy + dir);
                    if (!fwd1) {
                        this.highlightedMoves.push({ type: 'point', c: cx, r: cy + dir });
                        
                        // 2. Ğ ÑƒÑ… Ğ²Ğ¿ĞµÑ€ĞµĞ´ Ğ½Ğ° 2 ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸ (Ğ¢Ñ–Ğ»ÑŒĞºĞ¸ ÑĞºÑ‰Ğ¾ Ğ½Ğµ Ñ…Ğ¾Ğ´Ğ¸Ğ² Ğ† Ğ¾Ğ±Ğ¸Ğ´Ğ²Ñ– ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸ Ğ¿ÑƒÑÑ‚Ñ–)
                        if (!piece.hasMoved) {
                            const fwd2 = this.getPiece(cx, cy + dir * 2);
                            if (!fwd2) {
                                this.highlightedMoves.push({ type: 'point', c: cx, r: cy + dir * 2 });
                            }
                        }
                    }

                    // 3. ĞÑ‚Ğ°ĞºĞ¸ Ğ¿Ğ¾ Ğ´Ñ–Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ñ– (Ğ¢Ñ–Ğ»ÑŒĞºĞ¸ ÑĞºÑ‰Ğ¾ Ğ’ĞĞ ĞĞ“)
                    [1, -1].forEach(dx => {
                        const tx = cx + dx; const ty = cy + dir;
                        const t = this.getPiece(tx, ty);
                        if (t && t.c !== piece.c) {
                            this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: true });
                        }
                    });
                }
            }
            onMouseDown(e) {
                if (this.gameOver || this.isGenerating || this.promotionPending) return;
                
                this.clickStart = { x: e.clientX, y: e.clientY };
                const w = this.screenToWorld(e.clientX, e.clientY);
                const c = Math.floor(w.x / this.cellSize); 
                const r = Math.floor(w.y / this.cellSize);

                // --- Ğ›Ğ†Ğ’Ğ ĞšĞĞĞŸĞšĞ (Ğ“Ñ€Ğ° Ñ‚Ğ° Ğ†Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¸) ---
                if (e.button === 0) {
                    this.customArrows = []; 

                    // === Ğ¤Ğ†ĞĞĞ›Ğ¬ĞĞ• Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯ Ğ”Ğ›Ğ¯ Ğ“Ğ£ĞœĞšĞ˜ ===
                    // 1. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾: Ğ ĞµĞ¶Ğ¸Ğ¼ Ñ…Ğ¾Ğ´Ñƒ Ğ’Ğ˜ĞœĞšĞĞ•ĞĞ + ĞĞ±Ñ€Ğ°Ğ½Ğ° Ğ“Ğ£ĞœĞšĞ (âŒ)
                    if (!this.turnModeEnabled && (this.curSymbol === 'âŒ' || this.curSymbol === 'delete')) {
                        
                        // Ğ’Ğ¸ĞºĞ¾Ğ½ÑƒÑ”Ğ¼Ğ¾ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ¾ (Ğ¿Ñ€Ğ¸ Ğ½Ğ°Ñ‚Ğ¸ÑĞºĞ°Ğ½Ğ½Ñ–)
                        this.tryPlacePiece(c, r); 
                        
                        // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ:
                        // 1. ĞœĞ¸ ĞĞ• ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ this.isPainting = true. Ğ¦Ğµ Ğ¿Ñ€Ğ¸Ğ±Ğ¸Ñ€Ğ°Ñ” "Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğµ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ" Ğ¿Ñ€Ğ¸ Ñ€ÑƒÑÑ– Ğ¼Ğ¸ÑˆĞºĞ¾Ñ.
                        // 2. ĞœĞ¸ Ñ€Ğ¾Ğ±Ğ¸Ğ¼Ğ¾ return. Ğ¦Ğµ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚ÑƒÑ”, Ñ‰Ğ¾ ĞºĞ¾Ğ´ ĞĞ• Ğ¿Ñ–Ğ´Ğµ Ğ´Ğ°Ğ»Ñ–, Ñ‚Ğ¾Ğ¼Ñƒ:
                        //    - Ğ½Ğµ Ğ·'ÑĞ²Ğ¸Ñ‚ÑŒÑÑ Ğ¿Ñ–Ğ´ÑĞ²Ñ–Ñ‚ĞºĞ° Ñ…Ğ¾Ğ´Ñ–Ğ² (calculateHighlights Ğ½Ğµ Ğ²Ğ¸ĞºĞ»Ğ¸Ñ‡ĞµÑ‚ÑŒÑÑ)
                        //    - Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ğ½Ğµ "Ğ¿Ñ€Ğ¸Ğ»Ğ¸Ğ¿Ğ½Ğµ" Ğ´Ğ¾ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ° (isDraggingPiece Ğ½Ğµ ÑÑ‚Ğ°Ğ½Ğµ true)
                        return; 
                    }
                    // ======================================
                    
                    const piece = this.getPiece(c, r);
                    
                    let canGrabPiece = false;
                    if (piece) {
                        if (!this.turnModeEnabled || piece.c === this.currentTurn) {
                            canGrabPiece = true;
                        }
                    }

                    if (canGrabPiece) {
                        this.isDraggingPiece = true;
                        this.draggedPiece = { data: piece, startC: c, startR: r };
                        this.calculateHighlights(piece, c, r);
                    } 
                } 
                
                // --- ĞŸĞ ĞĞ’Ğ ĞšĞĞĞŸĞšĞ (ĞšĞ°Ğ¼ĞµÑ€Ğ° Ñ‚Ğ° Ğ¡Ñ‚Ñ€Ñ–Ğ»ĞºĞ¸) ---
                else if (e.button === 2) {
                    if (e.shiftKey) {
                        if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) {
                            this.rmbStart = { c, r };
                        } else {
                            this.rmbStart = null;
                        }
                    } else {
                        this.isDragging = true; 
                        this.lastMouse = { x: e.clientX, y: e.clientY }; 
                        this.canvas.style.cursor = "grabbing";
                    }
                }
            }
            onMouseMove(e) {
                this.mouse.x = e.clientX; this.mouse.y = e.clientY;
                if (this.promotionPending) return;

                if (this.isDragging) { 
                    // Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ Ñ€Ñ–Ğ·Ğ½Ğ¸Ñ†Ñ Ñ€ÑƒÑ…Ñƒ Ğ¼Ğ¸ÑˆĞºĞ¸
                    const dx = e.clientX - this.lastMouse.x;
                    const dy = e.clientY - this.lastMouse.y;

                    // 1. Ğ ÑƒÑ…Ğ°Ñ”Ğ¼Ğ¾ ĞºĞ°Ğ¼ĞµÑ€Ñƒ (Ñ‰Ğ¾Ğ± Ğ±ÑƒĞ»Ğ¾ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ¾)
                    this.camera.x += dx; 
                    this.camera.y += dy; 
                    
                    // 2. Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: Ğ ÑƒÑ…Ğ°Ñ”Ğ¼Ğ¾ Ğ¦Ğ†Ğ›Ğ¬ ĞºĞ°Ğ¼ĞµÑ€Ğ¸ (Ñ‰Ğ¾Ğ± Ğ°Ğ½Ñ–Ğ¼Ğ°Ñ†Ñ–Ñ Ğ½Ğµ Ñ‚ÑĞ³Ğ½ÑƒĞ»Ğ° Ğ½Ğ°Ğ·Ğ°Ğ´)
                    this.targetCamera.x += dx;
                    this.targetCamera.y += dy;

                    this.lastMouse = { x: e.clientX, y: e.clientY }; 
                    this.clampCamera(); 
                }
                
                const w = this.screenToWorld(e.clientX, e.clientY); const c = Math.floor(w.x / this.cellSize); const r = Math.floor(w.y / this.cellSize);
                if (this.isPainting) this.tryPlacePiece(c, r);
                if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) { const file = this.getFileLabel(c); const rank = this.boardSize - r; document.getElementById('coord').innerText = `${file}${rank}`; }
            }

            tryPlacePiece(c, r) { 
                // Ğ¯ĞºÑ‰Ğ¾ ÑƒĞ²Ñ–Ğ¼ĞºĞ½ĞµĞ½Ğ¾ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ñ…Ğ¾Ğ´Ñƒ, Ğ½Ñ–Ñ‡Ğ¾Ğ³Ğ¾ Ğ½Ğµ Ñ€Ğ¾Ğ±Ğ¸Ğ¼Ğ¾
                if (this.turnModeEnabled) return;

                if(c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) { 
                    // --- Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯ Ğ¢Ğ£Ğ¢ ---
                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ ÑĞ°Ğ¼Ğµ Ğ½Ğ° Ñ‡ĞµÑ€Ğ²Ğ¾Ğ½Ğ¸Ğ¹ Ñ…Ñ€ĞµÑÑ‚Ğ¸Ğº (âŒ), ÑĞºĞ¸Ğ¹ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ” Ğ²Ğ°ÑˆĞ° ĞºĞ½Ğ¾Ğ¿ĞºĞ°
                    if (this.curSymbol === 'âŒ' || this.curSymbol === 'delete') { 
                        this.removePiece(c, r); // Ğ’Ğ¸Ğ´Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ
                        this.updateUI(); 
                        return; 
                    } 
                    
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ½Ğµ Ğ³ÑƒĞ¼ĞºĞ°, ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ
                    this.setPiece(c, r, { s: this.curSymbol, c: this.curColor }); 
                    this.updateUI(); 
                } 
            }

            onMouseUp(e) {
                // 1. Ğ›ĞĞ“Ğ†ĞšĞ Ğ¡Ğ¢Ğ Ğ†Ğ›ĞĞš (ĞŸĞšĞœ) Ğ·Ğ°Ğ»Ğ¸ÑˆĞ°Ñ”Ñ‚ÑŒÑÑ Ğ±ĞµĞ· Ğ·Ğ¼Ñ–Ğ½
                if (e.button === 2 && this.rmbStart) {
                    const w = this.screenToWorld(e.clientX, e.clientY);
                    let rawC = Math.floor(w.x / this.cellSize); let rawR = Math.floor(w.y / this.cellSize);
                    const endC = Math.max(0, Math.min(this.boardSize - 1, rawC));
                    const endR = Math.max(0, Math.min(this.boardSize - 1, rawR));

                    if (this.rmbStart.c !== endC || this.rmbStart.r !== endR) {
                        const newArrow = { sx: this.rmbStart.c, sy: this.rmbStart.r, ex: endC, ey: endR };
                        const idx = this.customArrows.findIndex(a => a.sx === newArrow.sx && a.sy === newArrow.sy && a.ex === newArrow.ex && a.ey === newArrow.ey);
                        if (idx >= 0) this.customArrows.splice(idx, 1); else this.customArrows.push(newArrow);
                    } 
                    this.rmbStart = null; this.updateUI(); return;
                }
                if (e.button === 2) this.isPainting = false;
                if (this.promotionPending) return;

                const w = this.screenToWorld(e.clientX, e.clientY);
                const c = Math.floor(w.x / this.cellSize); 
                const r = Math.floor(w.y / this.cellSize);

                let isClick = false;
                if (this.clickStart) {
                    const dist = Math.hypot(e.clientX - this.clickStart.x, e.clientY - this.clickStart.y);
                    if (dist < 5) isClick = true;
                }

                if (e.button === 0) {
                    // Ğ¡Ğ¦Ğ•ĞĞĞ Ğ†Ğ™ Ğ: ĞœĞ˜ ĞŸĞ ĞĞ¡Ğ¢Ğ ĞšĞ›Ğ†ĞšĞĞ£Ğ›Ğ˜
                    if (isClick) {
                        // --- Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯ Ğ¢Ğ£Ğ¢ ---
                        // Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ, Ğ¢Ğ†Ğ›Ğ¬ĞšĞ˜ ÑĞºÑ‰Ğ¾ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ñ…Ğ¾Ğ´Ñƒ Ğ’Ğ˜ĞœĞšĞĞ•ĞĞ
                        if (!this.turnModeEnabled) {
                            this.tryPlacePiece(c, r);
                        } else {
                            // Ğ¯ĞºÑ‰Ğ¾ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ñ…Ğ¾Ğ´Ñƒ ÑƒĞ²Ñ–Ğ¼ĞºĞ½ĞµĞ½Ğ¾, ĞºĞ»Ñ–Ğº Ğ¿Ğ¾ Ğ¿Ğ¾Ñ€Ğ¾Ğ¶Ğ½ÑŒĞ¾Ğ¼Ñƒ Ğ¼Ñ–ÑÑ†Ñ 
                            // Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ·Ğ½Ñ–Ğ¼Ğ°Ñ” Ğ²Ğ¸Ğ´Ñ–Ğ»ĞµĞ½Ğ½Ñ (updateUI Ñ†Ğµ Ğ·Ñ€Ğ¾Ğ±Ğ¸Ñ‚ÑŒ)
                        }
                        
                        this.isDragging = false;
                        this.isDraggingPiece = false;
                        this.draggedPiece = null;
                        this.highlightedMoves = [];
                        this.updateUI();
                        return; 
                    }

                    // Ğ¡Ğ¦Ğ•ĞĞĞ Ğ†Ğ™ Ğ‘: ĞœĞ˜ ĞŸĞ•Ğ Ğ•Ğ¢Ğ¯Ğ“ĞĞ£Ğ›Ğ˜ Ğ¤Ğ†Ğ“Ğ£Ğ Ğ£ (Ğ¡Ğ¿Ñ€Ğ¾Ğ±Ğ° Ñ…Ğ¾Ğ´Ñƒ)
                    if (this.isDraggingPiece && this.draggedPiece) {
                        if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) {
                            if (c !== this.draggedPiece.startC || r !== this.draggedPiece.startR) {
                                let isValid = this.validateMove(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR, c, r);
                                if (isValid) {
                                    let isMoveSafe = true;
                                    if (this.rulesEnabled) isMoveSafe = this.simulateMoveAndCheckSafety(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR, c, r);
                                    
                                    if (isMoveSafe) {
                                        const isWhite = this.draggedPiece.data.c === 'w';
                                        const isPawn = this.draggedPiece.data.s === 'â™™' || this.draggedPiece.data.s === 'â™Ÿ';
                                        const promotionRow = isWhite ? 0 : this.boardSize - 1;
                                        
                                        if (isPawn && r === promotionRow) {
                                            this.promotionPending = { piece: this.draggedPiece.data, startC: this.draggedPiece.startC, startR: this.draggedPiece.startR, endC: c, endR: r };
                                            this.showPromotionDialog(this.draggedPiece.data.c);
                                            this.draggedPiece = null; this.isDraggingPiece = false; this.highlightedMoves = []; return;
                                        }

                                        const startCoord = this.getCoordString(this.draggedPiece.startC, this.draggedPiece.startR);
                                        const endCoord = this.getCoordString(c, r);
                                        const isCap = !!this.getPiece(c,r);
                                        
                                        const historyStep = { turn: this.currentTurn, prevKingPos: { w: this.kingPos.w ? {...this.kingPos.w} : null, b: this.kingPos.b ? {...this.kingPos.b} : null, r: this.kingPos.r ? {...this.kingPos.r} : null }, multiJumpSource: null, changes: [], notation: { icon: this.draggedPiece.data.s, start: startCoord, end: endCoord, cap: isCap } };
                                        
                                        const recordState = (col, row) => { const k = this.getKey(col, row); const v = this.grid.get(k); historyStep.changes.push({ key: k, value: v }); };
                                        recordState(this.draggedPiece.startC, this.draggedPiece.startR); recordState(c, r);
                                        
                                        this.moveHistory.push(historyStep);
                                        this.updateLogUI();
                                        
                                        this.removePiece(this.draggedPiece.startC, this.draggedPiece.startR);
                                        this.draggedPiece.data.x = c; this.draggedPiece.data.y = r; this.draggedPiece.data.hasMoved = true;
                                        this.setPiece(c, r, this.draggedPiece.data);
                                        
                                        setTimeout(() => this.switchTurn(), 0);
                                    }
                                }
                            }
                        }
                    }
                }

                this.isDragging = false;
                this.isDraggingPiece = false;
                this.draggedPiece = null;
                this.highlightedMoves = []; 
                this.updateUI();
            }

            showPromotionDialog(color) {
                const overlay = document.getElementById('promotionOverlay');
                const grid = document.getElementById('promotionGrid');
                grid.innerHTML = '';

                // Determine if we are in strict classic mode
                const isClassicMode = this.virtualGen === 'classic';

                PIECE_CATEGORIES.forEach(cat => {
                    // Skip Tools and Checkers
                    if (cat.name === "Ğ†Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¸" || cat.name === "Ğ¨Ğ°ÑˆĞºĞ¸") return;

                    // IF CLASSIC MODE: Skip any category that isn't Classic
                    if (isClassicMode && !cat.name.includes("ĞšĞ»Ğ°ÑĞ¸ĞºĞ°")) return;

                    cat.items.forEach(item => {
                        // Skip Kings, Pawns, and utility buttons
                        if (['â™”','â™š','â™™','â™Ÿ','delete','eraser'].includes(item.s)) return;

                        // If color specific category, ensure it matches
                        if (cat.name.includes("ĞšĞ»Ğ°ÑĞ¸ĞºĞ°")) {
                           if (color === 'w' && cat.name.includes("Ğ§Ğ¾Ñ€Ğ½Ñ–")) return;
                           if (color === 'b' && cat.name.includes("Ğ‘Ñ–Ğ»Ñ–")) return;
                        }

                        const btn = document.createElement('button');
                        btn.className = 'promo-btn';
                        btn.innerText = item.s;
                        btn.title = item.t;
                        btn.onclick = () => this.finalizePromotion(item.s);
                        grid.appendChild(btn);
                    });
                });

                overlay.style.display = 'flex';
            }

            finalizePromotion(symbol) {
                if (!this.promotionPending) return;

                const pp = this.promotionPending;
                const startCoord = this.getCoordString(pp.startC, pp.startR);
                const endCoord = this.getCoordString(pp.endC, pp.endR);

                // --- HISTORY ---
                const historyStep = {
                    turn: this.currentTurn,
                    prevKingPos: { w: this.kingPos.w ? {...this.kingPos.w} : null, b: this.kingPos.b ? {...this.kingPos.b} : null },
                    multiJumpSource: null,
                    changes: []
                };
                const recordState = (c, r) => {
                    const k = this.getKey(c, r);
                    const v = this.grid.get(k);
                    historyStep.changes.push({ key: k, value: v });
                };
                recordState(pp.startC, pp.startR);
                recordState(pp.endC, pp.endR);
                this.moveHistory.push(historyStep);
                // --------------

                // Execute logic
                this.removePiece(pp.startC, pp.startR);

                const newPieceData = {
                    x: pp.endC,
                    y: pp.endR,
                    s: symbol,
                    c: pp.piece.c,
                    hasMoved: true
                };

                // Capture if needed
                const target = this.getPiece(pp.endC, pp.endR);
                const isCap = !!target;

                this.setPiece(pp.endC, pp.endR, newPieceData);
                this.addLogToUI(`${pp.piece.s}â${symbol}`, startCoord, endCoord, isCap);

                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                this.updateUI();
                this.switchTurn();
            }

            undoMove() {
                if (this.moveHistory.length === 0) return;
                const last = this.moveHistory.pop();

                last.changes.forEach(change => {
                    if (change.value === undefined) this.grid.delete(change.key);
                    else this.grid.set(change.key, change.value);
                });

                this.currentTurn = last.turn;
                this.kingPos = last.prevKingPos;
                this.multiJumpSource = last.multiJumpSource;
                this.gameOver = false;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.highlightedMoves = [];
                this.updateTurnIndicator();
                this.updateUI();
                this.updateLogUI(); // <--- Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ
            }

            onKeyDown(e) {
                if (this.gameOver || this.turnModeEnabled || this.promotionPending) return;
                if (e.key === 'Delete') {
                    // Default delete key behavior is now Undo via main listener
                } else if (e.shiftKey && e.key === 'Delete') {
                    // Eraser tool
                    const w = this.screenToWorld(this.mouse.x, this.mouse.y);
                    const c = Math.floor(w.x / this.cellSize);
                    const r = Math.floor(w.y / this.cellSize);
                    this.removePiece(c, r);
                    this.updateUI();
                }
            }

            screenToWorld(sx, sy) { return { x: (sx - this.camera.x) / this.camera.zoom, y: (sy - this.camera.y) / this.camera.zoom }; }

            update() {
                // ĞšĞ»Ğ°Ğ²Ñ–Ğ°Ñ‚ÑƒÑ€Ğ° (Ñ€ÑƒÑ…Ğ°Ñ” Ñ†Ñ–Ğ»ÑŒ)
                const moveSpeed = 15;
                if (this.keys.ArrowLeft) this.targetCamera.x += moveSpeed;
                if (this.keys.ArrowRight) this.targetCamera.x -= moveSpeed;
                if (this.keys.ArrowUp) this.targetCamera.y += moveSpeed;
                if (this.keys.ArrowDown) this.targetCamera.y -= moveSpeed;

                // Ğ†Ğ½Ñ‚ĞµÑ€Ğ¿Ğ¾Ğ»ÑÑ†Ñ–Ñ (Lerp)
                // Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ„Ğ°ĞºÑ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ²ÑÑŒĞ¾Ğ³Ğ¾, Ñ‰Ğ¾Ğ± Ñ€ÑƒÑ… Ğ±ÑƒĞ² ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ¸Ğ¼
                const factor = 0.12; 

                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ñ€Ñ–Ğ·Ğ½Ğ¸Ñ†Ñ, Ñ‰Ğ¾Ğ± Ğ½Ğµ Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ·Ğ°Ğ¹Ğ²Ğ¾Ğ³Ğ¾ (ĞµĞºĞ¾Ğ½Ğ¾Ğ¼Ñ–Ñ CPU)
                const diffZ = Math.abs(this.targetCamera.zoom - this.camera.zoom);
                const diffX = Math.abs(this.targetCamera.x - this.camera.x);
                const diffY = Math.abs(this.targetCamera.y - this.camera.y);

                // ĞŸĞ¾Ñ€Ñ–Ğ³ Ñ‡ÑƒÑ‚Ğ»Ğ¸Ğ²Ğ¾ÑÑ‚Ñ– Ğ·Ğ°Ğ»ĞµĞ¶Ğ¸Ñ‚ÑŒ Ğ²Ñ–Ğ´ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ñƒ
                const threshold = Math.max(1e-10, this.targetCamera.zoom * 0.0001);

                if (diffZ > threshold || diffX > 1 || diffY > 1) {
                    this.camera.zoom += (this.targetCamera.zoom - this.camera.zoom) * factor;
                    this.camera.x += (this.targetCamera.x - this.camera.x) * factor;
                    this.camera.y += (this.targetCamera.y - this.camera.y) * factor;

                    // ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ UI
                    if (this.camera.zoom > 0) {
                        document.getElementById('zoomSlider').value = Math.log10(this.camera.zoom);
                    }
                    let disp = Math.round(this.camera.zoom * 100) + '%';
                    if (this.camera.zoom < 0.01) disp = this.camera.zoom.toExponential(2);
                    document.getElementById('zoomDisplay').innerText = disp;
                } else {
                    // "ĞŸÑ€Ğ¸Ğ¼Ğ°Ğ³Ğ½Ñ–Ñ‡ÑƒÑ”Ğ¼Ğ¾" Ğ² ĞºÑ–Ğ½Ñ†Ñ– Ğ°Ğ½Ñ–Ğ¼Ğ°Ñ†Ñ–Ñ—, Ñ‰Ğ¾Ğ± Ğ¿Ñ€Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¸ Ğ¼Ñ–ĞºÑ€Ğ¾-Ñ‚Ñ€ĞµĞ¼Ñ‚Ñ–Ğ½Ğ½Ñ
                    this.camera.zoom = this.targetCamera.zoom;
                    this.camera.x = this.targetCamera.x;
                    this.camera.y = this.targetCamera.y;
                }

                // ĞĞ±Ğ¼ĞµĞ¶ÑƒÑ”Ğ¼Ğ¾ ĞºĞ°Ğ¼ĞµÑ€Ñƒ (Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ¿Ğ¾Ğ»ĞµÑ‚Ñ–Ğ»Ğ° Ğ² ĞºĞ¾ÑĞ¼Ğ¾Ñ)
                this.clampCamera();
            }

            drawCustomArrows(ctx, cs, bx, by) {
                if (!this.customArrows.length) return;

                ctx.save();
                // Ğ¡Ñ‚Ğ¸Ğ»ÑŒ ÑÑ‚Ñ€Ñ–Ğ»Ğ¾Ğº (Ğ¿Ğ¾Ğ¼Ğ°Ñ€Ğ°Ğ½Ñ‡ĞµĞ²Ğ¸Ğ¹, Ğ½Ğ°Ğ¿Ñ–Ğ²Ğ¿Ñ€Ğ¾Ğ·Ğ¾Ñ€Ğ¸Ğ¹)
                ctx.fillStyle = "rgba(255, 170, 0, 0.8)";
                ctx.strokeStyle = "rgba(255, 170, 0, 0.8)";
                ctx.lineWidth = cs * 0.15;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                const headLen = cs * 0.35; // Ğ Ğ¾Ğ·Ğ¼Ñ–Ñ€ Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¸ ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ¸

                this.customArrows.forEach(arrow => {
                    const startX = bx + arrow.sx * cs + cs / 2;
                    const startY = by + arrow.sy * cs + cs / 2;
                    const endX = bx + arrow.ex * cs + cs / 2;
                    const endY = by + arrow.ey * cs + cs / 2;

                    const dx = endX - startX;
                    const dy = endY - startY;
                    const angle = Math.atan2(dy, dx);
                    const len = Math.sqrt(dx*dx + dy*dy);

                    // Ğ¢Ñ€Ğ¾Ñ…Ğ¸ ÑĞºĞ¾Ñ€Ğ¾Ñ‡ÑƒÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ½Ñ–Ñ, Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞºÑ€Ğ¸Ğ²Ğ°Ğ»Ğ° Ñ†ĞµĞ½Ñ‚Ñ€ Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸ Ğ² ĞºÑ–Ğ½Ñ†Ñ–
                    const shorten = cs * 0.35; 
                    if (len < shorten) return;

                    const lineEndX = endX - shorten * Math.cos(angle);
                    const lineEndY = endY - shorten * Math.sin(angle);

                    // Ğ›Ñ–Ğ½Ñ–Ñ
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(lineEndX, lineEndY);
                    ctx.stroke();

                    // Ğ¢Ñ€Ğ¸ĞºÑƒÑ‚Ğ½Ğ¸Ğº (Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ°)
                    ctx.beginPath();
                    // Ğ—ÑÑƒĞ² Ğ½Ğ°Ğ·Ğ°Ğ´ Ğ´Ğ»Ñ Ğ²Ñ–ÑÑ‚Ñ€Ñ
                    const tipX = endX - (cs * 0.12) * Math.cos(angle);
                    const tipY = endY - (cs * 0.12) * Math.sin(angle);
                    
                    ctx.moveTo(tipX, tipY);
                    ctx.lineTo(
                        tipX - headLen * Math.cos(angle - Math.PI / 6),
                        tipY - headLen * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        tipX - headLen * Math.cos(angle + Math.PI / 6),
                        tipY - headLen * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                });
                ctx.restore();
            }
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width; const height = this.canvas.height;
                const cs = this.cellSize * this.camera.zoom;

                // 1. ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ
                ctx.fillStyle = this.colors.void;
                ctx.fillRect(0, 0, width, height);

                const bx = this.camera.x; const by = this.camera.y;
                // ĞœĞµĞ¶Ñ– Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾Ğ³Ğ¾ ĞµĞºÑ€Ğ°Ğ½Ñƒ (Viewport) Ğ² ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ°Ñ… ÑÑ–Ñ‚ĞºĞ¸
                const startCol = Math.floor((-this.camera.x) / cs);
                const endCol = Math.floor((width - this.camera.x) / cs) + 1;
                const startRow = Math.floor((-this.camera.y) / cs);
                const endRow = Math.floor((height - this.camera.y) / cs) + 1;
                
                const boardPixelW = this.boardSize * cs; const boardPixelH = this.boardSize * cs;

                // 2. ĞœĞ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ´Ğ¾ÑˆĞºĞ¸
                if (bx < width && by < height && bx + boardPixelW > 0 && by + boardPixelH > 0) {
                     ctx.fillStyle = this.colors.light;
                     ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), Math.min(boardPixelW, width), Math.min(boardPixelH, height));
                     ctx.fillStyle = this.colors.dark;

                     if (cs > 0.8) {
                         ctx.beginPath();
                         // ĞœĞ°Ğ»ÑÑ”Ğ¼Ğ¾ Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ñ– ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸
                         const renderStartC = Math.max(0, startCol);
                         const renderEndC = Math.min(this.boardSize, endCol);
                         const renderStartR = Math.max(0, startRow);
                         const renderEndR = Math.min(this.boardSize, endRow);

                         const gridSkip = (cs < 2) ? 2 : 1;
                         for (let r = renderStartR; r < renderEndR; r += gridSkip) {
                             let c = renderStartC;
                             if ((r % 2) !== 0) { if (c % 2 !== 0) c++; } else { if (c % 2 === 0) c++; }
                             for (; c < renderEndC; c += 2) {
                                 ctx.rect((bx + c * cs) | 0, (by + r * cs) | 0, Math.ceil(cs), Math.ceil(cs));
                             }
                         }
                         ctx.fill();
                     } else {
                         ctx.globalAlpha = 0.5;
                         ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), Math.min(boardPixelW, width), Math.min(boardPixelH, height));
                         ctx.globalAlpha = 1.0;
                     }
                     ctx.strokeStyle = this.colors.border;
                     ctx.lineWidth = Math.max(2, cs * 0.1);
                     ctx.strokeRect(bx, by, boardPixelW, boardPixelH);
                }

                // 3. ĞŸÑ–Ğ´ÑĞ²Ñ–Ñ‚ĞºĞ° Ğ¨Ğ°Ñ…/ĞœĞ°Ñ‚
                if (this.rulesEnabled && cs > 2) {
                    for (const color of ['w', 'b']) {
                        if (this.kingsInCheck[color]) {
                            const k = this.kingsInCheck[color];
                            // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ğ²Ğ¸Ğ´Ğ½Ğ¾ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ
                            if (k.c >= startCol && k.c <= endCol && k.r >= startRow && k.r <= endRow) {
                                ctx.fillStyle = (this.gameOver && this.currentTurn === color) ? this.colors.mateHighlight : this.colors.checkHighlight;
                                ctx.fillRect(bx + k.c * cs, by + k.r * cs, cs, cs);
                            }
                        }
                    }
                }

                // 4. ĞŸĞ†Ğ”Ğ¡Ğ’Ğ†Ğ¢ĞšĞ Ğ¥ĞĞ”Ğ†Ğ’ (ĞĞŸĞ¢Ğ˜ĞœĞ†Ğ—ĞĞ’ĞĞĞ Ğ”Ğ›Ğ¯ 1 ĞœĞ›Ğ Ğ”)
                if (this.highlightedMoves.length > 0) {
                    // Ğ¢Ñ€Ğ¾Ñ…Ğ¸ Ñ€Ğ¾Ğ·ÑˆĞ¸Ñ€ÑÑ”Ğ¼Ğ¾ Ğ¼ĞµĞ¶Ñ– Ğ´Ğ»Ñ Ğ¿Ğ»Ğ°Ğ²Ğ½Ğ¾ÑÑ‚Ñ–
                    const viewMinC = startCol - 1;
                    const viewMaxC = endCol + 1;
                    const viewMinR = startRow - 1;
                    const viewMaxR = endRow + 1;

                    ctx.fillStyle = "rgba(46, 204, 113, 0.8)"; // Ğ—ĞµĞ»ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Ñ‚Ğ¾Ñ‡Ğ¾Ğº

                    this.highlightedMoves.forEach(move => {
                        // A. Ğ ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ½Ğ³ Ğ¾ĞºÑ€ĞµĞ¼Ğ¸Ñ… Ñ‚Ğ¾Ñ‡Ğ¾Ğº (ÑÑ‚Ñ€Ğ¸Ğ±ĞºĞ¸, Ğ°Ñ‚Ğ°ĞºĞ¸)
                        if (move.type === 'point') {
                            if (move.c >= viewMinC && move.c <= viewMaxC && move.r >= viewMinR && move.r <= viewMaxR) {
                                const hx = bx + move.c * cs + cs/2;
                                const hy = by + move.r * cs + cs/2;
                                ctx.beginPath();
                                if (move.capture) {
                                    const capSize = Math.max(cs * 0.35, 4);
                                    ctx.fillStyle = "rgba(200, 50, 50, 0.7)";
                                    ctx.arc(hx, hy, capSize, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.fillStyle = "rgba(46, 204, 113, 0.8)"; // ĞŸĞ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ğ¼Ğ¾ Ğ·ĞµĞ»ĞµĞ½Ğ¸Ğ¹
                                } else {
                                    const dotSize = Math.max(cs * 0.18, 3);
                                    ctx.arc(hx, hy, dotSize, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        } 
                        // B. Ğ ĞµĞ½Ğ´ĞµÑ€Ğ¸Ğ½Ğ³ Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ñ–Ğ² (RAYS) - ĞœĞ°Ğ³Ñ–Ñ Ğ´Ğ»Ñ Ğ¼Ñ–Ğ»ÑŒÑÑ€Ğ´Ñ–Ğ² ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ğ¾Ğº
                        else if (move.type === 'ray') {
                            // ĞœĞ¸ Ğ¼Ğ°Ñ”Ğ¼Ğ¾ Ğ»Ñ–Ğ½Ñ–Ñ: P = Start + t * Dir, Ğ´Ğµ 0 < t <= len
                            // ĞĞ°Ğ¼ Ñ‚Ñ€ĞµĞ±Ğ° Ğ·Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ´Ñ–Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ T (t_min, t_max), ÑĞºĞ¸Ğ¹ Ğ¿Ğ¾Ñ‚Ñ€Ğ°Ğ¿Ğ»ÑÑ” Ñƒ Viewport.

                            let tMin = 1;         // ĞŸĞ¾Ñ‡Ğ¸Ğ½Ğ°Ñ”Ğ¼Ğ¾ Ğ· 1 (Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ° ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ°)
                            let tMax = move.len;  // ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ° Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ğ° Ñ…Ğ¾Ğ´Ñƒ

                            // Ğ’Ñ–Ğ´ÑÑ–ĞºĞ°Ğ½Ğ½Ñ Ğ¿Ğ¾ X
                            if (move.dx > 0) {
                                tMin = Math.max(tMin, viewMinC - move.cx);
                                tMax = Math.min(tMax, viewMaxC - move.cx);
                            } else if (move.dx < 0) {
                                tMin = Math.max(tMin, move.cx - viewMaxC);
                                tMax = Math.min(tMax, move.cx - viewMinC);
                            } else {
                                // Ğ¯ĞºÑ‰Ğ¾ Ñ€ÑƒÑ… Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¸Ğ¹, Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ X Ğ² Ğ¼ĞµĞ¶Ğ°Ñ… ĞµĞºÑ€Ğ°Ğ½Ñƒ
                                if (move.cx < viewMinC || move.cx > viewMaxC) return; // ĞŸÑ€Ğ¾Ğ¼Ñ–Ğ½ÑŒ Ğ·Ğ° Ğ¼ĞµĞ¶Ğ°Ğ¼Ğ¸ ĞµĞºÑ€Ğ°Ğ½Ñƒ Ğ¿Ğ¾ X
                            }

                            // Ğ’Ñ–Ğ´ÑÑ–ĞºĞ°Ğ½Ğ½Ñ Ğ¿Ğ¾ Y
                            if (move.dy > 0) {
                                tMin = Math.max(tMin, viewMinR - move.cy);
                                tMax = Math.min(tMax, viewMaxR - move.cy);
                            } else if (move.dy < 0) {
                                tMin = Math.max(tMin, move.cy - viewMaxR);
                                tMax = Math.min(tMax, move.cy - viewMinR);
                            } else {
                                // Ğ¯ĞºÑ‰Ğ¾ Ñ€ÑƒÑ… Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹, Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Y Ğ² Ğ¼ĞµĞ¶Ğ°Ñ… ĞµĞºÑ€Ğ°Ğ½Ñƒ
                                if (move.cy < viewMinR || move.cy > viewMaxR) return; // ĞŸÑ€Ğ¾Ğ¼Ñ–Ğ½ÑŒ Ğ·Ğ° Ğ¼ĞµĞ¶Ğ°Ğ¼Ğ¸ ĞµĞºÑ€Ğ°Ğ½Ñƒ Ğ¿Ğ¾ Y
                            }

                            // Ğ¯ĞºÑ‰Ğ¾ Ñ” Ğ¿ĞµÑ€ĞµÑ‚Ğ¸Ğ½ (Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¸Ğ¹ Ğ²Ñ–Ğ´Ñ€Ñ–Ğ·Ğ¾Ğº)
                            if (tMin <= tMax) {
                                // Ğ¦Ğ¸ĞºĞ» Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ Ğ¿Ğ¾ Ğ’Ğ˜Ğ”Ğ˜ĞœĞ˜Ğ¥ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ°Ñ… (Ğ·Ğ°Ğ·Ğ²Ğ¸Ñ‡Ğ°Ğ¹ 20-50 Ñ–Ñ‚ĞµÑ€Ğ°Ñ†Ñ–Ğ¹, Ğ½Ğ°Ğ²Ñ–Ñ‚ÑŒ ÑĞºÑ‰Ğ¾ Ñ…Ñ–Ğ´ Ğ½Ğ° Ğ¼Ñ–Ğ»ÑŒÑÑ€Ğ´)
                                for (let t = tMin; t <= tMax; t++) {
                                    const gridX = move.cx + t * move.dx;
                                    const gridY = move.cy + t * move.dy;
                                    
                                    const hx = bx + gridX * cs + cs/2;
                                    const hy = by + gridY * cs + cs/2;
                                    
                                    const dotSize = Math.max(cs * 0.18, 3);
                                    
                                    ctx.beginPath();
                                    ctx.arc(hx, hy, dotSize, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        }
                    });
                }

                // 5. Ğ¢ĞµĞºÑÑ‚ Ñ– Ğ¡Ñ‚Ñ€Ñ–Ğ»ĞºĞ¸
                if (cs > 5) this.drawCustomArrows(ctx, cs, bx, by);
                if (cs > 25) {
                    const fontSize = Math.max(cs * 0.25, 12); ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; const labelX = bx - 5;
                    const rStart = Math.max(0, startRow); const rEnd = Math.min(this.boardSize, endRow);
                    for(let r = rStart; r < rEnd; r++) {
                        const rankVal = this.boardSize - r; const labelY = by + r*cs + cs/2;
                        if(labelY > 0 && labelY < height) { ctx.fillStyle = '#ccc'; ctx.fillText(rankVal.toString(), labelX, labelY); }
                    }
                    ctx.textAlign = 'center'; ctx.textBaseline = 'top'; const labelYBottom = by + this.boardSize*cs + 5;
                    const cStart = Math.max(0, startCol); const cEnd = Math.min(this.boardSize, endCol);
                    for(let c = cStart; c < cEnd; c++) {
                        const labelXPos = bx + c*cs + cs/2;
                        if(labelXPos > 0 && labelXPos < width) { ctx.fillStyle = '#ccc'; ctx.fillText(this.getFileLabel(c), labelXPos, labelYBottom); }
                    }
                }

                // 6. Ğ¤Ñ–Ğ³ÑƒÑ€Ğ¸
                const visibleCellsW = endCol - startCol;
                const visibleCellsH = endRow - startRow;
                const totalVisible = visibleCellsW * visibleCellsH;
                let skip = 1;
                // ĞĞ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞº Ğ¿Ñ€Ğ¸ ÑĞ¸Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ Ğ²Ñ–Ğ´Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ–, Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ñ‚Ğ¸ÑÑÑ‡Ñ– Ñ–ĞºĞ¾Ğ½Ğ¾Ğº Ğ² Ğ¾Ğ´Ğ½Ñ–Ğ¹ Ñ‚Ğ¾Ñ‡Ñ†Ñ–
                if (totalVisible > 50000) skip = Math.ceil(Math.sqrt(totalVisible / 50000));
                
                const minDrawSize = 12;
                const drawSize = Math.max(cs, minDrawSize);

                const renderStartC = Math.max(0, startCol);
                const renderEndC = Math.min(this.boardSize, endCol);
                const renderStartR = Math.max(0, startRow);
                const renderEndR = Math.min(this.boardSize, endRow);

                for (let r = renderStartR; r < renderEndR; r += skip) {
                    for (let c = renderStartC; c < renderEndC; c += skip) {
                        if (this.isDraggingPiece && this.draggedPiece && this.draggedPiece.startC === c && this.draggedPiece.startR === r) continue;
                        const piece = this.getPiece(c, r);
                        if (!piece) continue;
                        const px = (bx + c * cs + cs/2) | 0;
                        const py = (by + r * cs + cs/2) | 0;
                        const sprite = this.getLowResSprite(piece.s, piece.c);
                        ctx.drawImage(sprite, px - drawSize/2, py - drawSize/2, drawSize, drawSize);
                    }
                }

                if (this.isDraggingPiece && this.draggedPiece) {
                    this.drawPiece(ctx, this.draggedPiece.data, this.mouse.x | 0, this.mouse.y | 0, Math.max(cs, 40));
                }
            }

            drawPiece(ctx, pieceData, x, y, size) {
                const sprite = this.getPieceSprite(pieceData.s, pieceData.c);
                const drawSize = size * 0.85;
                ctx.drawImage(sprite, (x - drawSize/2) | 0, (y - drawSize/2) | 0, drawSize | 0, drawSize | 0);
            }

            formatCount(n) {
                if (!isFinite(n)) return "ĞĞµÑĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ½Ñ–ÑÑ‚ÑŒ";
                if (n < 1000) return n;

                // --- Ğ•Ñ‚Ğ°Ğ¿ 1: Ğ¡ĞºĞ¾Ñ€Ğ¾Ñ‡ĞµĞ½Ğ½Ñ Ğ´Ğ»Ñ "Ğ¼Ğ°Ğ»Ğ¸Ñ…" Ğ²ĞµĞ»Ğ¸ĞºĞ¸Ñ… Ñ‡Ğ¸ÑĞµĞ» ---
                // (Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ·Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¿Ñ€Ğ¸Ğ¹Ğ½ÑÑ‚Ñ– Ğ°Ğ±Ñ€ĞµĞ²Ñ–Ğ°Ñ‚ÑƒÑ€Ğ¸)
                if (n < 1e12) {
                    if (n >= 1e9) return (n / 1e9).toFixed(2) + " Ğ¼Ğ»Ñ€Ğ´";
                    if (n >= 1e6) return (n / 1e6).toFixed(2) + " Ğ¼Ğ»Ğ½";
                    return (n / 1000).toFixed(1) + " Ñ‚Ğ¸Ñ.";
                }

                // --- Ğ•Ñ‚Ğ°Ğ¿ 2: ĞŸĞ¾Ğ²Ğ½Ñ– Ğ½Ğ°Ğ·Ğ²Ğ¸ Ğ²Ñ–Ğ´ Ğ¢Ñ€Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ğ° ---
                
                // Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ñ‡Ğ¸ÑĞ»Ğ°
                let exp = Math.floor(Math.log10(n) / 3);

                // Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¸Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ñ… Ğ½Ğ°Ğ·Ğ² (Ğ´Ğ¾ Ğ”ĞµÑ†Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ğ° Ğ²ĞºĞ»ÑÑ‡Ğ½Ğ¾)
                // Ğ†Ğ½Ğ´ĞµĞºÑĞ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°ÑÑ‚ÑŒ ÑÑ‚ĞµĞ¿ĞµĞ½ÑĞ¼: 3->Ñ‚Ğ¸Ñ, 4->Ñ‚Ñ€Ğ»Ğ½ Ñ– Ñ‚.Ğ´.
                // ĞĞ°Ğ¼ Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±Ğ½Ñ– Ñ–Ğ½Ğ´ĞµĞºÑĞ¸ Ğ²Ñ–Ğ´ 4 (10^12)
                const fullNames = [
                    "", "", "", "", // 0-3 Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ (Ñ‚Ğ°Ğ¼ Ñ‚Ğ¸Ñ, Ğ¼Ğ»Ğ½, Ğ¼Ğ»Ñ€Ğ´)
                    " Ñ‚Ñ€Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²",      // 4 (10^12)
                    " ĞºĞ²Ğ°Ğ´Ñ€Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²",   // 5 (10^15)
                    " ĞºĞ²Ñ–Ğ½Ñ‚Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²",   // 6 (10^18)
                    " ÑĞµĞºÑÑ‚Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²",   // 7 (10^21)
                    " ÑĞµĞ¿Ñ‚Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²",    // 8 (10^24)
                    " Ğ¾ĞºÑ‚Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²",     // 9 (10^27)
                    " Ğ½Ğ¾Ğ½Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²",     // 10 (10^30)
                    " Ğ´ĞµÑ†Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²"      // 11 (10^33)
                ];

                if (exp < fullNames.length) {
                    return (n / Math.pow(10, exp * 3)).toFixed(2) + fullNames[exp];
                }

                // --- Ğ•Ñ‚Ğ°Ğ¿ 3: Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ ÑĞºĞ»Ğ°Ğ´Ğ½Ğ¸Ñ… Ğ½Ğ°Ğ·Ğ² (Ğ¿Ñ–ÑĞ»Ñ Ğ”ĞµÑ†Ğ¸Ğ»ÑŒĞ¹Ğ¾Ğ½Ğ°) ---
                // Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: [ĞŸÑ€ĞµÑ„Ñ–ĞºÑ Ğ¾Ğ´Ğ¸Ğ½Ğ¸Ñ†ÑŒ] + [ĞšĞ¾Ñ€Ñ–Ğ½ÑŒ Ğ´ĞµÑÑÑ‚ĞºÑ–Ğ²] + "Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²"
                
                const units = ["", "Ğ£Ğ½", "Ğ”ÑƒĞ¾", "Ğ¢Ñ€Ğµ", "ĞšĞ²Ğ°Ñ‚ÑƒĞ¾Ñ€", "ĞšĞ²Ñ–Ğ½", "Ğ¡ĞµĞºÑ", "Ğ¡ĞµĞ¿Ñ‚ĞµĞ½", "ĞĞºÑ‚Ğ¾", "ĞĞ¾Ğ²ĞµĞ¼"];
                const tens = ["", "Ğ”ĞµÑ†", "Ğ’Ñ–Ğ³Ñ–Ğ½Ñ‚", "Ğ¢Ñ€Ğ¸Ğ³Ñ–Ğ½Ñ‚", "ĞšĞ²Ğ°Ğ´Ñ€Ğ°Ğ³Ñ–Ğ½Ñ‚", "ĞšĞ²Ñ–Ğ½ĞºĞ²Ğ°Ğ³Ñ–Ğ½Ñ‚", "Ğ¡ĞµĞºÑĞ°Ğ³Ñ–Ğ½Ñ‚", "Ğ¡ĞµĞ¿Ñ‚ÑƒĞ°Ğ³Ñ–Ğ½Ñ‚", "ĞĞºÑ‚Ğ¾Ğ³Ñ–Ğ½Ñ‚", "ĞĞ¾Ğ½Ğ°Ğ³Ñ–Ğ½Ñ‚"];

                // ĞšĞ¾Ñ€ĞµĞºÑ†Ñ–Ñ Ñ–Ğ½Ğ´ĞµĞºÑÑƒ
                let idx = exp - 1; 
                const unitIdx = idx % 10;
                const tenIdx = Math.floor(idx / 10);

                // ĞÑÑ‚Ğ°Ğ½Ğ½Ñ” Ñ‡Ğ¸ÑĞ»Ğ¾ - Ğ¦ĞµĞ½Ñ‚Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½
                if (tenIdx >= 10) return (n / 1e303).toFixed(2) + " Ğ¦ĞµĞ½Ñ‚Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²";

                // Ğ¡ĞºĞ»ĞµÑÑ”Ğ¼Ğ¾: Ğ½Ğ°Ğ¿Ñ€Ğ¸ĞºĞ»Ğ°Ğ´ "Ğ£Ğ½" + "Ğ”ĞµÑ†" + "Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²"
                const suffix = " " + units[unitIdx] + tens[tenIdx] + "Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²";

                return (n / Math.pow(10, exp * 3)).toFixed(2) + suffix;
            }

            updatePieceCounts() {
                let w = 0, b = 0;

                // 1. Ğ‘ĞĞ—ĞĞ’Ğ˜Ğ™ ĞŸĞ†Ğ”Ğ ĞĞ¥Ğ£ĞĞĞš (Ğ”Ğ»Ñ Ğ²Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ñ…/Ğ¿Ñ€Ğ¾Ñ†ĞµĞ´ÑƒÑ€Ğ½Ğ¸Ñ… Ğ´Ğ¾ÑˆĞ¾Ğº)
                if (this.virtualGen) {
                    let rows = 0;
                    if (this.virtualGen === 'chess960') {
                        rows = 2; 
                    } else {
                        rows = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                        if (this.virtualGen !== 'checkers' && rows < 2) rows = 2;
                    }
                    
                    let totalBase = this.boardSize * rows; 
                    
                    if (this.virtualGen === 'checkers') {
                        totalBase = Math.floor(totalBase / 2);
                    }

                    w = totalBase;
                    b = totalBase;
                }

                // 2. ĞšĞĞ Ğ•ĞšĞ¦Ğ†Ğ¯ ĞĞ ĞĞ¡ĞĞĞ’Ğ† Ğ—ĞœĞ†Ğ (GRID)
                for (const [key, val] of this.grid) {
                    const [cx, cy] = key.split(',').map(Number);

                    if (this.virtualGen) {
                        let rows = 0;
                        if (this.virtualGen === 'chess960') rows = 2;
                        else {
                            rows = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                            if (this.virtualGen !== 'checkers' && rows < 2) rows = 2;
                        }

                        if (cy < rows) {
                            if (this.virtualGen !== 'checkers' || this.isDarkSquare(cx, cy)) {
                                b--; 
                            }
                        }
                        else if (cy >= this.boardSize - rows) {
                            if (this.virtualGen !== 'checkers' || this.isDarkSquare(cx, cy)) {
                                w--;
                            }
                        }
                    }

                    if (val !== GRID_VOID) {
                        const id = val & 0xFFFF;
                        const p = this.palette[id - 1];
                        if (p.c === 'w') w++;
                        else if (p.c === 'b') b++;
                    }
                }

                // --- 3. ĞĞĞ’Ğ˜Ğ™ Ğ’Ğ˜Ğ’Ğ†Ğ” Ğ’ HTML (Ğ— Ğ¢ĞĞ§ĞĞĞ® ĞšĞ†Ğ›Ğ¬ĞšĞ†Ğ¡Ğ¢Ğ®) ---
                
                // Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ BigInt, Ñ‰Ğ¾Ğ± Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ½Ğµ Ğ²Ñ‚Ñ€Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ‚Ğ¾Ñ‡Ğ½Ñ–ÑÑ‚ÑŒ Ğ½Ğ° Ğ´Ğ¾ÑˆĞºĞ°Ñ… 1M x 1M
                const totalSquaresBig = BigInt(this.boardSize) * BigInt(this.boardSize);
                
                // Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ Ğ²Ğ°ÑˆĞµ ÑĞºĞ¾Ñ€Ğ¾Ñ‡ĞµĞ½Ğ½Ñ (Ğ½Ğ°Ğ¿Ñ€Ğ¸ĞºĞ»Ğ°Ğ´ "1 Ğ¼Ğ»Ğ½")
                const shortStr = this.formatCount(Number(totalSquaresBig));
                
                // Ğ“ĞµĞ½ĞµÑ€ÑƒÑ”Ğ¼Ğ¾ Ñ‚Ğ¾Ñ‡Ğ½Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ· Ğ¿Ñ€Ğ¾Ğ±Ñ–Ğ»Ğ°Ğ¼Ğ¸ (Ğ½Ğ°Ğ¿Ñ€Ğ¸ĞºĞ»Ğ°Ğ´ "1 000 000")
                const exactStr = totalSquaresBig.toLocaleString('uk-UA');

                // Ğ¤Ğ¾Ñ€Ğ¼ÑƒÑ”Ğ¼Ğ¾ Ñ€ÑĞ´Ğ¾Ğº: ÑĞºÑ‰Ğ¾ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ²ĞµĞ»Ğ¸ĞºĞµ (>999), Ğ¿Ğ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾ [Ñ‚Ğ¾Ñ‡Ğ½Ğµ] Ğ¿Ğ¾Ñ€ÑƒÑ‡
                let countDisplay = shortStr;
                if (totalSquaresBig > 999n) {
                    countDisplay = `${shortStr} <span style="font-size:0.85em; color:#555; font-weight:normal;">[${exactStr}]</span>`;
                } else {
                    countDisplay = exactStr;
                }

                const boardInfo = `${this.boardSize}x${this.boardSize}, ${countDisplay}`;

                const html = `
                    <div style="margin-bottom: 4px; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 4px; font-size: 13px; color: #333;">
                        ğŸ“ ĞšĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸: <b>(${boardInfo})</b>
                    </div>
                    <span style="color:#555; font-weight:bold;">Ğ¤Ñ–Ğ³ÑƒÑ€: ${this.formatCount(w+b)}</span> 
                    (<span style="color:#27ae60">Ğ‘: ${this.formatCount(w)}</span> | 
                    <span style="color:#c0392b">Ğ§: ${this.formatCount(b)}</span>)
                `;
                document.getElementById('count').innerHTML = html;
            }

            updateUI() {
                // Ğ’Ğ¸ĞºĞ»Ğ¸ĞºĞ°Ñ”Ğ¼Ğ¾ Ğ½Ğ°ÑˆÑƒ Ğ½Ğ¾Ğ²Ñƒ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ¿Ñ–Ğ´Ñ€Ğ°Ñ…ÑƒĞ½ĞºÑƒ
                this.updatePieceCounts();
            }

            animate() {
                const now = performance.now();
                if (Math.random() < 0.05) document.getElementById('fps').innerText = Math.round(1000 / (now - this.renderTime || 16));
                this.renderTime = now;
                this.update();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }

        const game = new SmoothChess();
    </script>
</body>
</html>