<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mega Chess: Color Fix</title>
    <style>
        /* --- STYLES --- */
        body { margin: 0; padding: 0; overflow: hidden; font-family: "Segoe UI", Arial, sans-serif; background: #eeeed2; user-select: none; }
        #canvas { display: block; cursor: grab; }
        #canvas:active { cursor: grabbing; }

        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.94);
            padding: 12px; border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            width: 380px;
            max-height: 95vh;
            overflow-y: auto;
            backdrop-filter: blur(8px); z-index: 10;
            transition: opacity 0.3s;
            display: flex; flex-direction: column; gap: 10px;
        }
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 4px; }
        #controls::-webkit-scrollbar-thumb { background: #bbb; border-radius: 4px; }

        #turnIndicator {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px);
            color: #333; padding: 8px 25px; border-radius: 50px; font-size: 20px;
            font-weight: bold; border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); 
            /* –í–∞–∂–ª–∏–≤–æ: —Ä–æ–±–∏–º–æ –∫–Ω–æ–ø–∫—É –∫–ª—ñ–∫–∞–±–µ–ª—å–Ω–æ—é —ñ –ø–æ–≤–µ—Ä—Ö –≤—Å—å–æ–≥–æ */
            pointer-events: auto; 
            cursor: pointer; 
            user-select: none;
            display: flex; align-items: center; gap: 10px; transition: 0.2s; 
            z-index: 20; /* –ü—ñ–¥–Ω—è–ª–∏ –≤–∏—â–µ –º–µ–Ω—é */
        }
        #turnIndicator:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }
        #turnIndicator:active {
            transform: translateX(-50%) scale(0.95);
        }
        /* –ü—ñ–¥–∫–∞–∑–∫–∞ */
        #turnIndicator::after {
            content: "‚áÑ";
            font-size: 18px;
            margin-left: 5px;
            opacity: 0.5;
        }

        #loadingOverlay {
            position: absolute; bottom: 20px; right: 20px; width: 300px;
            background: rgba(0,0,0,0.8); display: none; padding: 15px; border-radius: 10px;
            flex-direction: column; justify-content: center; align-items: flex-start;
            z-index: 200; color: white; backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        .progress-bar { width: 100%; height: 6px; background: #444; border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.1s; }

        /* --- PROMOTION OVERLAY STYLES --- */
        #promotionOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center;
            z-index: 150; backdrop-filter: blur(8px); animation: fadeIn 0.3s;
        }
        .promo-card {
            background: white; padding: 25px; border-radius: 16px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 2px solid #3498db;
            width: 500px; max-height: 80vh; display: flex; flex-direction: column;
            animation: popIn 0.3s forwards;
        }
        .promo-header { font-size: 24px; margin-bottom: 15px; color: #2c3e50; font-weight: bold; }
        .promo-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 8px;
            overflow-y: auto; padding: 10px; border: 1px solid #eee; border-radius: 8px; background: #f9f9f9;
        }

        .promo-btn {
            font-size: 30px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
            padding: 5px;
            color: #000 !important;
            line-height: 1;
        }
        .promo-btn:hover { background: #e3f2fd; transform: scale(1.1); border-color: #3498db; }

        #gameOverOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center;
            z-index: 100; backdrop-filter: blur(5px); animation: fadeIn 0.5s;
        }
        .victory-card {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 4px solid #f1c40f;
            min-width: 300px; transform: scale(0.9); animation: popIn 0.3s forwards;
        }
        .victory-card h1 { margin: 0; color: #e74c3c; font-size: 48px; text-transform: uppercase; }
        .victory-card h2 { margin: 10px 0 30px 0; color: #2c3e50; font-size: 24px; }
        .victory-card .winner-icon { font-size: 60px; margin: 10px 0; display: block; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes popIn { to { transform: scale(1); } }

        h3 { margin: 0 0 5px 0; color: #2c3e50; font-size: 18px; border-bottom: 1px solid #ddd; padding-bottom: 8px; }
        .control-group { margin-bottom: 5px; }
        label { display: block; margin-bottom: 4px; font-size: 12px; font-weight: 700; color: #555; text-transform: uppercase; }
        input, button { width: 100%; padding: 6px; box-sizing: border-box; border-radius: 6px; border: 1px solid #ccc; font-size: 13px; }

        .btn-row { display: flex; gap: 4px; margin-top: 4px; }
        button { background: #769656; color: white; border: none; cursor: pointer; font-weight: 600; transition: 0.1s; }
        button:hover { background: #5d7c40; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        button.secondary { background: #9ca3af; }
        button.secondary:hover { background: #6b7280; }
        button.danger { background: #e74c3c; }
        button.danger:hover { background: #c0392b; }
        button.action { background: #f39c12; }
        button.action:hover { background: #d35400; }
        button.checkers { background: #8e44ad; }
        button.checkers:hover { background: #732d91; }
        button.classic { background: #3498db; }
        button.classic:hover { background: #2980b9; }
        button.undo-btn { background: #555; }
        button.undo-btn:hover { background: #333; }

        /* --- LOG STYLES --- */
         #logContainer {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-top: 5px;
            height: 140px;
            overflow-y: auto;
            position: relative;
        }
        #logContainer::-webkit-scrollbar { width: 6px; }
        #logContainer::-webkit-scrollbar-thumb { background: #ccc; }

        #logTable {
            width: 100%;
            border-collapse: collapse;
            font-family: "Segoe UI Mono", monospace;
            font-size: 12px;
            table-layout: fixed;
        }
        #logTable th {
            position: sticky; top: 0;
            background: #e0e0e0;
            color: #555;
            padding: 4px;
            font-size: 11px;
            z-index: 2;
            text-align: center;
            border-bottom: 1px solid #ccc;
        }
        #logTable td {
            padding: 3px 5px;
            border-bottom: 1px solid #f0f0f0;
            color: #333;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }
        #logTable tr:nth-child(even) { background: #f9f9f9; }
        
        .log-num { width: 30px; color: #999; font-weight: bold; border-right: 1px solid #eee; background: #fafafa; }
        .move-icon { font-weight: bold; color: #2c3e50; margin-right: 2px; }
        .move-cap { color: #c0392b; font-weight: bold; margin-left: 2px; font-size: 10px; }
        .move-coords { color: #444; }

        .piece-container { display: flex; flex-direction: column; gap: 8px; }
        .category-block { background: rgba(0,0,0,0.03); border-radius: 6px; padding: 6px; border: 1px solid rgba(0,0,0,0.05); }
        .grid-header { font-size: 11px; font-weight: bold; text-transform: uppercase; color: #666; margin-bottom: 4px; text-align: center; background: #e0e0e0; border-radius: 3px; padding: 2px; }
        .piece-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; }
        .piece-btn { aspect-ratio: 1; padding: 0; font-size: 22px; background: #fff; color: #333; border: 1px solid #ccc; cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: transform 0.1s, background 0.1s; }
        .piece-btn:hover { background: #fff; transform: scale(1.15); z-index: 5; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .piece-btn.selected { background: #769656; color: white; border-color: #4b6334; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        .piece-btn.eraser { 
            background: #ffebee; 
            color: #c0392b; 
            border-color: #e74c3c; 
            font-size: 22px; /* –ó–±—ñ–ª—å—à–∏–º–æ —ñ–∫–æ–Ω–∫—É */
            font-weight: bold;
        }
        .piece-btn.eraser:hover {
            background: #ffcdd2;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        .piece-btn.black-piece { background: #333; color: #eee; border-color: #000; }
        .piece-btn.black-piece:hover { background: #555; }

        .info-panel { margin-top: 10px; padding: 8px; background: rgba(241, 242, 246, 0.8); border-radius: 6px; font-size: 12px; color: #555; text-align: center;}
        #debug { position: absolute; top: 10px; right: 10px; color: #555; background: rgba(255,255,255,0.5); padding: 5px 10px; border-radius: 4px; font-family: monospace; pointer-events: none; z-index: 5; }

        .input-row { display: flex; gap: 5px; align-items: center; justify-content: space-between; margin-bottom: 5px;}
        .input-row input[type="number"] { width: 60px; }
        .input-row span { font-size: 12px; font-weight: bold; }
        input[type=range] { padding: 0; margin: 5px 0; }
        .separator { border-top: 1px dashed #ccc; margin: 5px 0; }
        .gen-panel { background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; border: 1px solid rgba(0,0,0,0.1); }

        #opt-warning { color: #d35400; font-weight: bold; display: none; margin-top: 5px; font-size: 11px; text-align: center;}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="loadingOverlay">
        <strong id="loadingText">–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Å–≤—ñ—Ç—É...</strong>
        <div class="progress-bar">
            <div id="loadingProgress" class="progress-fill"></div>
        </div>
        <div style="font-size: 10px; margin-top: 5px; color: #ccc">–û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—è...</div>
    </div>

    <!-- PROMOTION OVERLAY -->
    <div id="promotionOverlay">
        <div class="promo-card">
            <div class="promo-header">‚ú® –û–±–µ—Ä—ñ—Ç—å —Ñ—ñ–≥—É—Ä—É ‚ú®</div>
            <div id="promotionGrid" class="promo-grid">
                <!-- Buttons will be injected here -->
            </div>
            <div style="margin-top:10px; font-size:12px; color:#777;">–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ —Ñ—ñ–≥—É—Ä—É –¥–ª—è –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è</div>
        </div>
    </div>

    <div id="turnIndicator">
        <span id="turnIcon" style="font-size: 30px;">‚ôî</span>
        <span id="turnText">–•—ñ–¥: –ë—ñ–ª—ñ</span>
    </div>

    <div id="gameOverOverlay">
        <div class="victory-card">
            <h1>–ú–ê–¢!</h1>
            <span class="winner-icon" id="winnerIcon">üèÜ</span>
            <h2 id="winnerTxt">–ü–µ—Ä–µ–º–æ–≥–∞ –ë—ñ–ª–∏—Ö</h2>
            <button class="action" onclick="game.resetGame()">üîÑ –ù–æ–≤–∞ –≥—Ä–∞</button>
        </div>
    </div>

    <div id="controls">
        <h3>üöÄ Mega Chess: Unlimited</h3>

        <div class="control-group">
            <label>–†–æ–∑–º—ñ—Ä –¥–æ—à–∫–∏:</label>
            <input type="number" id="boardSize" value="32" min="2">
            <div class="btn-row">
                <button class="secondary" onclick="game.setSize(100)">100</button>
                <button class="secondary" onclick="game.setSize(1000)">1K</button>
                <button class="secondary" onclick="game.setSize(50000)">50K</button>
                <button class="secondary" onclick="game.setSize(1000000)">1M</button>
            </div>
        </div>

        <div class="control-group gen-panel">
             <label>‚öîÔ∏è –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è:</label>
             <div class="input-row">
                 <span>–ó–∞–ø–æ–≤–Ω–µ–Ω–Ω—è (%):</span>
                 <input type="number" id="fillPercent" value="25" min="1" max="50">
             </div>
             <div class="input-row">
                <span>–§–µ–Ω—Ç–µ–∑—ñ %:</span>
                <span id="fantasyPercentDisplay">40%</span>
             </div>
             <input type="range" id="fantasyMix" min="0" max="100" value="40" step="10">

             <div class="btn-row">
                 <button class="classic" onclick="game.fillClassic()">‚ôüÔ∏è –ö–ª–∞—Å.</button>
                 <button class="classic" onclick="game.fillChess960()">üé≤ 960</button>
                 <button class="danger" onclick="game.fillArmy()">‚öîÔ∏è –ê—Ä–º—ñ—è</button>
                 <button class="action" onclick="game.fillFantasy()">üé≤ –ú—ñ–∫—Å</button>
                 <button class="checkers" onclick="game.fillCheckers()">‚ö™‚ö´ –®–∞—à–∫–∏</button>
             </div>

        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>–†–µ–∂–∏–º–∏:</label>
             <div class="btn-row">
                 <button class="undo-btn" onclick="game.undoMove()">‚Ü©Ô∏è –ù–∞–∑–∞–¥ (Del)</button>
                 <button id="rulesBtn" onclick="game.toggleRules()">üü¢ –ü—Ä–∞–≤–∏–ª–∞</button>
             </div>
             <div class="btn-row">
                 <button id="turnBtn" onclick="game.toggleTurnMode()">üü¢ –•—ñ–¥ (–í–ö–õ)</button>
             </div>
        </div>

        <div class="control-group">
            <label>üìú –ó–∞–ø–∏—Å —Ö–æ–¥—ñ–≤:</label>
            <div id="logContainer">
                <table id="logTable">
                    <thead>
                        <tr>
                            <th class="log-num">#</th>
                            <th>–ë—ñ–ª—ñ</th>
                            <th>–ß–æ—Ä–Ω—ñ</th>
                        </tr>
                    </thead>
                    <tbody id="logTableBody">
                        <!-- –•–æ–¥–∏ –±—É–¥—É—Ç—å —Ç—É—Ç -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>üé® –†–µ–¥–∞–∫—Ç–æ—Ä (–í—Å—ñ —Ñ—ñ–≥—É—Ä–∏):</label>
             <div id="pieceContainer" class="piece-container"></div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>–ú–∞—Å—à—Ç–∞–±: <span id="zoomDisplay">100%</span></label>
             <input type="range" id="zoomSlider" min="-3" max="2" step="0.01">
        </div>
        <div class="separator"></div>
        <div class="control-group">
            <label>üíæ –§–∞–π–ª –ø–æ–∑–∏—Ü—ñ—ó:</label>
            <div class="btn-row">
                <button class="action" onclick="game.saveGame()">üì• –ó–±–µ—Ä–µ–≥—Ç–∏ (.json)</button>
                <button class="classic" onclick="document.getElementById('fileInput').click()">üìÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏</button>
                <!-- –ü—Ä–∏—Ö–æ–≤–∞–Ω–∏–π —ñ–Ω–ø—É—Ç –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è -->
                <input type="file" id="fileInput" style="display:none" accept=".json" onchange="game.loadGame(this)">
            </div>
        </div>
        <div class="btn-row">
            <button onclick="game.centerBoard()">üè† –¶–µ–Ω—Ç—Ä</button>
            <button class="danger" onclick="game.clear()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç–∏</button>
        </div>

        <div class="info-panel">
            <span id="coord" style="font-weight:bold; margin-right: 10px">-</span>
            <span id="count"></span>
        </div>
    </div>

    <div id="debug">FPS: <span id="fps">60</span></div>

    <script>
        const PIECE_CATEGORIES = [
            { name: "–Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏", bg: "#fff", items: [{ s: '‚ùå', t: '–ì—É–º–∫–∞', c: 'eraser' }] },
            { name: "–ö–ª–∞—Å–∏–∫–∞ (–ë—ñ–ª—ñ)", bg: "#f0f0f0", items: [{s:'‚ôî',t:'–ö–æ—Ä–æ–ª—å'}, {s:'‚ôï',t:'–§–µ—Ä–∑—å'}, {s:'‚ôñ',t:'–¢—É—Ä–∞'}, {s:'‚ôó',t:'–°–ª–æ–Ω'}, {s:'‚ôò',t:'–ö—ñ–Ω—å'}, {s:'‚ôô',t:'–ü—ñ—à–∞–∫'}] },
            { name: "–ö–ª–∞—Å–∏–∫–∞ (–ß–æ—Ä–Ω—ñ)", bg: "#ddd", items: [{s:'‚ôö',t:'–ö–æ—Ä–æ–ª—å', cls:'black-piece', color:'b'}, {s:'‚ôõ',t:'–§–µ—Ä–∑—å', cls:'black-piece', color:'b'}, {s:'‚ôú',t:'–¢—É—Ä–∞', cls:'black-piece', color:'b'}, {s:'‚ôù',t:'–°–ª–æ–Ω', cls:'black-piece', color:'b'}, {s:'‚ôû',t:'–ö—ñ–Ω—å', cls:'black-piece', color:'b'}, {s:'‚ôü',t:'–ü—ñ—à–∞–∫', cls:'black-piece', color:'b'}] },
            { name: "–®–∞—à–∫–∏", bg: "#e0e0e0", items: [{s:'‚õÄ',t:'–ë—ñ–ª–∞ —à–∞—à–∫–∞', color:'w'}, {s:'‚õÅ',t:'–ë—ñ–ª–∞ –¥–∞–º–∫–∞', color:'w'}, {s:'‚õÇ',t:'–ß–æ—Ä–Ω–∞ —à–∞—à–∫–∞', color:'b', cls:'black-piece'}, {s:'‚õÉ',t:'–ß–æ—Ä–Ω–∞ –¥–∞–º–∫–∞', color:'b', cls:'black-piece'}] },
            { name: "Mega: –°–ª–∞–π–¥–µ—Ä–∏", bg: "#e8daef", items: [{s:'üöÄ',t:'–†–∞–∫–µ—Ç–∞'}, {s:'‚öì',t:'–Ø–∫—ñ—Ä'}, {s:'üèπ',t:'–õ—É–∫'}, {s:'üé£',t:'–í—É–¥–∫–∞'}, {s:'üßú',t:'–†—É—Å–∞–ª–∫–∞'}, {s:'‚ö°',t:'–ë–ª–∏—Å–∫–∞–≤–∫–∞'}, {s:'üî±',t:'–¢—Ä–∏–∑—É–±'}, {s:'ü¶Ø',t:'–¢—Ä–æ—Å—Ç–∏–Ω–∞'}, {s:'üïØÔ∏è',t:'–°–≤—ñ—á–∫–∞'}, {s:'üìº',t:'–¢–∞–Ω–∫'}, {s:'üìú',t:'–°—É–≤—ñ–π'}, {s:'üåä',t:'–¶—É–Ω–∞–º—ñ'}, {s:'üß¨',t:'–î–ù–ö'}, {s:'üó°Ô∏è',t:'–ú–µ—á'}] },
            { name: "Mega: –°—Ç—Ä–∏–±—É–Ω–∏ (–¢–≤–∞—Ä–∏–Ω–∏)", bg: "#d4e6f1", items: [{s:'üò∫',t:'–ö—ñ—Ç'}, {s:'üê∫',t:'–í–æ–≤–∫'}, {s:'ü¶ä',t:'–õ–∏—Å'}, {s:'üêó',t:'–ö–∞–±–∞–Ω'}, {s:'ü¶ç',t:'–ì–æ—Ä–∏–ª–∞'}, {s:'üêÉ',t:'–ë—É–π–≤–æ–ª'}, {s:'üêä',t:'–ö—Ä–æ–∫–æ–¥–∏–ª'}, {s:'üêå',t:'–†–∞–≤–ª–∏–∫'}, {s:'ü¶ë',t:'–ö–∞–ª—å–º–∞—Ä'}, {s:'üêô',t:'–í–æ—Å—å–º–∏–Ω—ñ–≥'}, {s:'üêù',t:'–ë–¥–∂–æ–ª–∞'}, {s:'ü¶ã',t:'–ú–µ—Ç–µ–ª–∏–∫'}, {s:'üê´',t:'–í–µ—Ä–±–ª—é–¥'}, {s:'ü¶ì',t:'–ó–µ–±—Ä–∞'}, {s:'ü¶í',t:'–ñ–∏—Ä–∞—Ñ–∞'}, {s:'üêï',t:'–ü–µ—Å'}, {s:'ü¶Ä',t:'–ö—Ä–∞–±'}, {s:'üêÜ',t:'–õ–µ–æ–ø–∞—Ä–¥'}, {s:'üêøÔ∏è',t:'–ë—ñ–ª–∫–∞'}, {s:'ü¶á',t:'–ö–∞–∂–∞–Ω'}, {s:'ü¶ó',t:'–ö–æ–Ω–∏–∫'}] },
            { name: "Mega: –ö–æ–º–±—ñ–Ω–æ–≤–∞–Ω—ñ & –†–æ–ª—ñ", bg: "#f9e79f", items: [{s:'üéé',t:'–Ü–º–ø–µ—Ä–∞—Ç—Ä–∏—Ü—è'}, {s:'üë∏',t:'–ü—Ä–∏–Ω—Ü–µ—Å–∞'}, {s:'üè∫',t:'–ê–º–∞–∑–æ–Ω–∫–∞'}, {s:'üëÆ',t:'–ü–æ–ª—ñ—Ü—ñ—è'}, {s:'ü§ñ',t:'–†–æ–±–æ—Ç'}, {s:'üõ∏',t:'–ù–õ–û'}, {s:'üèá',t:'–í–µ—Ä—à–Ω–∏–∫'}, {s:'üå™Ô∏è',t:'–¢–æ—Ä–Ω–∞–¥–æ'}, {s:'üßõ',t:'–í–∞–º–ø—ñ—Ä'}, {s:'üíÇ',t:'–ì–≤–∞—Ä–¥—ñ—î—Ü—å'}, {s:'üë∑',t:'–ë—É–¥—ñ–≤–µ–ª—å–Ω–∏–∫'}, {s:'üßû',t:'–î–∂–∏–Ω'}, {s:'üßö',t:'–§–µ—è'}, {s:'‚òÄÔ∏è',t:'–°–æ–Ω—Ü–µ'}, {s:'üßô',t:'–ú–∞–≥'}, {s:'üïµÔ∏è',t:'–®–ø–∏–≥—É–Ω'}, {s:'ü•ã',t:'–°–∞–º—É—Ä–∞–π'}, {s:'ü•∑',t:'–ù—ñ–Ω–¥–∑—è'}, {s:'üë®',t:'–ß–æ–ª–æ–≤—ñ–∫'}, {s:'ü§¥',t:'–ü—Ä–∏–Ω—Ü'}, {s:'üëº',t:'–ê–Ω–≥–µ–ª'}] },
            { name: "Mega: –ê—Ä—Å–µ–Ω–∞–ª & –ú–æ–Ω—Å—Ç—Ä–∏", bg: "#fadbd8", items: [{s:'üõ°Ô∏è',t:'–©–∏—Ç'}, {s:'üî™',t:'–ö–∏–Ω–¥–∂–∞–ª'}, {s:'üî•',t:'–í–æ–≥–æ–Ω—å'}, {s:'üíß',t:'–í–æ–¥–∞'}, {s:'‚ùÑÔ∏è',t:'–°–Ω—ñ–≥'}, {s:'üßü',t:'–ó–æ–º–±—ñ'}, {s:'ü™®',t:'–ö–∞–º—ñ–Ω—å'}, {s:'üß®',t:'–î–∏–Ω–∞–º—ñ—Ç'}, {s:'üí£',t:'–ë–æ–º–±–∞'}, {s:'‚öóÔ∏è',t:'–ó—ñ–ª–ª—è'}, {s:'üíç',t:'–ö—ñ–ª—å—Ü–µ'}, {s:'üîÆ',t:'–°—Ñ–µ—Ä–∞'}, {s:'ü¶Ç',t:'–°–∫–æ—Ä–ø—ñ–æ–Ω'}, {s:'üêç',t:'–ó–º—ñ—è'}, {s:'ü¶ñ',t:'–¢—ñ-–†–µ–∫—Å'}, {s:'ü¶à',t:'–ê–∫—É–ª–∞'}, {s:'üëæ',t:'–ß—É–∂–∏–π'}, {s:'üë∫',t:'–ì–æ–±–ª—ñ–Ω'}, {s:'üê≤',t:'–î—Ä–∞–∫–æ–Ω'}, {s:'ü¶Ñ',t:'–Ñ–¥–∏–Ω–æ—Ä—ñ–≥'}, {s:'ü¶Ö',t:'–ì—Ä–∏—Ñ–æ–Ω'}, {s:'üï∑Ô∏è',t:'–ü–∞–≤—É–∫'}, {s:'üê¢',t:'–ß–µ—Ä–µ–ø–∞—Ö–∞'}] },
            { name: "Mega: –ê–±—Å—Ç—Ä–∞–∫—Ü—ñ—è & –ü—Ä–∏—Ä–æ–¥–∞", bg: "#d5f5e3", items: [{s:'üåµ',t:'–ö–∞–∫—Ç—É—Å'}, {s:'üçÑ',t:'–ì—Ä–∏–±'}, {s:'üå≤',t:'–î–µ—Ä–µ–≤–æ'}, {s:'üçÅ',t:'–õ–∏—Å—Ç'}, {s:'üåã',t:'–í—É–ª–∫–∞–Ω'}, {s:'üå©Ô∏è',t:'–ì—Ä–æ–∑–∞'}, {s:'üß©',t:'–ü–∞–∑–ª'}, {s:'üé≤',t:'–ö—É–±–∏–∫'}, {s:'‚öõÔ∏è',t:'–ê—Ç–æ–º'}, {s:'üöú',t:'–¢—Ä–∞–∫—Ç–æ—Ä'}, {s:'‚öîÔ∏è',t:'–ú–µ—á—ñ'}, {s:'üêò',t:'–°–ª–æ–Ω'}, {s:'üåõ',t:'–ú—ñ—Å—è—Ü—å'}, {s:'‚≠ê',t:'–ó—ñ—Ä–∫–∞'}, {s:'ü™ê',t:'–ü–ª–∞–Ω–µ—Ç–∞'}, {s:'üåå',t:'–ì–∞–ª–∞–∫—Ç–∏–∫–∞'}] }
        ];
const megaDefs = {
            'üï∑Ô∏è': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide_jump', d:'knight'}] },
            'üöú': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1]]}] },
            '‚öîÔ∏è': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'üêò': { t: 'complex', comps: [{t:'step', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'üöÄ': { t: 'slide', dirs: [[0,-1]] },
            '‚öì': { t: 'slide', dirs: [[0,1]] },
            'üèπ': { t: 'slide', dirs: [[-1,-1],[1,-1]] },
            'üé£': { t: 'slide', dirs: [[-1,1],[1,1]] },
            'üßú': { t: 'slide', dirs: [[1,0],[-1,0]] },
            '‚ö°': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'ü¶Ø': { t: 'slide', dirs: [[1,1],[-1,1],[1,-1],[-1,-1]], max: 2 },
            'üïØÔ∏è': { t: 'slide', dirs: [[1,0],[-1,0],[0,1],[0,-1]], max: 3 },
            'üî±': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'üåä': { t: 'slide', dirs: [[0,-1]] },
            'üìú': { t: 'slide', dirs: [[0,1]] },
            'üß¨': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'üó°Ô∏è': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'üåµ': { t: 'step', dirs: 'king' },
            'üçÑ': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'üå≤': { t: 'step', dirs: [[0,1],[0,-1]] },
            'üçÅ': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'üåã': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'üå©Ô∏è': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            '‚ùÑÔ∏è': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'üî•': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]], mul:2}] },
            'üíß': { t: 'complex', comps: [{t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]], mul:2}] },
            'ü™®': { t: 'none' },
            'üò∫': { t: 'jump', dirs: [[1,-2],[-1,-2]] },
            'üê∫': { t: 'jump', dirs: 'knight' },
            'ü¶ä': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'üêó': { t: 'jump', dirs: [[0,-2]] },
            'ü¶ç': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'üêÉ': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'üêä': { t: 'jump', dirs: [[3,3],[3,-3],[-3,3],[-3,-3]] },
            'üêå': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'ü¶ë': { t: 'jump', dirs: [[4,0],[-4,0],[0,4],[0,-4]] },
            'üêô': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[1,2],[1,-2],[-1,2],[-1,-2]]}] },
            'üêù': { t: 'complex', comps: [{t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ü¶ã': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'üê¢': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'üêï': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'üêøÔ∏è': { t: 'jump', dirs: 'knight' },
            'üêÜ': { t: 'slide', dirs: 'bishop' },
            'ü¶ì': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'üê´': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'ü¶í': { t: 'jump', dirs: [[4,1],[4,-1],[-4,1],[-4,-1],[1,4],[1,-4],[-1,4],[-1,-4]] },
            'ü¶ó': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0],[2,2],[2,-2],[-2,2],[-2,-2]] },
            'ü¶á': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ü¶Ä': { t: 'step', dirs: [[0,1],[0,-1],[2,0],[-2,0]] },
            'üß®': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ü¶Ç': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}] },
            'üêç': { t: 'complex', comps: [{t:'step', d:[[0,1],[0,-1],[1,0],[-1,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ü¶ñ': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ü¶à': { t: 'complex', comps: [{t:'slide', d:[[1,-1],[-1,-1]]}, {t:'slide', d:[[0,1]]}] },
            'üëæ': { t: 'jump', dirs: [[1,3],[1,-3],[-1,3],[-1,-3],[3,1],[3,-1],[-3,1],[-3,-1]] },
            'üßü': { t: 'step', dirs: 'king' },
            'üë∫': { t: 'slide', dirs: 'bishop' },
            'üêª': { t: 'step', dirs: 'king' },
            'üîÆ': { t: 'jump', dirs: [[2,2],[2,-2],[-2,2],[-2,-2]] },
            'üíç': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,3],[3,-3],[-3,3],[-3,-3]]}] },
            '‚öóÔ∏è': { t: 'jump', dirs: [[1,4],[1,-4],[-1,4],[-1,-4],[4,1],[4,-1],[-4,1],[-4,-1]] },
            'üí£': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0]] },
            'üß©': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'üé≤': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[-2,-2]]}, {t:'jump', d:[[3,3],[-3,-3]]}] },
            '‚öõÔ∏è': { t: 'jump', dirs: [[2,2],[-2,-2],[2,-2],[-2,2], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'üõ°Ô∏è': { t: 'step', dirs: [[1,0],[-1,0],[0,1],[0,-1]] },
            'üî™': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'üìº': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ü§ñ': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'slide', d:[[1,1],[-1,1]]}] },
            'üõ∏': { t: 'complex', comps: [{t:'slide', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'üåõ': { t: 'jump', dirs: [[2,3],[2,-3],[-2,3],[-2,-3],[3,2],[3,-2],[-3,2],[-3,-2]] },
            '‚≠ê': { t: 'jump', dirs: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2], [2,0],[-2,0],[0,2],[0,-2], [2,2],[-2,-2],[2,-2],[-2,2]] },
            'ü™ê': { t: 'jump', dirs: [[0,3],[0,-3],[3,0],[-3,0]] },
            'üåå': { t: 'jump', dirs: [[3,0],[-3,0],[0,3],[0,-3], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'üë®': { t: 'step', dirs: 'king' },
            'üèá': { t: 'complex', comps: [{t:'slide_jump', d:[[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]]}] },
            'üéé': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'üë∏': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'üè∫': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] },
            'üëÆ': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'üå™Ô∏è': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'üßõ': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:[[3,0],[-3,0],[0,3],[0,-3]]}] },
            'üíÇ': { t: 'step', dirs: [[0,-1],[1,0],[-1,0],[1,-1],[-1,-1],[1,1],[-1,1]] },
            'üë∑': { t: 'slide', dirs: 'rook', max: 2 },
            'üßû': { t: 'slide', dirs: 'queen', max: 3 },
            'üßö': { t: 'slide', dirs: 'bishop', max: 2 },
            '‚òÄÔ∏è': { t: 'slide', dirs: 'queen', max: 2 },
            'üßô': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]]}] },
            'üïµÔ∏è': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ü•ã': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[1,-1],[-1,1]]}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'ü•∑': { t: 'jump', dirs: [[1,1],[1,-1],[-1,1],[-1,-1], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ü§¥': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'rook'}] },
            'üëº': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'bishop'}] },
            'ü¶Ñ': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ü¶Ö': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'üê≤': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] }
        };

        const CHESS_SVGS = {
            'w_‚ôî': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#101010" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'w_‚ôï': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#101010" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'w_‚ôó': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#101010" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'w_‚ôò': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#ffffff; stroke:#000000;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#ffffff; stroke:#000000;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#000000; stroke:#000000;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#000000; stroke:#000000;"/></g>`,
            'w_‚ôñ': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#101010" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'w_‚ôô': `<g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`,
            'b_‚ôö': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#f9f9f9" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'b_‚ôõ': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#f9f9f9" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'b_‚ôú': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#f9f9f9" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'b_‚ôù': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#f9f9f9" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'b_‚ôû': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#000000; stroke:#ffffff;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#000000; stroke:#ffffff;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#ffffff; stroke:#ffffff;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#ffffff; stroke:#ffffff;"/></g>`,
            'b_‚ôü': `<g fill="#000" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`,
            // --- –ù–û–í–Ü –®–ê–®–ö–ò (LIDRAUGHTS STYLE) ---
    'w_checker': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#eee" stroke="#000" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#fff" stroke="#000" stroke-width="1.5" />
        </g>`,
    'w_damka': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#eee" stroke="#000" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#fff" stroke="#000" stroke-width="1.5" />
            <path d="M 12,23 L 12,17 L 16.5,20 L 22.5,13 L 28.5,20 L 33,17 L 33,23 Z" fill="#DAA520" stroke="#B8860B" stroke-width="1" />
        </g>`,
    'b_checker': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#333" stroke="#ccc" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#111" stroke="#ccc" stroke-width="1.5" />
        </g>`,
    'b_damka': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#333" stroke="#ccc" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#111" stroke="#ccc" stroke-width="1.5" />
            <path d="M 12,23 L 12,17 L 16.5,20 L 22.5,13 L 28.5,20 L 33,17 L 33,23 Z" fill="#DAA520" stroke="#B8860B" stroke-width="1" />
        </g>`

        };

        const CLASSIC_MAP = {
            '‚ôî':'w_‚ôî', '‚ôï':'w_‚ôï', '‚ôñ':'w_‚ôñ', '‚ôó':'w_‚ôó', '‚ôò':'w_‚ôò', '‚ôô':'w_‚ôô',
            '‚ôö':'b_‚ôö', '‚ôõ':'b_‚ôõ', '‚ôú':'b_‚ôú', '‚ôù':'b_‚ôù', '‚ôû':'b_‚ôû', '‚ôü':'b_‚ôü',

            // –ù–æ–≤—ñ –ø—Ä–∏–≤'—è–∑–∫–∏ –¥–ª—è —à–∞—à–æ–∫
    '‚õÄ': 'w_checker', // –ë—ñ–ª–∞ —à–∞—à–∫–∞
    '‚õÅ': 'w_damka',   // –ë—ñ–ª–∞ –¥–∞–º–∫–∞
    '‚õÇ': 'b_checker', // –ß–æ—Ä–Ω–∞ —à–∞—à–∫–∞
    '‚õÉ': 'b_damka'    // –ß–æ—Ä–Ω–∞ –¥–∞–º–∫–∞

        };
        const DIRS = {
            rook: [[0,1],[0,-1],[1,0],[-1,0]],
            bishop: [[1,1],[1,-1],[-1,1],[-1,-1]],
            queen: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            knight: [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]],
            king: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
        };

        const GRID_VOID = -999;

        class SmoothChess {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                this.boardSize = 32;
                this.cellSize = 60;

                this.camera = { x: 0, y: 0, zoom: 1 };
                
                // –î–æ–¥–∞—î–º–æ targetCamera –¥–ª—è —Å—Ç–∞–±—ñ–ª—ñ–∑–∞—Ü—ñ—ó
                this.targetCamera = { x: 0, y: 0, zoom: 1 }; 
                
                this.lerpFactor = 0.1;
                this.minZoom = 0.000001;
                this.maxZoom = 5.0;

                this.mouse = { x: 0, y: 0 };
                this.isDragging = false;
                this.isDraggingPiece = false;
                this.draggedPiece = null;
                this.lastMouse = { x: 0, y: 0 };
                this.isPainting = false;
                this.isGenerating = false;

                this.customArrows = []; // –ú–∞—Å–∏–≤ —Å—Ç—Ä—ñ–ª–æ–∫
                this.rmbStart = null;   // –¢–æ—á–∫–∞ –ø–æ—á–∞—Ç–∫—É –º–∞–ª—é–≤–∞–Ω–Ω—è
                // --- PROMOTION STATE ---
                this.promotionPending = null;

                // --- KEYBOARD ---
                this.keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

                // Storage for MODIFIED pieces only.
                this.grid = new Map();

                // History for UNDO
                this.moveHistory = [];

                this.virtualGen = null;
                this.virtualProps = { percent: 25, mix: 0 };

                this.generationSeed = 0;

                this.palette = [];
                this.paletteMap = new Map();
                this.pieceCount = 0;
                this.kingPos = { w: null, b: null };

                this.curSymbol = '‚ôî';
                this.curColor = 'w';

                this.rulesEnabled = true;
                this.turnModeEnabled = true;
                this.currentTurn = 'w';
                this.gameOver = false;
                this.multiJumpSource = null;

                this.highlightedMoves = [];
                this.kingsInCheck = { w: null, b: null };

                this.colors = {
                    light: '#eeeed2',
                    dark: 'rgba(80, 120, 60, 0.6)',
                    border: '#3a4a2b',
                    whiteP: '#ffffff',
                    blackP: '#000000',
                    neutralP: '#ffcc00',
                    highlight: 'rgba(0, 255, 0, 0.5)',
                    checkHighlight: 'rgba(255, 0, 0, 0.6)',
                    mateHighlight: 'rgba(75, 0, 130, 0.9)'
                };
                this.colors.void = this.colors.light;

                this.checkersSymbols = new Set(['‚õÄ', '‚õÅ', '‚õÇ', '‚õÉ']);
                this.spriteCache = new Map();
                this.lowResCache = new Map();
                this.spriteSize = 100;

                this.initUI();
                this.init();
                this.updateTurnIndicator();
            }
            // –ù–æ–≤—ã–π –º–µ—Ç–æ–¥: –ù–∞—Ö–æ–¥–∏—Ç –∫–æ–Ω–µ—Ü –ø—É—Ç–∏, –ø–µ—Ä–µ–ø—Ä—ã–≥–∏–≤–∞—è —á–µ—Ä–µ–∑ –ø—É—Å—Ç–æ—Ç—É
            // –ì—ñ–±—Ä–∏–¥–Ω–∏–π –ø–æ—à—É–∫: –¢–æ—á–Ω–∏–π –ø–æ–±–ª–∏–∑—É, —à–≤–∏–¥–∫–∏–π –¥–∞–ª–µ–∫–æ
            findRayEnd(cx, cy, dx, dy, maxSteps) {
                let x = cx;
                let y = cy;
                let steps = 0;
                const limit = maxSteps || this.boardSize;
                
                // 1. –ß–ï–°–ù–ò–ô –°–ö–ê–ù–ï–† (–ë–ª–∏–∂–Ω—è –¥–∏—Å—Ç–∞–Ω—Ü—ñ—è)
                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø–µ—Ä—à—ñ 100 –∫–ª—ñ—Ç–∏–Ω–æ–∫ —Ä–µ–∞–ª—å–Ω–æ. –¶–µ –≥–∞—Ä–∞–Ω—Ç—É—î, —â–æ –Ω–∞ –∑–≤–∏—á–∞–π–Ω—ñ–π –¥–æ—à—Ü—ñ
                // –∞–±–æ –ø—Ä–∏ –∑–≤–∏—á–∞–π–Ω–æ–º—É –∑—É–º—ñ –º–∏ –Ω—ñ–∫–æ–ª–∏ –Ω–µ –ø—Ä–æ–ø—É—Å—Ç–∏–º–æ —Ñ—ñ–≥—É—Ä—É.
                // 100 –æ–ø–µ—Ä–∞—Ü—ñ–π –¥–ª—è JS ‚Äî —Ü–µ –º–∏—Ç—Ç—î–≤–æ.
                const SCAN_LIMIT = 100;

                while (steps < limit && steps < SCAN_LIMIT) {
                    steps++;
                    x += dx; y += dy;

                    // –í–∏—Ö—ñ–¥ –∑–∞ –º–µ–∂—ñ –¥–æ—à–∫–∏
                    if (x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize) {
                        return { x: x - dx, y: y - dy, hit: false, edge: true };
                    }

                    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ñ—ñ–≥—É—Ä–∏ (Grid + Virtual)
                    const target = this.getPiece(x, y);
                    if (target) {
                        const myPiece = this.getPiece(cx, cy);
                        const isAlly = myPiece && target.c === myPiece.c;
                        return { x, y, hit: true, ally: isAlly };
                    }
                }

                // 2. –ì–Ü–ü–ï–†-–°–¢–†–ò–ë–û–ö (–î–∞–ª–µ–∫–∞ –¥–∏—Å—Ç–∞–Ω—Ü—ñ—è)
                // –Ø–∫—â–æ –º–∏ –ø—Ä–æ–π—à–ª–∏ 100 –∫–ª—ñ—Ç–∏–Ω–æ–∫ —ñ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏, –∑–Ω–∞—á–∏—Ç—å –º–∏ –≤ "–∫–æ—Å–º–æ—Å—ñ".
                // –¢–µ–ø–µ—Ä –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –º–∞—Ç–µ–º–∞—Ç–∏–∫—É, —â–æ–± –∑–Ω–∞–π—Ç–∏ –∫—Ä–∞–π –¥–æ—à–∫–∏ –∞–±–æ –Ω–∞—Å—Ç—É–ø–Ω—É —Ñ—ñ–≥—É—Ä—É –∑ Grid.
                
                // –†–∞—Ö—É—î–º–æ —Å–∫—ñ–ª—å–∫–∏ –ª–∏—à–∏–ª–æ—Å—å –¥–æ –∫—Ä–∞—é
                let distToEdge = this.boardSize;
                if (dx > 0) distToEdge = this.boardSize - 1 - x;
                else if (dx < 0) distToEdge = x;
                if (dy > 0) distToEdge = Math.min(distToEdge, this.boardSize - 1 - y);
                else if (dy < 0) distToEdge = Math.min(distToEdge, y);

                // –û–±–º–µ–∂—É—î–º–æ –ª—ñ–º—ñ—Ç–æ–º —Ö–æ–¥—É (—è–∫—â–æ —î)
                let jumpDist = distToEdge;
                if (maxSteps) jumpDist = Math.min(jumpDist, limit - steps);

                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –Ω–∞ —à–ª—è—Ö—É —Ä–µ–∞–ª—å–Ω—ñ —Ñ—ñ–≥—É—Ä–∏ (–∑ Grid), —â–æ–± –Ω–µ –ø–µ—Ä–µ—Å—Ç—Ä–∏–±–Ω—É—Ç–∏ —ó—Ö
                let bestGridDist = jumpDist;
                let hitGrid = false;

                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const comma = key.indexOf(',');
                    const px = parseInt(key.substring(0, comma));
                    const py = parseInt(key.substring(comma + 1));

                    // –í–µ–∫—Ç–æ—Ä –≤—ñ–¥ –ø–æ—Ç–æ—á–Ω–æ—ó —Ç–æ—á–∫–∏ —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è (x, y)
                    const vx = px - x;
                    const vy = py - y;

                    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞–ø—Ä—è–º–∫—É
                    if (Math.sign(vx) !== dx && dx !== 0) continue;
                    if (Math.sign(vy) !== dy && dy !== 0) continue;
                    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ
                    if (vx * dy - vy * dx !== 0) continue;

                    const d = Math.max(Math.abs(vx), Math.abs(vy));
                    if (d < bestGridDist && d > 0) {
                        bestGridDist = d;
                        hitGrid = true;
                    }
                }

                // –¢–∞–∫–æ–∂ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å—Ç—ñ–Ω—É –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–æ—ó –∞—Ä–º—ñ—ó (—è–∫—â–æ –ª–µ—Ç–∏–º–æ –≤ –Ω–µ—ó)
                if (this.virtualGen) {
                    let rows = 0;
                    if (this.virtualGen === 'chess960') rows = 2;
                    else {
                        rows = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                        if (this.virtualGen !== 'checkers' && rows < 2) rows = 2;
                    }
                    const botLimit = this.boardSize - rows; // –ü–æ—á–∞—Ç–æ–∫ –Ω–∏–∂–Ω—å–æ—ó –∞—Ä–º—ñ—ó

                    // –Ø–∫—â–æ –ª–µ—Ç–∏–º–æ –≤–Ω–∏–∑ —ñ —â–µ –Ω–µ –¥—ñ–π—à–ª–∏ –¥–æ –Ω–∏–∂–Ω—å–æ—ó –∞—Ä–º—ñ—ó
                    if (dy > 0 && y < botLimit) {
                        const distToArmy = botLimit - y;
                        if (distToArmy < bestGridDist) {
                            bestGridDist = distToArmy;
                            hitGrid = true; // –í–≤–∞–∂–∞—î–º–æ —Ü–µ –≤–ª—É—á–∞–Ω–Ω—è–º
                        }
                    }
                    // –î–ª—è –≤–µ—Ä—Ö–Ω—å–æ—ó –∞—Ä–º—ñ—ó –Ω–µ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, –±–æ –º–∏ –ª–µ—Ç–∏–º–æ –≤—ñ–¥ –Ω–µ—ó (y –∑–±—ñ–ª—å—à—É—î—Ç—å—Å—è –∞–±–æ –º–∏ –≤–∂–µ –ø—Ä–æ–π—à–ª–∏)
                    // (–°–ø—Ä–æ—â–µ–Ω–Ω—è –¥–ª—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ)
                }

                // –°—Ç—Ä–∏–±–∞—î–º–æ
                const finalX = x + dx * bestGridDist;
                const finalY = y + dy * bestGridDist;

                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ñ—ñ–Ω–∞–ª—å–Ω—É —Ç–æ—á–∫—É (—á–∏ —Ü–µ –≤–æ—Ä–æ–≥)
                const finalTarget = this.getPiece(finalX, finalY);
                const startPiece = this.getPiece(cx, cy);
                const finalAlly = finalTarget && startPiece && finalTarget.c === startPiece.c;

                return { x: finalX, y: finalY, hit: hitGrid || !!finalTarget, ally: finalAlly };
            }

            calculateHighlights(piece, cx, cy) {
                if (!this.rulesEnabled) return;
                
                this.highlightedMoves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // --- 1. –°–ª–∞–π–¥–µ—Ä–∏ (–¢—É—Ä–∞, –°–ª–æ–Ω, –§–µ—Ä–∑—å) ---
                const castRay = (dx, dy, maxLimit = this.boardSize) => {
                    const end = this.findRayEnd(cx, cy, dx, dy, maxLimit);
                    
                    // –î–æ–≤–∂–∏–Ω–∞ –ø—Ä–æ–º–µ–Ω—è (–º–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∞ –¥–∏—Å—Ç–∞–Ω—Ü—ñ—è)
                    let dist = Math.max(Math.abs(end.x - cx), Math.abs(end.y - cy));

                    // –Ø–∫—â–æ –≤–ª—É—á–∏–ª–∏, —Å–∫–æ—Ä–æ—á—É—î–º–æ –ª—ñ–Ω—ñ—é –Ω–∞ 1, —â–æ–± –Ω–µ –º–∞–ª—é–≤–∞—Ç–∏ –ù–ê —Ñ—ñ–≥—É—Ä—ñ
                    if (end.hit || end.ally) dist--;

                    if (dist > 0) {
                        this.highlightedMoves.push({
                            type: 'ray', cx: cx, cy: cy, dx: dx, dy: dy, len: dist
                        });
                    }

                    // –ß–µ—Ä–≤–æ–Ω–∞ –∫—Ä–∞–ø–∫–∞ –¥–ª—è –∞—Ç–∞–∫–∏
                    if (end.hit && !end.ally) {
                        this.highlightedMoves.push({ type: 'point', c: end.x, r: end.y, capture: true });
                    }
                };

                // --- 2. –°—Ç—Ä–∏–±—É–Ω–∏ (–ö—ñ–Ω—å, –ö–æ—Ä–æ–ª—å) ---
                // ... (–ø–æ—á–∞—Ç–æ–∫ –º–µ—Ç–æ–¥—É calculateHighlights) ...

                // --- 2. –°—Ç—Ä–∏–±—É–Ω–∏ (–ö—ñ–Ω—å, –ö–æ—Ä–æ–ª—å) ---
                const checkJump = (dx, dy) => {
                    const tx = cx + dx; const ty = cy + dy;
                    if (tx >= 0 && tx < this.boardSize && ty >= 0 && ty < this.boardSize) {
                        const target = this.getPiece(tx, ty);
                        if (!target) {
                             this.highlightedMoves.push({ type: 'point', c: tx, r: ty });
                        } else if (target.c !== piece.c) {
                             this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: true });
                        }
                    }
                };

                // ... (–∫–æ–¥ –¥–ª—è —à–∞—à–æ–∫ —ñ —Å–ª–∞–π–¥–µ—Ä—ñ–≤) ...
                if (['‚ôò','‚ôû'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => checkJump(d[0], d[1])); }
                
                // --- –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø –î–õ–Ø –ö–û–†–û–õ–Ø (–ü—Ä–∏–±–∏—Ä–∞—î–º–æ checkJump, –¥–æ–¥–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –∞—Ç–∞–∫–∏) ---
                if (['‚ôî','‚ôö'].includes(type)) { 
                    for(let i=-1; i<=1; i++) {
                        for(let j=-1; j<=1; j++) {
                            if(i===0 && j===0) continue;
                            const tx = cx + i; 
                            const ty = cy + j;
                            
                            if (tx >= 0 && tx < this.boardSize && ty >= 0 && ty < this.boardSize) {
                                const target = this.getPiece(tx, ty);
                                if (!target || target.c !== piece.c) {
                                    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ö—ñ–¥ –±–µ–∑–ø–µ—á–Ω–∏–π (–Ω–µ –ø—ñ–¥ —à–∞—Ö)
                                    if (this.rulesEnabled) {
                                        if (this.simulateMoveAndCheckSafety(piece, cx, cy, tx, ty)) {
                                            this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: !!target });
                                        }
                                    } else {
                                        this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: !!target });
                                    }
                                }
                            }
                        }
                    }
                }
                // -----------------------------------------------------------------------------

               
                if (megaDefs[type]) {
                     const def = megaDefs[type];
                     const FLIP_Y_LIST = ['üöÄ','‚öì','üèπ','üé£','üò∫','üêó','üåä','üó°Ô∏è','üìú'];
                     const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0], dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            if (moveType === 'slide' || moveType === 'slide_jump') castRay(dirX, dirY, limit);
                            else { let mul = comp.mul || 1; checkJump(dirX * mul, dirY * mul); }
                        }
                     };
                     if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }

                // --- –ü–Ü–®–ê–ö–ò (–°—É–≤–æ—Ä–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞) ---
                if (['‚ôô','‚ôü'].includes(type)) {
                    const dir = isWhite ? -1 : 1;
                    
                    // 1. –í–ø–µ—Ä–µ–¥ –Ω–∞ 1 (—è–∫—â–æ –ø—É—Å—Ç–æ)
                    const fwd1 = this.getPiece(cx, cy + dir);
                    if (!fwd1) {
                        this.highlightedMoves.push({ type: 'point', c: cx, r: cy + dir });
                        
                        // 2. –í–ø–µ—Ä–µ–¥ –Ω–∞ 2 (—è–∫—â–æ –Ω–µ —Ö–æ–¥–∏–≤ —ñ –ø—É—Å—Ç–æ)
                        if (!piece.hasMoved) {
                            const fwd2 = this.getPiece(cx, cy + dir * 2);
                            if (!fwd2) {
                                this.highlightedMoves.push({ type: 'point', c: cx, r: cy + dir * 2 });
                            }
                        }
                    }

                    // 3. –ê—Ç–∞–∫–∏ (—è–∫—â–æ –≤–æ—Ä–æ–≥)
                    [1, -1].forEach(dx => {
                        const tx = cx + dx; const ty = cy + dir;
                        const t = this.getPiece(tx, ty);
                        if (t && t.c !== piece.c) {
                            this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: true });
                        }
                    });
                }
            }
            
            initUI() {
                const container = document.getElementById('pieceContainer');
                container.innerHTML = '';

                PIECE_CATEGORIES.forEach(cat => {
                    const block = document.createElement('div');
                    block.className = 'category-block';
                    if(cat.bg) block.style.backgroundColor = cat.bg;
                    const header = document.createElement('div');
                    header.className = 'grid-header';
                    header.innerText = cat.name;
                    block.appendChild(header);
                    const grid = document.createElement('div');
                    grid.className = 'piece-grid';

                    cat.items.forEach(item => {
                        const btn = document.createElement('button');
                        btn.className = `piece-btn ${item.cls || ''}`;
                        if(item.s === '‚ùå') btn.classList.add('eraser');

                        btn.innerText = item.s;
                        btn.title = item.t;
                        btn.dataset.s = item.s;
                        btn.dataset.c = item.color || 'w';
                        btn.addEventListener('click', () => {
                            document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            this.curSymbol = btn.dataset.s;
                            this.curColor = btn.dataset.c;
                        });
                        if(item.s === '‚ôî' && item.color !== 'b') btn.classList.add('selected');
                        grid.appendChild(btn);
                    });
                    block.appendChild(grid);
                    container.appendChild(block);
                });
            }

            init() {
                this.setSize(32);
                this.resize();
                window.addEventListener('resize', () => { this.resize(); });
                this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
                this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
                window.addEventListener('mousemove', e => this.onMouseMove(e));
                window.addEventListener('mouseup', e => this.onMouseUp(e));
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());

                window.addEventListener('keydown', e => {
                    if (e.key === 'Delete') {
                        this.undoMove();
                    } else {
                        this.onKeyDown(e);
                        if(this.keys.hasOwnProperty(e.code)) {
                            this.keys[e.code] = true;
                            e.preventDefault();
                        }
                    }
                });
                window.addEventListener('keyup', e => {
                    if(this.keys.hasOwnProperty(e.code)) this.keys[e.code] = false;
                });

                document.getElementById('boardSize').addEventListener('change', e => this.setSize(e.target.value));
                document.getElementById('zoomSlider').addEventListener('input', e => {
                    this.targetZoom = Math.pow(10, parseFloat(e.target.value));
                });
                document.getElementById('fantasyMix').addEventListener('input', (e) => {
                    document.getElementById('fantasyPercentDisplay').innerText = e.target.value + '%';
                });
                document.getElementById('turnIndicator').addEventListener('click', () => this.toggleTurnColor());

                this.lastTime = performance.now();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.centerBoard();
            }

            getPaletteId(s, c) {
                const key = s + c;
                if (!this.paletteMap.has(key)) {
                    this.palette.push({ s, c });
                    this.paletteMap.set(key, this.palette.length);
                }
                return this.paletteMap.get(key);
            }

            getKey(c, r) {
                return c + "," + r;
            }

            getCoordString(c, r) {
                let label = "";
                let index = c + 1;
                while (index > 0) {
                    let rem = (index - 1) % 26;
                    label = String.fromCharCode(97 + rem) + label;
                    index = Math.floor((index - 1) / 26);
                }
                return label + (this.boardSize - r);
            }

            addLogToUI(pieceIcon, startCoord, endCoord, isCapture) {
                const list = document.getElementById('logList');
                // Remove default placeholder if exists
                if (list.children.length === 1 && list.children[0].innerText === '–•–æ–¥—ñ–≤ —â–µ –Ω–µ–º–∞—î') {
                    list.innerHTML = '';
                }

                const div = document.createElement('div');
                div.className = 'log-entry';

                const moveText = `<span class="move">${pieceIcon}</span> ${startCoord} ‚Üí ${endCoord}`;
                const capText = isCapture ? `<span class="capture">‚öîÔ∏è</span>` : '';

                div.innerHTML = `${moveText} ${capText}`;
                list.prepend(div); // Newest first
            }

            removeLastLogEntry() {
                const list = document.getElementById('logList');
                if (list.children.length > 0) {
                    list.removeChild(list.firstElementChild);
                }
                if (list.children.length === 0) {
                    list.innerHTML = '<div class="log-entry" style="color:#999; justify-content:center;">–•–æ–¥—ñ–≤ —â–µ –Ω–µ–º–∞—î</div>';
                }
            }

            setSize(n) {
                // –ü—Ä–∏–±–∏—Ä–∞—î–º–æ –≤–µ—Ä—Ö–Ω—î –æ–±–º–µ–∂–µ–Ω–Ω—è. 
                // –ó–∞–ª–∏—à–∞—î–º–æ –ª–∏—à–µ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–µ (2), —â–æ–± –Ω–µ –∑–ª–∞–º–∞—Ç–∏ –≥—Ä—É –≤—ñ–¥'—î–º–Ω–∏–º–∏ —á–∏—Å–ª–∞–º–∏.
                this.boardSize = Math.max(2, parseInt(n) || 32);
                
                // –û–Ω–æ–≤–ª—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –≤ –ø–æ–ª—ñ –≤–≤–æ–¥—É
                document.getElementById('boardSize').value = this.boardSize;

                this.grid.clear();
                this.moveHistory = [];
                this.virtualGen = null;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';

                this.resetGame();
                this.centerBoard();
            }

            centerBoard() {
                const boardPx = this.boardSize * this.cellSize;
                const screenW = this.canvas.width;
                const screenH = this.canvas.height;
                
                const fitScaleX = screenW / boardPx;
                const fitScaleY = screenH / boardPx;
                const fitZoom = Math.min(fitScaleX, fitScaleY);

                this.minZoom = fitZoom * 0.8; 
                if (this.minZoom > this.maxZoom) this.minZoom = this.maxZoom / 2;

                const startZoom = fitZoom * 0.95;
                
                // –¶–µ–Ω—Ç—Ä—É—î–º–æ
                const startX = (screenW - boardPx * startZoom) / 2;
                const startY = (screenH - boardPx * startZoom) / 2;

                // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –º–∏—Ç—Ç—î–≤–æ
                this.camera.x = startX;
                this.camera.y = startY;
                this.camera.zoom = startZoom;

                // –í–ê–ñ–õ–ò–í–û: –û–Ω–æ–≤–ª—é—î–º–æ —Ç–∞–∫–æ–∂ —Ü—ñ–ª—ñ
                this.targetCamera.x = startX;
                this.targetCamera.y = startY;
                this.targetCamera.zoom = startZoom;

                const slider = document.getElementById('zoomSlider');
                slider.min = Math.log10(this.minZoom);
                slider.value = Math.log10(startZoom);
            }

            clampCamera() {
                // –í–Ü–õ–¨–ù–ï –ü–ï–†–ï–ú–Ü–©–ï–ù–ù–Ø –ó –ú–ï–ñ–ê–ú–ò (–ê–ù–¢–ò-–ü–£–°–¢–û–¢–ê)
                
                const boardPx = this.boardSize * this.cellSize * this.camera.zoom;
                const screenW = this.canvas.width;
                const screenH = this.canvas.height;

                // "–°—Ç—Ä–∞—Ö—É–≤–∞–ª—å–Ω–∏–π —Ç—Ä–æ—Å":
                // –ú–∏ —Ö–æ—á–µ–º–æ, —â–æ–± —Ö–æ—á–∞ –± 150 –ø—ñ–∫—Å–µ–ª—ñ–≤ –¥–æ—à–∫–∏ (–∞–±–æ –ø–æ–ª–æ–≤–∏–Ω–∞ —ó—ó —Ä–æ–∑–º—ñ—Ä—É, —è–∫—â–æ –≤–æ–Ω–∞ –¥—É–∂–µ –º–∞–ª–∞)
                // –∑–∞–≤–∂–¥–∏ –∑–∞–ª–∏—à–∞–ª–∏—Å—è –≤–∏–¥–∏–º–∏–º–∏ –Ω–∞ –µ–∫—Ä–∞–Ω—ñ.
                const safeZone = Math.min(150, boardPx / 2);

                // –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–µ–∂:
                // 1. Min X: –ü—Ä–∞–≤–∏–π –∫—Ä–∞–π –¥–æ—à–∫–∏ –Ω–µ –º–æ–∂–µ –ø—ñ—Ç–∏ –∑–∞ –ª—ñ–≤–∏–π –∫—Ä–∞–π –µ–∫—Ä–∞–Ω—É (–∑–∞–ª–∏—à–∞—î–º–æ safeZone)
                //    –§–æ—Ä–º—É–ª–∞: camera.x + boardPx >= safeZone  =>  camera.x >= safeZone - boardPx
                const minX = safeZone - boardPx;

                // 2. Max X: –õ—ñ–≤–∏–π –∫—Ä–∞–π –¥–æ—à–∫–∏ –Ω–µ –º–æ–∂–µ –ø—ñ—Ç–∏ –∑–∞ –ø—Ä–∞–≤–∏–π –∫—Ä–∞–π –µ–∫—Ä–∞–Ω—É
                //    –§–æ—Ä–º—É–ª–∞: camera.x <= screenW - safeZone
                const maxX = screenW - safeZone;

                // 3. –¢–µ —Å–∞–º–µ –¥–ª—è Y (–í–µ—Ä—Ç–∏–∫–∞–ª—å)
                const minY = safeZone - boardPx;
                const maxY = screenH - safeZone;

                // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –ª—ñ–º—ñ—Ç–∏ –¥–æ –¶–Ü–õ–Ü (–¥–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó)
                if (this.targetCamera.x < minX) this.targetCamera.x = minX;
                if (this.targetCamera.x > maxX) this.targetCamera.x = maxX;
                if (this.targetCamera.y < minY) this.targetCamera.y = minY;
                if (this.targetCamera.y > maxY) this.targetCamera.y = maxY;

                // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –ª—ñ–º—ñ—Ç–∏ –¥–æ –ü–û–¢–û–ß–ù–û–á –∫–∞–º–µ—Ä–∏ (–¥–ª—è –º–∏—Ç—Ç—î–≤–æ—ó —Ä–µ–∞–∫—Ü—ñ—ó –º–∏—à–∫–∏)
                if (this.camera.x < minX) this.camera.x = minX;
                if (this.camera.x > maxX) this.camera.x = maxX;
                if (this.camera.y < minY) this.camera.y = minY;
                if (this.camera.y > maxY) this.camera.y = maxY;
            }
            onWheel(e) {
                if (this.promotionPending) return;
                e.preventDefault();

                // 1. –î–µ –º–∏—à–∫–∞ –∑–∞—Ä–∞–∑ (–Ω–∞ –µ–∫—Ä–∞–Ω—ñ)
                const mx = e.clientX;
                const my = e.clientY;

                // 2. –î–µ –º–∏—à–∫–∞ —É "–°–≤—ñ—Ç—ñ" (–Ω–∞ –¥–æ—à—Ü—ñ) –∑ –ü–û–¢–û–ß–ù–ò–ú –∑—É–º–æ–º
                // –í–∞–∂–ª–∏–≤–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ this.camera (–ø–æ—Ç–æ—á–Ω–µ), –∞ –Ω–µ target
                const worldX = (mx - this.camera.x) / this.camera.zoom;
                const worldY = (my - this.camera.y) / this.camera.zoom;

                // 3. –†–∞—Ö—É—î–º–æ –ù–û–í–ò–ô –∑—É–º
                const sensitivity = 0.0015; // –ß—É—Ç–ª–∏–≤—ñ—Å—Ç—å
                let newZoom = this.targetCamera.zoom * (1 - e.deltaY * sensitivity);
                newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));

                // 4. –û–Ω–æ–≤–ª—é—î–º–æ —Ü—ñ–ª—å –¥–ª—è –∑—É–º—É
                this.targetCamera.zoom = newZoom;

                // 5. –ú–ê–ì–Ü–Ø –°–¢–ê–ë–Ü–õ–Ü–ó–ê–¶–Ü–á:
                // –†–∞—Ö—É—î–º–æ, –¥–µ –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –∫–∞–º–µ—Ä–∞ (X, Y), —â–æ–± —Ç–æ—á–∫–∞ worldX 
                // –∑–∞–ª–∏—à–∏–ª–∞—Å—è —Ç–æ—á–Ω–æ –ø—ñ–¥ –∫—É—Ä—Å–æ—Ä–æ–º (mx) –ø—Ä–∏ –ù–û–í–û–ú–£ –∑—É–º—ñ (newZoom).
                // –§–æ—Ä–º—É–ª–∞: Screen = Cam + World * Zoom  =>  Cam = Screen - World * Zoom
                
                this.targetCamera.x = mx - worldX * newZoom;
                this.targetCamera.y = my - worldY * newZoom;
            }

            isDarkSquare(c, r) { return (c + r) % 2 !== 0; }

            getPieceSprite(symbol, color) {
                const key = `${symbol}_${color}`;
                if (this.spriteCache.has(key)) return this.spriteCache.get(key);

                // –ó–±—ñ–ª—å—à—É—î–º–æ —Ä–æ–∑–¥—ñ–ª—å–Ω—É –∑–¥–∞—Ç–Ω—ñ—Å—Ç—å –¥–ª—è —á—ñ—Ç–∫–æ—Å—Ç—ñ
                this.spriteSize = 256;

                const c = document.createElement('canvas');
                c.width = this.spriteSize;
                c.height = this.spriteSize;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();

                    // –í–ê–ñ–õ–ò–í–û: –î–æ–¥–∞—î–º–æ width/height —ñ viewBox 0 0 45 45, —â–æ–± —Ñ—ñ–≥—É—Ä–∞ —Ä–æ–∑—Ç—è–≥–Ω—É–ª–∞—Å—å –Ω–∞ –≤–µ—Å—å —Å–ø—Ä–∞–π—Ç
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${this.spriteSize}" height="${this.spriteSize}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0, 0, this.spriteSize, this.spriteSize);
                        ctx.drawImage(img, 0, 0, this.spriteSize, this.spriteSize);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;

                } else {
                    // –î–ª—è —Ñ–µ–Ω—Ç–µ–∑—ñ —Ñ—ñ–≥—É—Ä
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `bold ${this.spriteSize * 0.8}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.lineWidth = this.spriteSize * 0.05; ctx.lineJoin = 'round';
                    const cx = this.spriteSize / 2; const cy = this.spriteSize / 2 * 1.1;

                    if (isWhite) ctx.strokeStyle = '#000000';
                    else if (isBlack) ctx.strokeStyle = '#ffffff';
                    else ctx.strokeStyle = '#333333';

                    ctx.strokeText(symbol, cx, cy);
                    ctx.fillStyle = isWhite ? this.colors.whiteP : (isBlack ? this.colors.blackP : this.colors.neutralP);
                    ctx.fillText(symbol, cx, cy);
                }

                this.spriteCache.set(key, c);
                return c;
            }

            getLowResSprite(symbol, color) {
                const key = `${symbol}_${color}_lo`;
                if (this.lowResCache.has(key)) return this.lowResCache.get(key);

                // –ó–±—ñ–ª—å—à—É—î–º–æ —è–∫—ñ—Å—Ç—å "–Ω–∏–∑—å–∫–æ—ó —Ä–æ–∑–¥—ñ–ª—å–Ω–æ—ó –∑–¥–∞—Ç–Ω–æ—Å—Ç—ñ"
                const size = 128;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();
                    // –¢–µ–∂ —Å–∞–º–µ: —Ñ—ñ–∫—Å—É—î–º–æ —Ä–æ–∑–º—ñ—Ä SVG –ø—ñ–¥ –∫–∞–Ω–≤–∞—Å
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0,0,size,size);
                        ctx.drawImage(img, 0, 0, size, size);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;
                } else {
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `${size}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    const cx = size / 2; const cy = size / 2 * 1.1;
                    ctx.fillStyle = isWhite ? '#fff' : (isBlack ? '#000' : '#fa0');
                    ctx.fillText(symbol, cx, cy);
                }

                this.lowResCache.set(key, c);
                return c;
            }

            pseudoRandom(x, y) {
                return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
            }

            getPiece(c, r) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return null;

                const key = this.getKey(c, r);
                const val = this.grid.get(key);

                if (val !== undefined) {
                    if (val === GRID_VOID) return null;
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    return { x: c, y: r, s: p.s, c: p.c, hasMoved: hasMoved };
                }

                if (this.virtualGen) {
                    return this.getVirtualPiece(c, r);
                }

                return null;
            }
getVirtualPiece(c, r) {
                if (this.virtualGen === 'checkers') {
                     const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                     const armyHeight = rowsCalc;
                     if (!this.isDarkSquare(c, r)) return null;

                     if (r < armyHeight) return { x:c, y:r, s:'‚õÇ', c:'b' };
                     if (r >= this.boardSize - armyHeight) return { x:c, y:r, s:'‚õÄ', c:'w' };
                     return null;
                }

                const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                const armyHeight = Math.max(2, rowsCalc);
                const whiteStart = this.boardSize - armyHeight;

                let relativeRow = -1;
                let color = '';

                // Identify if this row belongs to an army and normalize row index
                if (r < armyHeight) {
                    color = 'b';
                    relativeRow = r;
                } else if (r >= whiteStart) {
                    color = 'w';
                    relativeRow = (this.boardSize - 1) - r; // Mirror row index
                } else {
                    return null;
                }

                // --- –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø –¢–£–¢: –ü—Ä–∏–º—É—Å–æ–≤–æ –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π Y ---
                const p = this.generateProceduralPiece(c, relativeRow, color, armyHeight);
                if (p) p.y = r; 
                return p;
            }
            
            generateProceduralPiece(c, relativeRow, color, height) {
                // 1. –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ü–µ–Ω—Ç—Ä –¥–ª—è –ö–æ—Ä–æ–ª—è (–±–µ–∑–ø–µ–∫–∞)
                let armyCenterCol = Math.floor(this.boardSize / 2);

                if (this.virtualGen === '3player') {
                    if (color === 'b') armyCenterCol = Math.floor((this.boardSize / 2) / 2);
                    else if (color === 'r') {
                        const mid = Math.floor(this.boardSize / 2);
                        armyCenterCol = mid + Math.floor((this.boardSize - mid) / 2);
                    }
                }

                // –ó–∞–≤–∂–¥–∏ —Å—Ç–∞–≤–∏–º–æ "–≥–æ–ª–æ–≤–Ω–æ–≥–æ" –∫–æ—Ä–æ–ª—è –ø–æ —Ü–µ–Ω—Ç—Ä—É (–¥–ª—è –ª–æ–≥—ñ–∫–∏ –≥—Ä–∏)
                if (c === armyCenterCol && relativeRow === 0) {
                    return { x: c, y: -1, s: color === 'w' ? '‚ôî' : '‚ôö', c: color };
                }
                
                // --- –ù–û–í–ê –õ–û–ì–Ü–ö–ê –î–õ–Ø –ê–†–ú–Ü–á (–©–æ–± –Ω–µ –∑–∞–≤–∏—Å–∞–ª–æ) ---
                if (this.virtualGen === 'army') {
                    // –ü–æ–ª–æ–≤–∏–Ω–∞ —Ä—è–¥—ñ–≤ - –æ—Ñ—ñ—Ü–µ—Ä–∏, –ø–æ–ª–æ–≤–∏–Ω–∞ - –ø—ñ—à–∞–∫–∏
                    const officerRows = Math.floor(height / 2);
                    
                    // –Ø–∫—â–æ —Ü–µ –ø–µ—Ä–µ–¥–Ω—ñ —Ä—è–¥–∏ - —Å—Ç–∞–≤–∏–º–æ –ü—ñ—à–∞–∫—ñ–≤
                    if (relativeRow >= officerRows) {
                         return { x: c, y: -1, s: color === 'w' ? '‚ôô' : '‚ôü', c: color };
                    }
                    
                    // –Ø–∫—â–æ —Ü–µ –∑–∞–¥–Ω—ñ —Ä—è–¥–∏ - —Å—Ç–∞–≤–∏–º–æ –ø–∞—Ç–µ—Ä–Ω –û—Ñ—ñ—Ü–µ—Ä—ñ–≤
                    const pattern = ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ'];
                    const mirrorMap = { '‚ôñ':'‚ôú', '‚ôò':'‚ôû', '‚ôó':'‚ôù', '‚ôï':'‚ôõ', '‚ôî':'‚ôö' };
                    
                    let sym = pattern[c % 8]; // –ü–æ–≤—Ç–æ—Ä–µ–Ω–Ω—è –∫–æ–∂–Ω—ñ 8 –∫–ª—ñ—Ç–∏–Ω–æ–∫
                    if (color !== 'w') sym = mirrorMap[sym]; // –î–ª—è —á–æ—Ä–Ω–∏—Ö/—á–µ—Ä–≤–æ–Ω–∏—Ö
                    
                    return { x: c, y: -1, s: sym, c: color };
                }
                // -----------------------------------------------

                // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ñ –ø—ñ—à–∞–∫–∏ –¥–ª—è —ñ–Ω—à–∏—Ö —Ä–µ–∂–∏–º—ñ–≤ (Classic/Fantasy)
                if (relativeRow === height - 1) {
                    return { x: c, y: -1, s: color === 'w' ? '‚ôô' : '‚ôü', c: color };
                }

                // –õ–æ–≥—ñ–∫–∞ –¥–ª—è Classic/Fantasy (Random)
                const classicMajors = ['‚ôñ', '‚ôò', '‚ôó', '‚ôï'];
                const mirrorMap = { '‚ôñ': '‚ôú', '‚ôò': '‚ôû', '‚ôó': '‚ôù', '‚ôï': '‚ôõ' };
                const fantasyMajors = ['ü¶Ñ', 'ü¶Ö', 'üê≤', 'üï∑Ô∏è', 'üê¢', 'üß®', 'üê´', 'ü¶ì', 'ü¶í', 'üêò', 'üöú', '‚öîÔ∏è', 'üõ°Ô∏è', 'üë®', 'ü¶ó', 'ü¶á', 'üèπ', 'üêª', 'üêï', 'ü¶Ä', 'üêÜ', 'üêøÔ∏è', 'ü§¥', 'üëº', 'üë∫', 'üçÑ', 'üåµ', 'üå≤', 'üçÅ', 'üåã', 'üåä', 'üå™Ô∏è', 'üå©Ô∏è', 'ü¶Ç', 'üêç', 'ü¶ñ', 'ü¶à', 'üêù', 'ü¶ã', 'üêô', 'üëæ', 'üó°Ô∏è', 'üîÆ', 'üìú', 'üíç', '‚öóÔ∏è', 'üí£', 'üß©', 'üé≤', 'üß¨', '‚öõÔ∏è', ...Object.keys(megaDefs)];
                
                const seed = c * 49297 + relativeRow * 9301 + this.generationSeed;
                const rnd = Math.abs(Math.sin(seed) * 10000) % 100;
                let symbol;

                if (this.virtualGen === 'fantasy' && rnd < this.virtualProps.mix) {
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 5) * fantasyMajors.length);
                    symbol = fantasyMajors[idx];
                } else {
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 7) * classicMajors.length);
                    let base = classicMajors[idx];
                    if (color !== 'w') symbol = mirrorMap[base];
                    else symbol = base;
                }
                return { x: c, y: -1, s: symbol, c: color };
            }

            setPiece(c, r, data) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return;
                const key = this.getKey(c, r);

                if (!data) {
                    if (this.virtualGen) {
                        this.grid.set(key, GRID_VOID);
                    } else {
                        this.grid.delete(key);
                    }
                    return;
                }

                const paletteId = this.getPaletteId(data.s, data.c);
                const hasMovedBit = (data.hasMoved ? 1 : 0) << 16;
                this.grid.set(key, paletteId | hasMovedBit);

                if (data.s === '‚ôî' && data.c === 'w') this.kingPos.w = {c, r};
                if (data.s === '‚ôö' && data.c === 'b') this.kingPos.b = {c, r};
            }

            removePiece(c, r) { this.setPiece(c, r, null); }
            
            updateLogUI() {
                const tbody = document.getElementById('logTableBody');
                if (!tbody) return;
                tbody.innerHTML = '';
                
                let moveCount = 1;
                let currentRow = null;

                this.moveHistory.forEach((step) => {
                    const not = step.notation;
                    if (!not) return; // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ —Å—Ç–∞—Ä—ñ/–±–∏—Ç—ñ –∑–∞–ø–∏—Å–∏

                    const moveHTML = `<span class="move-icon">${not.icon}</span><span class="move-coords">${not.start}‚Üí${not.end}</span>${not.cap ? '<span class="move-cap">x</span>' : ''}`;

                    if (step.turn === 'w') {
                        // –•—ñ–¥ –±—ñ–ª–∏—Ö - —Å—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π —Ä—è–¥–æ–∫
                        currentRow = document.createElement('tr');
                        currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>${moveHTML}</td><td></td>`;
                        tbody.appendChild(currentRow);
                    } else {
                        // –•—ñ–¥ —á–æ—Ä–Ω–∏—Ö
                        if (!currentRow) {
                            // –Ø–∫—â–æ —ñ—Å—Ç–æ—Ä—ñ—è –ø–æ—á–∞–ª–∞—Å—è –∑ —á–æ—Ä–Ω–∏—Ö (—Ä—ñ–¥–∫—ñ—Å–Ω–∏–π –≤–∏–ø–∞–¥–æ–∫)
                            currentRow = document.createElement('tr');
                            currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>...</td><td></td>`;
                            tbody.appendChild(currentRow);
                        }
                        currentRow.children[2].innerHTML = moveHTML;
                        moveCount++;
                        currentRow = null;
                    }
                });
                
                // –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ –≤–Ω–∏–∑
                const container = document.getElementById('logContainer');
                if(container) container.scrollTop = container.scrollHeight;
            }

            resetGame() {
                this.customArrows = [];

                this.grid.clear();
                this.moveHistory = [];
                this.pieceCount = 0;
                this.currentTurn = 'w'; this.gameOver = false;
                this.multiJumpSource = null;
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.updateUI(); 
                this.updateTurnIndicator();
                this.updateLogUI(); // <--- –í–ê–ñ–õ–ò–í–û: –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—ñ
            }

            fillCheckers() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.virtualGen = 'checkers';
                this.virtualProps.percent = percent;
                this.updateUI();
            }

            fillClassic() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'classic';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = 0;
                this.updateUI();
            }
            fillArmy() {
                // –û—Ç—Ä–∏–º—É—î–º–æ –≤—ñ–¥—Å–æ—Ç–æ–∫ –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; 
                if (percent > 50) percent = 50;

                this.resetGame();
                
                // –í–ú–ò–ö–ê–Ñ–ú–û –í–Ü–†–¢–£–ê–õ–¨–ù–£ –ì–ï–ù–ï–†–ê–¶–Ü–Æ –ó–ê–ú–Ü–°–¢–¨ –¶–ò–ö–õ–£
                this.virtualGen = 'army'; 
                this.virtualProps.percent = percent;
                
                this.updateUI();
                console.log("Mode: Army (Optimized/Virtual)");
            }
            fillChess960() {
                this.resetGame();
                this.virtualGen = null; // –í–∏–º–∏–∫–∞—î–º–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É –≥–µ–Ω–µ—Ä–∞—Ü—ñ—é

                // –í–∏–∑–Ω–∞—á–∞—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ä—è–¥—ñ–≤
                const whiteRow = this.boardSize - 1;
                const whitePawnRow = this.boardSize - 2;
                const blackRow = 0;
                const blackPawnRow = 1;

                // –Ø–∫—â–æ –¥–æ—à–∫–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ (8 –∫–ª—ñ—Ç–∏–Ω–æ–∫) ‚Äî –∫–ª–∞—Å–∏—á–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º 960
                // –Ø–∫—â–æ –≤–µ–ª–∏–∫–∞ ‚Äî —Ä–æ–∑—à–∏—Ä–µ–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º
                const width = this.boardSize;
                let rank = new Array(width).fill(null);
                let available = Array.from({length: width}, (_, i) => i);

                // --- –õ–û–ì–Ü–ö–ê –ì–ï–ù–ï–†–ê–¶–Ü–á ---

                // 1. –ö–û–†–û–õ–¨: –°—Ç–∞–≤–∏–º–æ –¥–µ—Å—å –±–ª–∏–∂—á–µ –¥–æ —Ü–µ–Ω—Ç—Ä—É
                // –©–æ–± –Ω–µ –∑–∞–≥–Ω–∞—Ç–∏ –π–æ–≥–æ –≤ –∫—É—Ç –Ω–∞ –¥–æ—à—Ü—ñ 100—Ö100
                const centerStart = Math.floor(width * 0.3);
                const centerEnd = Math.floor(width * 0.7);
                const possibleKingSpots = available.filter(i => i >= centerStart && i <= centerEnd);
                
                const kIdx = Math.floor(Math.random() * possibleKingSpots.length);
                const kPos = possibleKingSpots[kIdx];
                rank[kPos] = '‚ôî';
                
                // –í–∏–¥–∞–ª—è—î–º–æ –ø–æ–∑–∏—Ü—ñ—é –∫–æ—Ä–æ–ª—è –∑—ñ —Å–ø–∏—Å–∫—É –¥–æ—Å—Ç—É–ø–Ω–∏—Ö
                available = available.filter(i => i !== kPos);

                // 2. –¢–£–†–ò: –ú—ñ–Ω—ñ–º—É–º –æ–¥–Ω–∞ –∑–ª—ñ–≤–∞ —ñ –æ–¥–Ω–∞ —Å–ø—Ä–∞–≤–∞ –≤—ñ–¥ –∫–æ—Ä–æ–ª—è
                const leftSide = available.filter(i => i < kPos);
                const rightSide = available.filter(i => i > kPos);

                if (leftSide.length === 0 || rightSide.length === 0) {
                    // –¶–µ —Ç–µ–æ—Ä–µ—Ç–∏—á–Ω–æ –Ω–µ–º–æ–∂–ª–∏–≤–æ –ø—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É centerStart, –∞–ª–µ –ø—Ä–æ –≤—Å—è–∫ –≤–∏–ø–∞–¥–æ–∫
                    alert("–ü–æ–º–∏–ª–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó (–∑–∞–º–∞–ª–∞ –¥–æ—à–∫–∞)"); 
                    return;
                }

                const r1 = leftSide[Math.floor(Math.random() * leftSide.length)];
                const r2 = rightSide[Math.floor(Math.random() * rightSide.length)];
                rank[r1] = '‚ôñ';
                rank[r2] = '‚ôñ';
                
                // –û–Ω–æ–≤–ª—é—î–º–æ available
                available = available.filter(i => i !== r1 && i !== r2);

                // 3. –°–õ–û–ù–ò: –ì–µ–Ω–µ—Ä—É—î–º–æ –ø–∞—Ä–∞–º–∏ (—Ä—ñ–∑–Ω–æ–∫–æ–ª—å–æ—Ä–æ–≤–∏–º–∏)
                // –ù–∞ –≤–µ–ª–∏–∫–∏—Ö –¥–æ—à–∫–∞—Ö —Å–ª–æ–Ω—ñ–≤ –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–µ. –°–∫–∞–∂—ñ–º–æ, ~15% —Ñ—ñ–≥—É—Ä.
                let bishopsCount = Math.max(2, Math.floor(width * 0.15));
                if (bishopsCount % 2 !== 0) bishopsCount++; // –†–æ–±–∏–º–æ –ø–∞—Ä–Ω–∏–º

                // –†–æ–∑–¥—ñ–ª—è—î–º–æ –≤—ñ–ª—å–Ω—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –Ω–∞ –±—ñ–ª—ñ —Ç–∞ —á–æ—Ä–Ω—ñ (–ø–∞—Ä–Ω—ñ/–Ω–µ–ø–∞—Ä–Ω—ñ —ñ–Ω–¥–µ–∫—Å–∏)
                // –£–≤–∞–≥–∞: –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–ª—å–æ—Ä—É –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ (col + row), –∞–ª–µ –æ—Å–∫—ñ–ª—å–∫–∏ row –æ–¥–Ω–∞–∫–æ–≤–∏–π, 
                // —Ç–æ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏ –ø–∞—Ä–Ω—ñ—Å—Ç—å —ñ–Ω–¥–µ–∫—Å—É column.
                let evens = available.filter(i => i % 2 === 0);
                let odds = available.filter(i => i % 2 !== 0);

                for (let i = 0; i < bishopsCount / 2; i++) {
                    if (evens.length > 0 && odds.length > 0) {
                        // –ë–µ—Ä–µ–º–æ –æ–¥–∏–Ω –∑ –ø–∞—Ä–Ω–æ–≥–æ
                        const eIdx = Math.floor(Math.random() * evens.length);
                        const ePos = evens[eIdx];
                        rank[ePos] = '‚ôó';
                        evens.splice(eIdx, 1);

                        // –ë–µ—Ä–µ–º–æ –æ–¥–∏–Ω –∑ –Ω–µ–ø–∞—Ä–Ω–æ–≥–æ
                        const oIdx = Math.floor(Math.random() * odds.length);
                        const oPos = odds[oIdx];
                        rank[oPos] = '‚ôó';
                        odds.splice(oIdx, 1);
                    }
                }

                // –ó–±–∏—Ä–∞—î–º–æ –∑–∞–ª–∏—à–æ–∫ available –∑ –Ω–µ–≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–∏—Ö –ø–∞—Ä–Ω–∏—Ö/–Ω–µ–ø–∞—Ä–Ω–∏—Ö
                available = [...evens, ...odds];

                // 4. –ó–ê–ü–û–í–ù–ï–ù–ù–Ø (–§–µ—Ä–∑—ñ, –ö–æ–Ω—ñ —Ç–∞ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –¢—É—Ä–∏)
                // –ù–∞ –≤–µ–ª–∏–∫–∏—Ö –¥–æ—à–∫–∞—Ö –¥–æ–¥–∞–º–æ —Ç—Ä–æ—Ö–∏ —Ä—ñ–∑–Ω–æ–º–∞–Ω—ñ—Ç—Ç—è
                available.forEach(pos => {
                    const rand = Math.random();
                    if (rand < 0.45) rank[pos] = '‚ôò';       // 45% –ö—ñ–Ω—å
                    else if (rand < 0.80) rank[pos] = '‚ôï';  // 35% –§–µ—Ä–∑—å
                    else rank[pos] = '‚ôñ';                   // 20% –î–æ–¥–∞—Ç–∫–æ–≤–∞ –¢—É—Ä–∞
                });

                // --- –†–û–ó–ú–Ü–©–ï–ù–ù–Ø –ù–ê –î–û–®–¶–Ü ---
                const blackMirror = { '‚ôñ':'‚ôú', '‚ôò':'‚ôû', '‚ôó':'‚ôù', '‚ôï':'‚ôõ', '‚ôî':'‚ôö' };

                for (let c = 0; c < width; c++) {
                    const wSym = rank[c];
                    const bSym = blackMirror[wSym];

                    // –ë—ñ–ª—ñ
                    this.setPiece(c, whiteRow, { s: wSym, c: 'w' });
                    this.setPiece(c, whitePawnRow, { s: '‚ôô', c: 'w' });

                    // –ß–æ—Ä–Ω—ñ (–¥–∑–µ—Ä–∫–∞–ª—å–Ω–æ)
                    this.setPiece(c, blackRow, { s: bSym, c: 'b' });
                    this.setPiece(c, blackPawnRow, { s: '‚ôü', c: 'b' });
                }

                this.updateUI();
                console.log(`Mega 960 Generated: Size ${width}`);
            }

            fillFantasy() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                let mix = parseFloat(document.getElementById('fantasyMix').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'fantasy';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = mix;
                this.updateUI();
            }

            clear() {
                this.virtualGen = null;
                this.resetGame();
            }

            saveGame() {
                const pieces = [];
                for (const [key, val] of this.grid) {
                    const coord = key.split(',').map(Number);
                    if (val === GRID_VOID) {
                        pieces.push({ x: coord[0], y: coord[1], void: true });
                        continue;
                    }
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    pieces.push({
                        x: coord[0], y: coord[1], s: p.s, c: p.c, m: hasMoved ? 1 : 0
                    });
                }

                const saveData = {
                    format: "MegaChess_v4_History", // –û–Ω–æ–≤–ª–µ–Ω–∞ –≤–µ—Ä—Å—ñ—è —Ñ–æ—Ä–º–∞—Ç—É
                    timestamp: Date.now(),
                    boardSize: this.boardSize,
                    turn: this.currentTurn,
                    virtualGen: this.virtualGen,
                    virtualProps: this.virtualProps,
                    generationSeed: this.generationSeed,
                    moveHistory: this.moveHistory, // <-- –î–û–î–ê–ù–û –¶–ï
                    pieces: pieces
                };

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(saveData));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                const date = new Date().toISOString().slice(0,10);
                downloadAnchorNode.setAttribute("download", `megachess_${this.boardSize}x_${date}.json`);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            loadGame(inputElement) {
                const file = inputElement.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.applyLoadedData(data);
                    } catch (err) {
                        alert("–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è —Ñ–∞–π–ª—É! –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ —Ü–µ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π JSON.");
                        console.error(err);
                    }
                    inputElement.value = '';
                };
                reader.readAsText(file);
            }

            applyLoadedData(data) {
                this.grid.clear();
                this.moveHistory = [];
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;

                if (data.boardSize) {
                    document.getElementById('boardSize').value = data.boardSize;
                    this.boardSize = data.boardSize;
                }

                this.virtualGen = data.virtualGen || null;
                if (data.virtualProps) this.virtualProps = data.virtualProps;
                if (data.generationSeed) this.generationSeed = data.generationSeed;

                this.currentTurn = data.turn || 'w';

                // 1. –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —Ñ—ñ–≥—É—Ä
                if (Array.isArray(data.pieces)) {
                    data.pieces.forEach(p => {
                        if (p.x >= 0 && p.x < this.boardSize && p.y >= 0 && p.y < this.boardSize) {
                            if (p.void) {
                                this.grid.set(this.getKey(p.x, p.y), GRID_VOID);
                            } else {
                                this.setPiece(p.x, p.y, { s: p.s, c: p.c, hasMoved: !!p.m });
                            }
                        }
                    });
                }

                // 2. –í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ—Å—Ç–æ—Ä—ñ—ó —Ç–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è –≤ –ª–æ–∑—ñ
                const logList = document.getElementById('logList');
                logList.innerHTML = ''; // –û—á–∏—â—É—î–º–æ –ª–æ–≥ –ø–µ—Ä–µ–¥ –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è–º

                if (data.moveHistory && Array.isArray(data.moveHistory)) {
                    this.moveHistory = data.moveHistory;

                    // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ —ñ—Å—Ç–æ—Ä—ñ—ó —ñ –¥–æ–¥–∞—î–º–æ –≤ UI
                    // –í–∞–∂–ª–∏–≤–æ: addLogToUI –¥–æ–¥–∞—î –∑–≤–µ—Ä—Ö—É (prepend), —Ç–æ–º—É –ø—Ä–æ—Ö–æ–¥–∏–º–æ –º–∞—Å–∏–≤ –≤—ñ–¥ –ø–æ—á–∞—Ç–∫—É –¥–æ –∫—ñ–Ω—Ü—è
                    this.moveHistory.forEach(step => {
                        if (step.notation) {
                            this.addLogToUI(
                                step.notation.icon,
                                step.notation.start,
                                step.notation.end,
                                step.notation.cap
                            );
                        }
                    });
                } else {
                    // –Ø–∫—â–æ —ñ—Å—Ç–æ—Ä—ñ—ó –Ω–µ–º–∞—î (—Å—Ç–∞—Ä–∏–π —Ñ–∞–π–ª), –ø–æ–∫–∞–∑—É—î–º–æ –∑–∞–≥–ª—É—à–∫—É
                    logList.innerHTML = '<div class="log-entry" style="color:#999; justify-content:center;">–•–æ–¥—ñ–≤ —â–µ –Ω–µ–º–∞—î (–ê–±–æ —Ñ–∞–π–ª –±–µ–∑ —ñ—Å—Ç–æ—Ä—ñ—ó)</div>';
                }

                this.updateTurnIndicator();
                this.centerBoard();
                this.updateUI();

                // –°–∏—Å—Ç–µ–º–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –ª–æ–≥ –ø—Ä–æ —É—Å–ø—ñ—à–Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.style.color = 'green';
                div.style.background = '#e8f5e9';
                div.innerText = `üìÇ –§–∞–π–ª –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ —É—Å–ø—ñ—à–Ω–æ`;
                logList.prepend(div);
            }

            getFileLabel(index) { let label = ""; index++; while (index > 0) { let rem = (index - 1) % 26; label = String.fromCharCode(97 + rem) + label; index = Math.floor((index - 1) / 26); } return label; }
            isPathClear(c1, r1, c2, r2) { const dx = Math.sign(c2 - c1); const dy = Math.sign(r2 - r1); let x = c1 + dx; let y = r1 + dy; while (x !== c2 || y !== r2) { if (this.getPiece(x,y)) return false; x += dx; y += dy; } return true; }

             canCheckersCapture(piece, cx, cy, ignoredPiece) {
                const isKing = ['‚õÅ', '‚õÉ'].includes(piece.s);
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                for (const d of dirs) {
                    if (!isKing) {
                        // –õ–æ–≥—ñ–∫–∞ –ø—ñ—à–∞–∫–∞
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;
                        
                        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –Ω–µ —Ç–∞ —Å–∞–º–∞ —Ñ—ñ–≥—É—Ä–∞, —è–∫—É –º–∏ —â–æ–π–Ω–æ –ø–æ–±–∏–ª–∏ (ignoredPiece)
                        if (enemyX === ignoredPiece.x && enemyY === ignoredPiece.y) continue;

                        if (landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);
                            if (enemy && enemy.c !== piece.c && !landing) return true;
                        }
                    } else {
                        // –õ–æ–≥—ñ–∫–∞ –î–∞–º–∫–∏ (—Å–∫–∞–Ω—É—î–º–æ –ø—Ä–æ–º–µ–Ω—ñ)
                        for (let dist = 1; dist < this.boardSize; dist++) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;
                            
                            // –Ø–∫—â–æ –Ω–∞—Ç—Ä–∞–ø–∏–ª–∏ –Ω–∞ "—ñ–≥–Ω–æ—Ä–æ–≤–∞–Ω—É" (—â–æ–π–Ω–æ –ø–æ–±–∏—Ç—É) —Ñ—ñ–≥—É—Ä—É, –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ —ó—ó —è–∫ –ø–æ—Ä–æ–∂–Ω—î –º—ñ—Å—Ü–µ
                            if (tx === ignoredPiece.x && ty === ignoredPiece.y) continue;

                            const target = this.getPiece(tx, ty);
                            
                            if (target) {
                                if (target.c !== piece.c) {
                                    // –ó–Ω–∞–π—à–ª–∏ –≤–æ—Ä–æ–≥–∞, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î –º—ñ—Å—Ü–µ –∑–∞ –Ω–∏–º
                                    // –ü–æ—Ç—Ä—ñ–±–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ö–æ—á–∞ –± –æ–¥–Ω—É –∫–ª—ñ—Ç–∏–Ω–∫—É –∑–∞ –≤–æ—Ä–æ–≥–æ–º
                                    let landDist = 1;
                                    while (true) {
                                        const lx = tx + d[0] * landDist;
                                        const ly = ty + d[1] * landDist;
                                        if (lx < 0 || lx >= this.boardSize || ly < 0 || ly >= this.boardSize) break;
                                        
                                        const landingPiece = this.getPiece(lx, ly);
                                        // –Ø–∫—â–æ –Ω–∞—Ç—Ä–∞–ø–∏–ª–∏ –Ω–∞ —â–µ –æ–¥–Ω—É —Ñ—ñ–≥—É—Ä—É –∑—Ä–∞–∑—É –∂, –±—ñ–π –Ω–µ–º–æ–∂–ª–∏–≤–∏–π –≤ —Ü—å–æ–º—É –Ω–∞–ø—Ä—è–º–∫—É
                                        if (landingPiece && (lx !== ignoredPiece.x || ly !== ignoredPiece.y)) break;
                                        
                                        // –Ø–∫—â–æ –≤—ñ–ª—å–Ω–æ (–∞–±–æ —Ü–µ —ñ–≥–Ω–æ—Ä–æ–≤–∞–Ω–∞ —Ñ—ñ–≥—É—Ä–∞, —â–æ –º–∞–ª–æ–π–º–æ–≤—ñ—Ä–Ω–æ —Ç—É—Ç), —Ç–æ –±—ñ–π –º–æ–∂–ª–∏–≤–∏–π
                                        return true;
                                    }
                                    break; // –ó–∞ –≤–æ—Ä–æ–≥–æ–º –Ω–µ–º–∞—î –º—ñ—Å—Ü—è –∞–±–æ –≤–ø–µ—Ä–ª–∏—Å—è –≤ —ñ–Ω—à—É —Ñ—ñ–≥—É—Ä—É
                                } else {
                                    break; // –í–ø–µ—Ä–ª–∏—Å—è –≤ —Å–≤–æ–≥–æ
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            // --- –ù–û–í–ò–ô –ú–ï–¢–û–î: –†–ï–ö–£–†–°–ò–í–ù–ò–ô –ü–Ü–î–†–ê–•–£–ù–û–ö –î–û–í–ñ–ò–ù–ò –ë–û–Æ ---
            // –†–∞—Ö—É—î, —Å–∫—ñ–ª—å–∫–∏ –≤—Å—å–æ–≥–æ —à–∞—à–æ–∫ –º–æ–∂–Ω–∞ –∑–∞–±—Ä–∞—Ç–∏, —Å—Ç–∞—Ä—Ç—É—é—á–∏ –∑ (cx, cy)
            _measureCaptureChain(piece, cx, cy, ignoredPieces) {
                const isKing = ['‚õÅ', '‚õÉ'].includes(piece.s);
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                let maxChain = 0;

                for (const d of dirs) {
                    // --- –õ–û–ì–Ü–ö–ê –î–ê–ú–ö–ò ---
                    if (isKing) {
                        let foundEnemy = null;
                        // –°–∫–∞–Ω—É—î–º–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—å
                        for (let dist = 1; dist < this.boardSize; dist++) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;

                            // –í–∏—Ö—ñ–¥ –∑–∞ –º–µ–∂—ñ
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;

                            // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ "—ñ–≥–Ω–æ—Ä–æ–≤–∞–Ω–∏—Ö" (—É–±–∏—Ç–∏—Ö —É —Ü—å–æ–º—É –ª–∞–Ω—Ü—é–∂–∫—É)
                            let isIgnored = false;
                            for (const ip of ignoredPieces) {
                                if (ip.x === tx && ip.y === ty) { isIgnored = true; break; }
                            }
                            if (isIgnored) continue; // –ü—Ä–æ–ª—ñ—Ç–∞—î–º–æ –∫—Ä—ñ–∑—å —É–±–∏—Ç—É —à–∞—à–∫—É —è–∫ —á–µ—Ä–µ–∑ –ø—É—Å—Ç—É

                            const target = this.getPiece(tx, ty);

                            if (!foundEnemy) {
                                // –®—É–∫–∞—î–º–æ –≤–æ—Ä–æ–≥–∞
                                if (target) {
                                    if (target.c !== piece.c) {
                                        foundEnemy = { x: tx, y: ty };
                                    } else {
                                        break; // –í–ø–µ—Ä–ª–∏—Å—è –≤ —Å–≤–æ–≥–æ
                                    }
                                }
                            } else {
                                // –í–æ—Ä–æ–≥–∞ –≤–∂–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —à—É–∫–∞—î–º–æ –≤—ñ–ª—å–Ω—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –∑–∞ –Ω–∏–º
                                if (target) {
                                    break; // –í–ø–µ—Ä–ª–∏—Å—è –≤ —Ñ—ñ–≥—É—Ä—É –∑–∞ –≤–æ—Ä–æ–≥–æ–º
                                } else {
                                    // –ó–Ω–∞–π—à–ª–∏ —Ç–æ—á–∫—É –ø—Ä–∏–∑–µ–º–ª–µ–Ω–Ω—è!
                                    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —â–æ –º–æ–∂–Ω–∞ –±–∏—Ç–∏ –¥–∞–ª—ñ –∑ —Ü—ñ—î—ó —Ç–æ—á–∫–∏
                                    const newIgnored = [...ignoredPieces, foundEnemy];
                                    const depth = 1 + this._measureCaptureChain(piece, tx, ty, newIgnored);
                                    if (depth > maxChain) maxChain = depth;
                                }
                            }
                        }
                    } 
                    // --- –õ–û–ì–Ü–ö–ê –ü–†–û–°–¢–û–á –®–ê–®–ö–ò ---
                    else {
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;

                        // –ß–∏ –Ω–µ —ñ–≥–Ω–æ—Ä—É—î–º–æ –º–∏ —Ü—å–æ–≥–æ –≤–æ—Ä–æ–≥–∞?
                        let isIgnored = false;
                        for (const ip of ignoredPieces) { if (ip.x === enemyX && ip.y === enemyY) isIgnored = true; }

                        if (!isIgnored && landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);

                            if (enemy && enemy.c !== piece.c && !landing) {
                                // –ë—ñ–π –º–æ–∂–ª–∏–≤–∏–π
                                const newIgnored = [...ignoredPieces, {x: enemyX, y: enemyY}];
                                const depth = 1 + this._measureCaptureChain(piece, landX, landY, newIgnored);
                                if (depth > maxChain) maxChain = depth;
                            }
                        }
                    }
                }
                return maxChain;
            }

            // --- –û–ù–û–í–õ–ï–ù–ò–ô –ú–ï–¢–û–î –û–¢–†–ò–ú–ê–ù–ù–Ø –•–û–î–Ü–í ---
            getCheckersMoves(piece, cx, cy, onlyCaptures = false) {
                const moves = [];
                const possibleCaptures = [];
                const isKing = ['‚õÅ', '‚õÉ'].includes(piece.s);
                const isWhite = piece.c === 'w';
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                // 1. –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ "—Å–∏—Ä—ñ" —Ö–æ–¥–∏ (—Ç–∏—Ö—ñ —Ç–∞ –±–æ–π–æ–≤—ñ)
                for (const d of dirs) {
                    if (!isKing) {
                        // –ü—ñ—à–∞–∫
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;

                        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –±–æ—é
                        if (landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);
                            if (enemy && enemy.c !== piece.c && !landing) {
                                possibleCaptures.push({ 
                                    c: landX, r: landY, 
                                    isCapture: true, 
                                    captured: {x: enemyX, y: enemyY} 
                                });
                            }
                        }
                        // –¢–∏—Ö–∏–π —Ö—ñ–¥
                        if (!onlyCaptures) {
                            const forward = isWhite ? -1 : 1;
                            if (d[1] === forward) {
                                if (enemyX >= 0 && enemyX < this.boardSize && enemyY >= 0 && enemyY < this.boardSize) {
                                    if (!this.getPiece(enemyX, enemyY)) moves.push({ c: enemyX, r: enemyY });
                                }
                            }
                        }
                    } else {
                        // –î–∞–º–∫–∞
                        let foundEnemy = null;
                        for (let dist = 1; dist < this.boardSize; dist++) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;
                            const target = this.getPiece(tx, ty);

                            if (!foundEnemy) {
                                if (target) {
                                    if (target.c !== piece.c) foundEnemy = { x: tx, y: ty };
                                    else break;
                                } else {
                                    if (!onlyCaptures) moves.push({ c: tx, r: ty });
                                }
                            } else {
                                if (target) break; // –ë–ª–æ–∫–æ–≤–∞–Ω–æ
                                // –¶–µ —Ç–æ—á–∫–∞ –ø—Ä–∏–∑–µ–º–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –±–æ—é
                                possibleCaptures.push({ 
                                    c: tx, r: ty, 
                                    isCapture: true, 
                                    captured: { x: foundEnemy.x, y: foundEnemy.y } 
                                });
                            }
                        }
                    }
                }

                // 2. –§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è –∑–≥—ñ–¥–Ω–æ –ø—Ä–∞–≤–∏–ª–∞ –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û–ì–û –ë–û–Æ
                if (possibleCaptures.length > 0) {
                    // –î–ª—è –∫–æ–∂–Ω–æ–≥–æ –≤–∞—Ä—ñ–∞–Ω—Ç—É –±–æ—é —Ä–∞—Ö—É—î–º–æ –ø–æ–≤–Ω—É –¥–æ–≤–∂–∏–Ω—É –ª–∞–Ω—Ü—é–∂–∫–∞
                    let maxChainLen = 0;
                    
                    possibleCaptures.forEach(move => {
                        // –ü–æ—á–∞—Ç–∫–æ–≤–∞ –¥–æ–≤–∂–∏–Ω–∞ = 1 (–º–∏ –≤–∂–µ –∑—Ä–æ–±–∏–ª–∏ —Ü–µ–π —Å—Ç—Ä–∏–±–æ–∫).
                        // –ó–∞–ø—É—Å–∫–∞—î–º–æ —Ä–µ–∫—É—Ä—Å—ñ—é –∑ –Ω–æ–≤–æ—ó —Ç–æ—á–∫–∏, —ñ–≥–Ω–æ—Ä—É—é—á–∏ —â–æ–π–Ω–æ –ø–æ–±–∏—Ç—É —Ñ—ñ–≥—É—Ä—É.
                        const chainRest = this._measureCaptureChain(piece, move.c, move.r, [move.captured]);
                        move.totalChain = 1 + chainRest;
                        
                        if (move.totalChain > maxChainLen) maxChainLen = move.totalChain;
                    });

                    // –ó–∞–ª–∏—à–∞—î–º–æ –¢–Ü–õ–¨–ö–ò —Ç—ñ —Ö–æ–¥–∏, —è–∫—ñ –≤–µ–¥—É—Ç—å –¥–æ –Ω–∞–π–¥–æ–≤—à–æ–≥–æ –ª–∞–Ω—Ü—é–∂–∫–∞
                    // (–¶–µ –∑–º—É—à—É—î –¥–∞–º–∫—É –æ–±—Ä–∞—Ç–∏ —Å–∞–º–µ —Ç—É –∫–ª—ñ—Ç–∏–Ω–∫—É, –∑ —è–∫–æ—ó –º–æ–∂–Ω–∞ –±–∏—Ç–∏ –¥–∞–ª—ñ)
                    return possibleCaptures.filter(m => m.totalChain === maxChainLen);
                }

                return onlyCaptures ? [] : moves;
            }

            validateMove(piece, c1, r1, c2, r2, checkingAttack = false) {
                if (!this.rulesEnabled) return true;
                if (this.checkersSymbols.has(piece.s) && !checkingAttack) {
                    const legalMoves = this.generatePotentialMoves(piece, c1, r1);
                    return legalMoves.some(m => m.c === c2 && m.r === r2);
                }
                const dx = c2 - c1; const dy = r2 - r1;
                if (dx === 0 && dy === 0) return false;
                const target = this.getPiece(c2, r2);
                if (!checkingAttack && target && target.c === piece.c) return false;
                const absDx = Math.abs(dx); const absDy = Math.abs(dy);
                const type = piece.s; const isWhite = piece.c === 'w';

                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const checkComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && (['üöÄ','‚öì','üèπ','üé£','üò∫','üêó','üåä','üó°Ô∏è','üìú'].includes(type))) { dirY = -dirY; }
                            if (comp.t === 'slide' || def.t === 'slide') {
                                if (dirX === 0) { if (dx === 0 && Math.sign(dy) === Math.sign(dirY) && absDy <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else if (dirY === 0) { if (dy === 0 && Math.sign(dx) === Math.sign(dirX) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else { if (absDx === absDy && Math.sign(dx) === Math.sign(dirX) && Math.sign(dy) === Math.sign(dirY) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                            }
                            else if (comp.t === 'jump' || def.t === 'jump') { if (dx === dirX && dy === dirY) return true; }
                            else if (comp.t === 'step' || def.t === 'step') { let mul = comp.mul || 1; if (dx === dirX*mul && dy === dirY*mul) return true; }
                            else if (comp.t === 'slide_jump') { if (dx % dirX === 0 && dy % dirY === 0) { const steps = dx / dirX; if (steps === dy / dirY && steps > 0) { let cx = c1 + dirX, cy = r1 + dirY; while (cx !== c2 || cy !== r2) { if (this.getPiece(cx, cy)) return false; cx += dirX; cy += dirY; } return true; } } }
                        }
                        return false;
                    };
                    if (def.t === 'complex') { return def.comps.some(c => checkComp(c)); } else { return checkComp(def); }
                }

                const isRook = (dx === 0 || dy === 0) && this.isPathClear(c1, r1, c2, r2);
                const isBishop = (absDx === absDy) && this.isPathClear(c1, r1, c2, r2);
                const isKnight = (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                if (['‚ôñ','‚ôú','‚ôï','‚ôõ','ü¶Ö','üê≤','ü§¥','üçÑ'].includes(type)) { if (isRook) return true; }
                if (['‚ôó','‚ôù','‚ôï','‚ôõ','‚õÅ','‚õÉ','ü¶Ñ','üê≤','üëº','üêÜ','üë∫'].includes(type)) { if (isBishop) return true; }
                if (['‚ôò','‚ôû','ü¶Ñ','ü¶Ö','üê≤','üêøÔ∏è'].includes(type)) { if (isKnight) return true; }
                if (['‚ôî','‚ôö','üë®','üêª','ü§¥','üëº'].includes(type)) return absDx <= 1 && absDy <= 1;
                if (type === '‚ôô' || type === '‚ôü') { const dir = isWhite ? -1 : 1; if (dx === 0 && dy === dir) return !target && !checkingAttack; if (dx === 0 && dy === dir * 2) { return !piece.hasMoved && !target && !checkingAttack && !this.getPiece(c1, r1 + dir); } if (absDx === 1 && dy === dir) return checkingAttack || (target && target.c !== piece.c); return false; }
                if (['üê¢','üêï'].includes(type)) return (absDx + absDy === 1) || (absDx===0 && dy===(isWhite?-1:1));
                return false;
            }
findKing(color) {
                if(color === 'w' && this.kingPos.w) return this.kingPos.w;
                if(color === 'b' && this.kingPos.b) return this.kingPos.b;

                // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø: –î–æ–¥–∞–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É, —á–∏ –Ω–µ –≤–∏–¥–∞–ª–µ–Ω–∞ —Ñ—ñ–≥—É—Ä–∞ –≥—É–º–∫–æ—é (GRID_VOID)
                if (this.virtualGen === 'classic' || this.virtualGen === 'fantasy' || this.virtualGen === 'army') {
                     const kingCol = Math.floor(this.boardSize/2);
                     let kR = -1;
                     if (color === 'b') kR = 0;
                     if (color === 'w') kR = this.boardSize - 1;
                     
                     if (kR !== -1) {
                        // –Ø–∫—â–æ –Ω–∞ –º—ñ—Å—Ü—ñ –∫–æ—Ä–æ–ª—è —Å—Ç–æ—ó—Ç—å "–ø—É—Å—Ç–æ—Ç–∞" (–≤–∏–¥–∞–ª–µ–Ω–æ), –Ω–µ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –π–æ–≥–æ
                        if (this.grid.get(this.getKey(kingCol, kR)) !== GRID_VOID) {
                             return {c: kingCol, r: kR};
                        }
                     }
                }

                const kingSymbol = color === 'w' ? '‚ôî' : '‚ôö';
                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    if(p.s === kingSymbol && p.c === color) {
                         const parts = key.split(',');
                         return {c: parseInt(parts[0]), r: parseInt(parts[1])};
                    }
                }
                return null;
            }
            
           endGame(title = "–ú–ê–¢!") {
                this.gameOver = true;
                
                // –í–∏–∑–Ω–∞—á–∞—î–º–æ –ø–µ—Ä–µ–º–æ–∂—Ü—è (—Ç–æ–π, —Ö—Ç–æ –∑—Ä–æ–±–∏–≤ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π —Ö—ñ–¥)
                // –Ø–∫—â–æ –∑–∞—Ä–∞–∑ —Ö—ñ–¥ 'w' —ñ —Ö–æ–¥—ñ–≤ –Ω–µ–º–∞—î -> –≤–∏–≥—Ä–∞–ª–∏ –ß–æ—Ä–Ω—ñ.
                const winner = this.currentTurn === 'w' ? "–ß–æ—Ä–Ω—ñ" : "–ë—ñ–ª—ñ";
                
                let icon = "";
                
                if (this.virtualGen === 'checkers') {
                    // –Ø–∫—â–æ —à–∞—à–∫–∏: –ø–æ–∫–∞–∑—É—î–º–æ —à–∞—à–∫—É –ø–µ—Ä–µ–º–æ–∂—Ü—è
                    // –Ø–∫—â–æ –≤–∏–≥—Ä–∞–ª–∏ –ß–æ—Ä–Ω—ñ -> –ß–æ—Ä–Ω–∞ —à–∞—à–∫–∞, —ñ–Ω–∞–∫—à–µ –ë—ñ–ª–∞
                    icon = this.currentTurn === 'w' ? "‚õÇ" : "‚õÄ"; 
                } else {
                    // –Ø–∫—â–æ —à–∞—Ö–∏: –ø–æ–∫–∞–∑—É—î–º–æ –∫–æ—Ä–æ–ª—è –ø–µ—Ä–µ–º–æ–∂—Ü—è
                    icon = this.currentTurn === 'w' ? "‚ôö" : "‚ôî";
                }
                
                const titleEl = document.querySelector('.victory-card h1');
                if (titleEl) titleEl.innerText = title;

                document.getElementById('winnerTxt').innerText = `–ü–µ—Ä–µ–º–æ–≥–∞: ${winner}`;
                document.getElementById('winnerIcon').innerText = icon;
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }

            showStalemate() {
                this.gameOver = true;
                document.getElementById('winnerTxt').innerText = "–ù—ñ—á–∏—è (–ü–∞—Ç)";
                document.getElementById('winnerIcon').innerText = "ü§ù"; // –Ü–∫–æ–Ω–∫–∞ —Ä—É–∫–æ—Å—Ç–∏—Å–∫–∞–Ω–Ω—è
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }
            // –ú–µ—Ç–æ–¥ –¥–ª—è —Ä—É—á–Ω–æ—ó –∑–º—ñ–Ω–∏ —Å—Ç–æ—Ä–æ–Ω–∏ (–†–µ–∂–∏–º –†–µ–¥–∞–∫—Ç–æ—Ä–∞)
            toggleTurnColor() {
                // –ú—ñ–Ω—è—î–º–æ —Å—Ç–æ—Ä–æ–Ω—É
                this.currentTurn = this.currentTurn === 'w' ? 'b' : 'w';
                
                // –°–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä "–ö—ñ–Ω–µ—Ü—å –≥—Ä–∏", —â–æ–± –º–æ–∂–Ω–∞ –±—É–ª–æ –¥–æ–≥—Ä–∞—Ç–∏ –∞–±–æ –≤–∏–ø—Ä–∞–≤–∏—Ç–∏ —Å–∏—Ç—É–∞—Ü—ñ—é
                this.gameOver = false;
                document.getElementById('gameOverOverlay').style.display = 'none';

                // –û–Ω–æ–≤–ª—é—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É —à–∞—Ö—ñ–≤ –¥–ª—è –Ω–æ–≤–æ—ó —Å—Ç–æ—Ä–æ–Ω–∏
                if (this.virtualGen !== 'checkers') {
                    this.kingsInCheck.w = this.isInCheck('w') ? this.findKing('w') : null;
                    this.kingsInCheck.b = this.isInCheck('b') ? this.findKing('b') : null;
                }

                // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å
                this.updateTurnIndicator();
                
                // –î–æ–¥–∞—î–º–æ –∑–∞–ø–∏—Å –≤ –ª–æ–≥ –ø—Ä–æ –∑–º—ñ–Ω—É —á–µ—Ä–≥–∏ (–æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ, —â–æ–± –±—É–ª–æ –≤–∏–¥–Ω–æ –≤ —ñ—Å—Ç–æ—Ä—ñ—ó)
                const logList = document.getElementById('logList'); // –Ø–∫—â–æ –≤–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç–µ —Å—Ç–∞—Ä—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É
                // –ê–±–æ –ø—Ä–æ—Å—Ç–æ –≤ –∫–æ–Ω—Å–æ–ª—å, —â–æ–± –Ω–µ –∑–∞—Å–º—ñ—á—É–≤–∞—Ç–∏ –ª–æ–≥ —Ö–æ–¥—ñ–≤
                console.log(`–ß–µ—Ä–≥—É –∑–º—ñ–Ω–µ–Ω–æ –Ω–∞: ${this.currentTurn === 'w' ? '–ë—ñ–ª—ñ' : '–ß–æ—Ä–Ω—ñ'}`);
            }
switchTurn() {
                if (!this.turnModeEnabled) return;

                this.currentTurn = this.currentTurn === 'w' ? 'b' : 'w';

                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É —à–∞—Ö—É (—Ç—ñ–ª—å–∫–∏ –¥–ª—è —à–∞—Ö—ñ–≤)
                if (this.virtualGen !== 'checkers') {
                    this.kingsInCheck.w = this.isInCheck('w') ? this.findKing('w') : null;
                    this.kingsInCheck.b = this.isInCheck('b') ? this.findKing('b') : null;
                } else {
                    this.kingsInCheck = { w: null, b: null };
                }

                this.updateTurnIndicator();

                // –ó–∞–ø—É—Å–∫–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –∑ –∑–∞—Ç—Ä–∏–º–∫–æ—é, —â–æ–± –±—Ä–∞—É–∑–µ—Ä –≤—Å—Ç–∏–≥ –Ω–∞–º–∞–ª—é–≤–∞—Ç–∏ —Ö—ñ–¥
                setTimeout(() => {
                    // –Ø–∫—â–æ —É –ø–æ—Ç–æ—á–Ω–æ–≥–æ –≥—Ä–∞–≤—Ü—è –Ω–µ–º–∞—î —Ö–æ–¥—ñ–≤...
                    if (!this.hasAnyLegalMoves(this.currentTurn)) {
                        
                        if (this.virtualGen === 'checkers') {
                             this.endGame("–ü–ï–†–ï–ú–û–ì–ê!"); 
                        } 
                        else {
                            if (this.kingsInCheck[this.currentTurn]) {
                                this.endGame("–ú–ê–¢!"); 
                            } else {
                                this.showStalemate(); 
                            }
                        }
                    }
                }, 20);
            }
            
            updateTurnIndicator() {
                const ind = document.getElementById('turnIndicator');
                const txt = document.getElementById('turnText');
                const icon = document.getElementById('turnIcon');
                
                // –ó–ê–í–ñ–î–ò –ø–æ–∫–∞–∑—É—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä, –Ω–∞–≤—ñ—Ç—å —è–∫—â–æ —Ä–µ–∂–∏–º —Ö–æ–¥—ñ–≤ –≤–∏–º–∫–Ω–µ–Ω–æ
                ind.style.display = 'flex';
                
                if (!this.turnModeEnabled) {
                    // --- –†–ï–ñ–ò–ú –†–ï–î–ê–ö–¢–û–†–ê (–ñ–æ–≤—Ç–∏–π) ---
                    ind.style.background = '#f1c40f'; 
                    ind.style.color = '#000';
                    ind.style.borderColor = '#f39c12';
                    // –ü–æ–∫–∞–∑—É—î–º–æ, —á–∏–π –±—É–¥–µ —Ö—ñ–¥, –∫–æ–ª–∏ –≥—Ä—É –∑–∞–ø—É—Å—Ç—è—Ç—å
                    const label = this.currentTurn === 'w' ? "–ë—ñ–ª—ñ" : "–ß–æ—Ä–Ω—ñ";
                    txt.innerText = `–†–µ–¥–∞–∫—Ç–æ—Ä (${label})`;
                    icon.innerText = this.currentTurn === 'w' ? "‚ôî" : "‚ôö";
                } else {
                    // --- –†–ï–ñ–ò–ú –ì–†–ò ---
                    if (this.currentTurn === 'w') {
                        ind.style.background = 'rgba(255, 255, 255, 0.95)'; 
                        ind.style.color = '#000';
                        ind.style.borderColor = (this.kingsInCheck.w) ? 'red' : '#ccc';
                        txt.innerText = (this.kingsInCheck.w) ? "–•—ñ–¥: –ë—ñ–ª—ñ (–®–ê–•!)" : "–•—ñ–¥: –ë—ñ–ª—ñ";
                        icon.innerText = "‚ôî";
                    } else {
                        ind.style.background = 'rgba(30, 30, 30, 0.95)'; 
                        ind.style.color = '#fff';
                        ind.style.borderColor = (this.kingsInCheck.b) ? 'red' : '#555';
                        txt.innerText = (this.kingsInCheck.b) ? "–•—ñ–¥: –ß–æ—Ä–Ω—ñ (–®–ê–•!)" : "–•—ñ–¥: –ß–æ—Ä–Ω—ñ";
                        icon.innerText = "‚ôö";
                    }
                }
            }

            toggleRules() { this.rulesEnabled = !this.rulesEnabled; if(!this.rulesEnabled) this.kingsInCheck = { w: null, b: null }; document.getElementById('rulesBtn').innerText = this.rulesEnabled ? "üü¢ –ü—Ä–∞–≤–∏–ª–∞" : "üî¥ –ü—Ä–∞–≤–∏–ª–∞"; }
            toggleTurnMode() { this.turnModeEnabled = !this.turnModeEnabled; this.updateTurnIndicator(); document.getElementById('turnBtn').innerText = this.turnModeEnabled ? "üü¢ –•—ñ–¥ (–í–ö–õ)" : "üî¥ –•—ñ–¥ (–í–ò–ö–õ)"; }

            findKing(color) {
                if(color === 'w' && this.kingPos.w) return this.kingPos.w;
                if(color === 'b' && this.kingPos.b) return this.kingPos.b;

                // –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø: –î–æ–¥–∞–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É, —á–∏ –Ω–µ –≤–∏–¥–∞–ª–µ–Ω–∞ —Ñ—ñ–≥—É—Ä–∞ –≥—É–º–∫–æ—é (GRID_VOID)
                if (this.virtualGen === 'classic' || this.virtualGen === 'fantasy' || this.virtualGen === 'army') {
                     const kingCol = Math.floor(this.boardSize/2);
                     let kR = -1;
                     if (color === 'b') kR = 0;
                     if (color === 'w') kR = this.boardSize - 1;
                     
                     if (kR !== -1) {
                        // –Ø–∫—â–æ –Ω–∞ –º—ñ—Å—Ü—ñ –∫–æ—Ä–æ–ª—è —Å—Ç–æ—ó—Ç—å "–ø—É—Å—Ç–æ—Ç–∞" (–≤–∏–¥–∞–ª–µ–Ω–æ), –Ω–µ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ –π–æ–≥–æ
                        if (this.grid.get(this.getKey(kingCol, kR)) !== GRID_VOID) {
                             return {c: kingCol, r: kR};
                        }
                     }
                }

                const kingSymbol = color === 'w' ? '‚ôî' : '‚ôö';
                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    if(p.s === kingSymbol && p.c === color) {
                         const parts = key.split(',');
                         return {c: parseInt(parts[0]), r: parseInt(parts[1])};
                    }
                }
                return null;
            }

            isSquareAttacked(targetC, targetR, byOpponentOfColor) {
                // 1. –®–≤–∏–¥–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–æ—Ä–æ–∂–æ–≥–æ –ö–û–†–û–õ–Ø (–¶–µ —Ç–µ, —á–æ–≥–æ –Ω–µ –≤–∏—Å—Ç–∞—á–∞–ª–æ!)
                const enemyKingPos = this.findKing(byOpponentOfColor);
                if (enemyKingPos) {
                    const dkx = Math.abs(enemyKingPos.c - targetC);
                    const dky = Math.abs(enemyKingPos.r - targetR);
                    // –Ø–∫—â–æ –∫–ª—ñ—Ç–∏–Ω–∫–∞ –ø–æ—Ä—É—á –∑ –≤–æ—Ä–æ–∂–∏–º –∫–æ—Ä–æ–ª–µ–º ‚Äî –≤–æ–Ω–∞ –ø—ñ–¥ –∞—Ç–∞–∫–æ—é
                    if (dkx <= 1 && dky <= 1) return true;
                }

                // 2. –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ (–ö–æ–Ω—ñ, –ü—ñ—à–∞–∫–∏, –ü—Ä–æ–º–µ–Ω—ñ)
                const enemyQueen = byOpponentOfColor === 'w' ? '‚ôï' : '‚ôõ';
                const enemyRook = byOpponentOfColor === 'w' ? '‚ôñ' : '‚ôú';
                const enemyBishop = byOpponentOfColor === 'w' ? '‚ôó' : '‚ôù';
                const enemyKnight = byOpponentOfColor === 'w' ? '‚ôò' : '‚ôû';
                const enemyPawn = byOpponentOfColor === 'w' ? '‚ôô' : '‚ôü';

                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ö–æ–Ω—ñ–≤
                const knights = [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]];
                for (const [dx, dy] of knights) {
                    const p = this.getPiece(targetC + dx, targetR + dy);
                    if (p && p.c === byOpponentOfColor && (p.s === enemyKnight || p.s === 'ü¶Ñ')) return true;
                }

                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ü—ñ—à–∞–∫—ñ–≤
                const pawnDy = byOpponentOfColor === 'w' ? 1 : -1;
                const checkPawn = (offset) => {
                     const p = this.getPiece(targetC + offset, targetR + pawnDy);
                     return p && p.c === byOpponentOfColor && p.s === enemyPawn;
                }
                if (checkPawn(1) || checkPawn(-1)) return true;

                // –û–ü–¢–ò–ú–Ü–ó–û–í–ê–ù–ê –ü–ï–†–ï–í–Ü–†–ö–ê –õ–Ü–ù–Ü–ô (Raycast)
                const checkRayOptimized = (dx, dy, types) => {
                    let closestDist = Infinity;
                    let closestPiece = null;

                    // –ê. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä–µ–∞–ª—å–Ω–∏—Ö —Ñ—ñ–≥—É—Ä
                    for (const [key, val] of this.grid) {
                        if (val === GRID_VOID) continue; 
                        const comma = key.indexOf(',');
                        const pc = parseInt(key.substring(0, comma));
                        const pr = parseInt(key.substring(comma + 1));
                        const distC = pc - targetC;
                        const distR = pr - targetR;
                        
                        let valid = false;
                        let d = Infinity;
                        
                        if (dx !== 0 && dy !== 0) { // –î—ñ–∞–≥–æ–Ω–∞–ª—å
                            if (Math.abs(distC) === Math.abs(distR) && Math.sign(distC) === dx && Math.sign(distR) === dy) {
                                valid = true; d = Math.abs(distC);
                            }
                        } else if (dx !== 0) { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å
                            if (distR === 0 && Math.sign(distC) === dx) { valid = true; d = Math.abs(distC); }
                        } else { // –í–µ—Ä—Ç–∏–∫–∞–ª—å
                            if (distC === 0 && Math.sign(distR) === dy) { valid = true; d = Math.abs(distR); }
                        }

                        if (valid && d < closestDist) {
                            closestDist = d;
                            const id = val & 0xFFFF;
                            closestPiece = this.palette[id-1];
                        }
                    }

                    // –ë. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –í—ñ—Ä—Ç—É–∞–ª—å–Ω–∏—Ö –ê—Ä–º—ñ–π
                    if (this.virtualGen) {
                         let armyH = 0;
                         if (this.virtualGen === 'chess960') armyH = 2;
                         else if (this.virtualGen !== 'checkers') {
                             armyH = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                             if (armyH < 2) armyH = 2;
                         } else {
                             armyH = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                         }
                         const topBoundary = armyH; 
                         const botBoundary = this.boardSize - armyH;
                         let vDist = Infinity;

                         if (dy !== 0) {
                             if (dy < 0) { if (targetR >= topBoundary) vDist = targetR - (topBoundary - 1); } 
                             else { if (targetR < botBoundary) vDist = botBoundary - targetR; }
                         } else {
                             if (targetR < topBoundary || targetR >= botBoundary) vDist = 1;
                         }

                         if (vDist < closestDist) {
                             const vx = targetC + dx * vDist; const vy = targetR + dy * vDist;
                             if (vx >= 0 && vx < this.boardSize && vy >= 0 && vy < this.boardSize) {
                                 const vp = this.getPiece(vx, vy);
                                 if (vp) { closestDist = vDist; closestPiece = vp; }
                             }
                         }
                    }

                    // –í. –§—ñ–Ω–∞–ª—å–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞
                    if (closestPiece && closestPiece.c === byOpponentOfColor) {
                        if (types.includes(closestPiece.s)) return true;
                        if (types.includes(enemyQueen) && ['üßú','üî±','ü¶Ö'].includes(closestPiece.s)) return true;
                    }
                    return false;
                };

                if (checkRayOptimized(0, 1, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(0, -1, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(1, 0, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(-1, 0, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(1, -1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(-1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(-1, -1, [enemyBishop, enemyQueen])) return true;

                return false;
            }

            isInCheck(kingColor) { const kingPos = this.findKing(kingColor); if (!kingPos) return false; return this.isSquareAttacked(kingPos.c, kingPos.r, kingColor === 'w' ? 'b' : 'w'); }
            updateKingCheckStatus(color) { this.kingsInCheck[color] = this.isInCheck(color) ? this.findKing(color) : null; }

            hasAnyLegalMoves(color) {
                // –¢–∞–π–º–µ—Ä –¥–ª—è –∑–∞—Ö–∏—Å—Ç—É –≤—ñ–¥ –ø–æ–≤–Ω–æ–≥–æ –∑–∞–≤–∏—Å–∞–Ω–Ω—è
                const startTime = performance.now();
                // –î–∞—î–º–æ –±—ñ–ª—å—à–µ —á–∞—Å—É (200–º—Å), —â–æ–± –≤—Å—Ç–∏–≥–Ω—É—Ç–∏ –∑–Ω–∞–π—Ç–∏ —Ö—ñ–¥
                const MAX_CALC_TIME_MS = 200; 

                // 1. –î–ª—è –≥—ñ–≥–∞–Ω—Ç—Å—å–∫–∏—Ö –¥–æ—à–æ–∫ (>64) –≤–∑–∞–≥–∞–ª—ñ –Ω–µ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ (—â–æ–± –Ω–µ –ª–∞–≥–∞–ª–æ –ø—Ä–∏ —Ö–æ–¥—å–±—ñ)
                if (this.boardSize > 64) return true;

                // 2. –î–ª—è –º–∞–ª–∏—Ö –¥–æ—à–æ–∫ (<= 20) –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ü–û–í–ù–Ü–°–¢–Æ (—ñ–≥–Ω–æ—Ä—É—î–º–æ —Ç–∞–π–º–µ—Ä), 
                // —â–æ–± –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –ø–æ–∫–∞–∑–∞—Ç–∏ –ú–ê–¢.
                const allowTimeout = (this.boardSize > 20);

                const checkPiece = (p, cx, cy) => {
                    const moves = this.generatePotentialMoves(p, cx, cy);
                    for (const m of moves) {
                        if (this.checkersSymbols.has(p.s)) return true;
                        if (this.simulateMoveAndCheckSafety(p, cx, cy, m.c, m.r)) {
                            return true;
                        }
                    }
                    return false;
                };

                // –°–∫–∞–Ω—É–≤–∞–Ω–Ω—è GRID (—Ä–µ–∞–ª—å–Ω—ñ —Ñ—ñ–≥—É—Ä–∏)
                for (const [key, val] of this.grid) {
                    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ç–∞–π–º–µ—Ä —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –¥–æ—à–∫–∞ –≤–µ–ª–∏–∫–∞
                    if (allowTimeout && (performance.now() - startTime > MAX_CALC_TIME_MS)) return true;

                    if (val === GRID_VOID) continue;
                    const comma = key.indexOf(',');
                    const cx = parseInt(key.substring(0, comma));
                    const cy = parseInt(key.substring(comma + 1));
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    
                    if (p.c === color) {
                        if (checkPiece(p, cx, cy)) return true;
                    }
                }

                // –°–∫–∞–Ω—É–≤–∞–Ω–Ω—è Virtual (–∞—Ä–º—ñ—è)
                if (this.virtualGen) {
                    let armyHeight = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                    if (this.virtualGen === 'chess960') armyHeight = 2;
                    else if (armyHeight < 2 && this.virtualGen !== 'checkers') armyHeight = 2;

                    const ranges = [
                        {start: 0, end: armyHeight},
                        {start: this.boardSize - armyHeight, end: this.boardSize}
                    ];

                    for (const range of ranges) {
                        for (let r = range.start; r < range.end; r++) {
                            for (let c = 0; c < this.boardSize; c++) {
                                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ç–∞–π–º–µ—Ä–∞ –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ —Ü–∏–∫–ª—É (—Ä—ñ–¥—à–µ, –∫–æ–∂–Ω—ñ 10 —Å—Ç–æ–≤–ø—Ü—ñ–≤)
                                if (allowTimeout && (c % 10 === 0) && (performance.now() - startTime > MAX_CALC_TIME_MS)) return true;

                                if (this.grid.has(this.getKey(c, r))) continue;

                                const p = this.getVirtualPiece(c, r);
                                if (p && p.c === color) {
                                    if (checkPiece(p, c, r)) return true;
                                }
                            }
                        }
                    }
                }

                return false;
            }hasAnyLegalMoves(color) {
                // –¢–∞–π–º–µ—Ä: –¥–∞—î–º–æ 500–º—Å –Ω–∞ –ø–æ—à—É–∫ —Ö–æ–¥—É (–ø—ñ–≤ —Å–µ–∫—É–Ω–¥–∏ - —Ü–µ –Ω–µ–ø–æ–º—ñ—Ç–Ω–æ –ø—Ä–∏ –º–∞—Ç—ñ)
                const startTime = performance.now();
                const MAX_CALC_TIME_MS = 500;

                // –Ø–∫—â–æ –¥–æ—à–∫–∞ –≥—ñ–≥–∞–Ω—Ç—Å—å–∫–∞ (>64x64), –∞–≤—Ç–æ-–º–∞—Ç –≤–∏–º–∏–∫–∞—î–º–æ –ø–æ–≤–Ω—ñ—Å—Ç—é
                if (this.boardSize > 64) return true;

                // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
                const checkPiece = (p, cx, cy) => {
                    const moves = this.generatePotentialMoves(p, cx, cy);
                    // –î–ª—è —à–∞—à–æ–∫ –ø—Ä–æ—Å—Ç–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å —Ö–æ–¥—É
                    if (this.checkersSymbols.has(p.s)) return moves.length > 0;
                    
                    // –î–ª—è —à–∞—Ö—ñ–≤ - –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –±–µ–∑–ø–µ–∫—É
                    for (const m of moves) {
                        if (this.simulateMoveAndCheckSafety(p, cx, cy, m.c, m.r)) {
                            return true; // –ó–Ω–∞–π—à–ª–∏ —Ä—è—Ç—ñ–≤–Ω–∏–π —Ö—ñ–¥!
                        }
                    }
                    return false;
                };

                // --- –ö–†–û–ö 1: –ü–ï–†–ï–í–Ü–†–ö–ê –ö–û–†–û–õ–Ø (–ü–†–Ü–û–†–ò–¢–ï–¢) ---
                // –ù–∞–π—á–∞—Å—Ç—ñ—à–µ –ø—Ä–∏ —à–∞—Ö—É —Ç—Ä–µ–±–∞ —Ç—ñ–∫–∞—Ç–∏ –∫–æ—Ä–æ–ª–µ–º. –ü–µ—Ä–µ–≤—ñ—Ä–∏–º–æ —Ü–µ –ø–µ—Ä—à–∏–º, —Ü–µ –¥—É–∂–µ —à–≤–∏–¥–∫–æ.
                const kPos = this.findKing(color);
                if (kPos) {
                    const kPiece = this.getPiece(kPos.c, kPos.r);
                    if (kPiece && checkPiece(kPiece, kPos.c, kPos.r)) return true;
                }

                // --- –ö–†–û–ö 2: –ü–ï–†–ï–í–Ü–†–ö–ê –Ü–ù–®–ò–• –§–Ü–ì–£–† ---
                
                // –ê. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ä–µ–∞–ª—å–Ω–∏—Ö —Ñ—ñ–≥—É—Ä (Grid)
                for (const [key, val] of this.grid) {
                    // –Ø–∫—â–æ —á–∞—Å –≤–∏–π—à–æ–≤ - –ø–µ—Ä–µ—Ä–∏–≤–∞—î–º–æ —ñ –≤–≤–∞–∂–∞—î–º–æ, —â–æ —Ö—ñ–¥ —î (—â–æ–± –Ω–µ –≤–∏—Å–ª–æ)
                    if (performance.now() - startTime > MAX_CALC_TIME_MS) return true;

                    if (val === GRID_VOID) continue;
                    const comma = key.indexOf(',');
                    const cx = parseInt(key.substring(0, comma));
                    const cy = parseInt(key.substring(comma + 1));
                    
                    // –ö–æ—Ä–æ–ª—è –º–∏ –≤–∂–µ –ø–µ—Ä–µ–≤—ñ—Ä–∏–ª–∏, –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
                    if (cx === kPos?.c && cy === kPos?.r) continue;

                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    
                    if (p.c === color) {
                        if (checkPiece(p, cx, cy)) return true;
                    }
                }

                // –ë. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–∏—Ö —Ñ—ñ–≥—É—Ä (–ê—Ä–º—ñ—è)
                if (this.virtualGen) {
                    let armyHeight = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                    if (this.virtualGen === 'chess960') armyHeight = 2;
                    else if (armyHeight < 2 && this.virtualGen !== 'checkers') armyHeight = 2;

                    const ranges = [
                        {start: 0, end: armyHeight},
                        {start: this.boardSize - armyHeight, end: this.boardSize}
                    ];

                    for (const range of ranges) {
                        for (let r = range.start; r < range.end; r++) {
                            for (let c = 0; c < this.boardSize; c++) {
                                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∞—Å—É –∫–æ–∂–Ω—ñ 10 –∫–ª—ñ—Ç–∏–Ω–æ–∫
                                if ((c % 10 === 0) && (performance.now() - startTime > MAX_CALC_TIME_MS)) return true;

                                // –Ø–∫—â–æ —Ñ—ñ–≥—É—Ä–∞ –≤–∂–µ –∑–º—ñ–Ω–µ–Ω–∞ (–≤ Grid), –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
                                if (this.grid.has(this.getKey(c, r))) continue;
                                // –ö–æ—Ä–æ–ª—è –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
                                if (c === kPos?.c && r === kPos?.r) continue;

                                const p = this.getVirtualPiece(c, r);
                                if (p && p.c === color) {
                                    if (checkPiece(p, c, r)) return true;
                                }
                            }
                        }
                    }
                }

                return false;
            }
            _resolveDirs(d) { return typeof d === 'string' ? DIRS[d] : d; }

            generatePotentialMoves(piece, cx, cy, bounds = null) {
                // –ï—Å–ª–∏ —ç—Ç–æ —à–∞—à–∫–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—É—é –ª–æ–≥–∏–∫—É (–æ–Ω–∞ –ª–æ–∫–∞–ª—å–Ω–∞—è, –Ω–µ –¥–ª–∏–Ω–Ω–∞—è)
                if (this.checkersSymbols.has(piece.s)) {
                    if (!this.multiJumpSource && this.rulesEnabled) return this.getCheckersMoves(piece, cx, cy);
                    else if (this.multiJumpSource) {
                        if (cx !== this.multiJumpSource.c || cy !== this.multiJumpSource.r) return [];
                        return this.getCheckersMoves(piece, cx, cy, true);
                    }
                    return this.getCheckersMoves(piece, cx, cy);
                }

                let moves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –æ–¥–Ω–æ–π —Ç–æ—á–∫–∏ (–ø—Ä—ã–∂–æ–∫ –∫–æ–Ω—è, –∫–æ—Ä–æ–ª—è)
                const addStep = (dx, dy) => {
                    let x = cx + dx; let y = cy + dy;
                    if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {
                        moves.push({c: x, r: y});
                    }
                };

                // –í–ê–ñ–ù–û: –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ (–°–ª–∞–π–¥–µ—Ä—ã: –õ–∞–¥—å—è, –°–ª–æ–Ω, –§–µ—Ä–∑—å)
                const addTrace = (dx, dy) => {
                    let x = cx + dx; 
                    let y = cy + dy;
                    
                    // –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞, –Ω–æ —Ç–µ–ø–µ—Ä—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∞ —ç–∫—Ä–∞–Ω–æ–º –∏–ª–∏ –¥–æ—Å–∫–æ–π
                    let steps = 0;
                    // –ú–∞–∫—Å–∏–º—É–º —à–∞–≥–æ–≤ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä–æ–º –¥–æ—Å–∫–∏, –Ω–æ –ø—Ä–µ—Ä–≤–µ–º —Ä–∞–Ω—å—à–µ
                    const maxSteps = this.boardSize; 

                    while (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize && steps < maxSteps) {
                        // 1. –í–ò–†–¢–£–ê–õ–¨–ù–ê–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø:
                        // –ï—Å–ª–∏ –µ—Å—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞ (bounds) –∏ –º—ã –≤—ã—à–ª–∏ –∑–∞ –Ω–∏—Ö ‚Äî –ü–†–ï–†–´–í–ê–ï–ú–°–Ø.
                        // –ù–µ—Ç —Å–º—ã—Å–ª–∞ —Ä–∏—Å–æ–≤–∞—Ç—å —Ç–æ—á–∫–∏ —Ç–∞–º, –≥–¥–µ –∏–≥—Ä–æ–∫ –Ω–µ –≤–∏–¥–∏—Ç.
                        if (bounds) {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–≤–∏–∂–µ–º—Å—è –ª–∏ –º—ã –û–¢ —Ñ–∏–≥—É—Ä—ã –ó–ê –ø—Ä–µ–¥–µ–ª—ã —ç–∫—Ä–∞–Ω–∞
                            // (–£–ø—Ä–æ—â–µ–Ω–Ω–æ: –µ—Å–ª–∏ —Ç–æ—á–∫–∞ –≤–Ω–µ —ç–∫—Ä–∞–Ω–∞, –ø–µ—Ä–µ—Å—Ç–∞–µ–º –¥–æ–±–∞–≤–ª—è—Ç—å)
                            if (x < bounds.minC || x > bounds.maxC || y < bounds.minR || y > bounds.maxR) {
                                // –ù–æ –Ω—É–∂–Ω–æ –±—ã—Ç—å –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã–º: –µ—Å–ª–∏ —Ñ–∏–≥—É—Ä–∞ —Å–∞–º–∞ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º, –∞ –±—å–µ—Ç –í —ç–∫—Ä–∞–Ω.
                                // –ü–æ—ç—Ç–æ–º—É –ø—Ä–æ–≤–µ—Ä—è–µ–º: –µ—Å–ª–∏ –º—ã –£–ñ–ï –¥–∞–ª–µ–∫–æ –æ—Ç —Ñ–∏–≥—É—Ä—ã –∏ –≤—ã—à–ª–∏ –∑–∞ —ç–∫—Ä–∞–Ω.
                                if (Math.abs(x - cx) > 50 || Math.abs(y - cy) > 50) break;
                                
                                // –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ: –µ—Å–ª–∏ —Ç–æ—á–∫–∞ –¥–∞–ª–µ–∫–æ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤—å—é–ø–æ—Ä—Ç–∞, break.
                                // –†–∞–∑—Ä–µ—à–∞–µ–º –Ω–µ–±–æ–ª—å—à–æ–π "–æ–≤–µ—Ä–¥—Ä–∞—Ñ—Ç", —á—Ç–æ–±—ã –ª–∏–Ω–∏–∏ –Ω–µ –æ–±—Ä—ã–≤–∞–ª–∏—Å—å —Ä–µ–∑–∫–æ –ø—Ä–∏ —Å–∫—Ä–æ–ª–ª–µ
                            }
                        }

                        const target = this.getPiece(x, y);
                        if (target) {
                            // –ï—Å–ª–∏ –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏ —Ñ–∏–≥—É—Ä—É
                            if (target.c !== piece.c) moves.push({c: x, r: y}); // –ë—å–µ–º –≤—Ä–∞–≥–∞
                            break; // –ò –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è
                        }
                        
                        // –ï—Å–ª–∏ –ø—É—Å—Ç–æ - –¥–æ–±–∞–≤–ª—è–µ–º —Ö–æ–¥
                        moves.push({c: x, r: y});
                        
                        x += dx; y += dy;
                        steps++;
                    }
                };

                // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–≤–∏–∂–µ–Ω–∏—è
                if (['‚ôñ','‚ôú','‚ôï','‚ôõ'].includes(type)) { addTrace(1,0); addTrace(-1,0); addTrace(0,1); addTrace(0,-1); }
                if (['‚ôó','‚ôù','‚ôï','‚ôõ'].includes(type)) { addTrace(1,1); addTrace(-1,1); addTrace(1,-1); addTrace(-1,-1); }
                if (['‚ôò','‚ôû'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => addStep(d[0], d[1])); }
                if (['‚ôî','‚ôö'].includes(type)) { for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i||j) addStep(i,j); }
                
                // –ü–µ—à–∫–∏
                if (['‚ôô','‚ôü'].includes(type)) {
                    const d = isWhite ? -1 : 1;
                    if (!this.getPiece(cx, cy + d)) addStep(0, d);
                    if (!this.getPiece(cx, cy + d*2) && !this.getPiece(cx, cy + d) && !piece.hasMoved) addStep(0, d*2);
                    const t1 = this.getPiece(cx + 1, cy + d); if (t1 && t1.c !== piece.c) addStep(1, d);
                    const t2 = this.getPiece(cx - 1, cy + d); if (t2 && t2.c !== piece.c) addStep(-1, d);
                }
                
                // –ú–µ–≥–∞-—Ñ–∏–≥—É—Ä—ã
                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const FLIP_Y_LIST = ['üöÄ','‚öì','üèπ','üé£','üò∫','üêó','üåä','üó°Ô∏è','üìú'];
                    const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            
                            if (moveType === 'slide' || moveType === 'slide_jump') {
                                // –ó–¥–µ—Å—å –º—ã –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞—Ç—å limit, —Ç–∞–∫ –∫–∞–∫ addTrace —Ç–µ–ø–µ—Ä—å —Å–∞–º —Ä–µ—à–∞–µ—Ç –∫–æ–≥–¥–∞ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
                                // –ù–æ –¥–ª—è "–∫–æ—Ä–æ—Ç–∫–∏—Ö" —Å–ª–∞–π–¥–µ—Ä–æ–≤ (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã—Ö max), –º—ã –º–æ–∂–µ–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å –≤–Ω—É—Ç—Ä–∏
                                // –î–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ addTrace, –æ–Ω —Å–∞–º –æ–±—Ä–µ–∂–µ—Ç—Å—è –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ —ç–∫—Ä–∞–Ω–∞
                                addTrace(dirX, dirY); 
                            } else { 
                                let mul = comp.mul || 1; 
                                addStep(dirX * mul, dirY * mul); 
                            }
                        }
                    };
                    if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }
                return moves;
            }

            simulateMoveAndCheckSafety(piece, startC, startR, targetC, targetR) {
                if (!this.validateMove(piece, startC, startR, targetC, targetR)) return false;

                const keyStart = this.getKey(startC, startR);
                const keyTarget = this.getKey(targetC, targetR);

                const valStart = this.grid.get(keyStart);
                const valTarget = this.grid.get(keyTarget);

                const wasKingW = this.kingPos.w;
                const wasKingB = this.kingPos.b;

                if (valStart === undefined && this.virtualGen) {
                    const p = this.getVirtualPiece(startC, startR);
                    const pid = this.getPaletteId(p.s, p.c);
                    this.grid.set(keyTarget, pid);
                    this.grid.set(keyStart, GRID_VOID);
                } else {
                    this.grid.set(keyTarget, valStart);
                    this.grid.delete(keyStart);
                }

                if(piece.s === '‚ôî') this.kingPos.w = {c: targetC, r: targetR};
                if(piece.s === '‚ôö') this.kingPos.b = {c: targetC, r: targetR};

                const isSafe = !this.isInCheck(piece.c);

                if (valTarget === undefined) this.grid.delete(keyTarget); else this.grid.set(keyTarget, valTarget);
                if (valStart === undefined) this.grid.delete(keyStart); else this.grid.set(keyStart, valStart);

                this.kingPos.w = wasKingW;
                this.kingPos.b = wasKingB;

                return isSafe;
            }
            tryPlacePiece(c, r) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return;
                // –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –≥—É–º–∫–∏
                if (this.curSymbol === '‚ùå' || this.curSymbol === 'eraser') {
                    this.removePiece(c, r);
                } else {
                    // –°—Ç–∞–≤–∏–º–æ —Ñ—ñ–≥—É—Ä—É
                    this.setPiece(c, r, { s: this.curSymbol, c: this.curColor, hasMoved: false });
                }
            }

              calculateHighlights(piece, cx, cy) {
                if (!this.rulesEnabled) return;
                
                this.highlightedMoves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è: –ø–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ –±–µ–∑–ø–µ—á–Ω–∏–π —Ö—ñ–¥, –ø–µ—Ä—à –Ω—ñ–∂ –º–∞–ª—é–≤–∞—Ç–∏ –∫—Ä–∞–ø–∫—É
                const tryAddMove = (tx, ty, isCapture) => {
                    if (this.simulateMoveAndCheckSafety(piece, cx, cy, tx, ty)) {
                        this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: isCapture });
                    }
                };

                // --- 1. –°–ª–∞–π–¥–µ—Ä–∏ ---
                const castRay = (dx, dy, maxLimit = this.boardSize) => {
                    const end = this.findRayEnd(cx, cy, dx, dy, maxLimit);
                    let dist = Math.max(Math.abs(end.x - cx), Math.abs(end.y - cy));
                    if (end.hit || end.ally) dist--;

                    // –ú–∞–ª—é—î–º–æ –ª—ñ–Ω—ñ—é (–±–µ–∑–ø–µ–∫—É –ø—Ä–æ–º—ñ–∂–Ω–∏—Ö —Ç–æ—á–æ–∫ –∑–∞–∑–≤–∏—á–∞–π –Ω–µ –ø–µ—Ä–µ–≤—ñ—Ä—è—é—Ç—å –¥–ª—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ, 
                    // –∞–ª–µ –∫–æ—Ä–æ–ª—ñ –Ω–µ —Ö–æ–¥—è—Ç—å –ª—ñ–Ω—ñ—è–º–∏, —Ç–æ–º—É —Ü–µ –û–ö)
                    if (dist > 0) {
                        this.highlightedMoves.push({ type: 'ray', cx: cx, cy: cy, dx: dx, dy: dy, len: dist });
                    }

                    // –ê—Ç–∞–∫–∞ –≤ –∫—ñ–Ω—Ü—ñ –ª—ñ–Ω—ñ—ó
                    if (end.hit && !end.ally) {
                        tryAddMove(end.x, end.y, true);
                    }
                };

                // --- 2. –°—Ç—Ä–∏–±—É–Ω–∏ (–ö–æ—Ä–æ–ª—å, –ö—ñ–Ω—å) ---
                const checkJump = (dx, dy) => {
                    const tx = cx + dx; const ty = cy + dy;
                    if (tx >= 0 && tx < this.boardSize && ty >= 0 && ty < this.boardSize) {
                        const target = this.getPiece(tx, ty);
                        if (!target) {
                             tryAddMove(tx, ty, false);
                        } else if (target.c !== piece.c) {
                             tryAddMove(tx, ty, true);
                        }
                    }
                };

                // –®–∞—à–∫–∏
                if (this.checkersSymbols.has(type)) {
                    const moves = this.generatePotentialMoves(piece, cx, cy);
                    moves.forEach(m => this.highlightedMoves.push({ type: 'point', c: m.c, r: m.r, capture: !!m.isCapture }));
                    return;
                }

                if (['‚ôñ','‚ôú','‚ôï','‚ôõ'].includes(type)) { castRay(1,0); castRay(-1,0); castRay(0,1); castRay(0,-1); }
                if (['‚ôó','‚ôù','‚ôï','‚ôõ'].includes(type)) { castRay(1,1); castRay(-1,1); castRay(1,-1); castRay(-1,-1); }
                if (['‚ôò','‚ôû'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => checkJump(d[0], d[1])); }
                if (['‚ôî','‚ôö'].includes(type)) { for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i||j) checkJump(i,j); }

                // Mega —Ñ—ñ–≥—É—Ä–∏
                if (megaDefs[type]) {
                     const def = megaDefs[type];
                     const FLIP_Y_LIST = ['üöÄ','‚öì','üèπ','üé£','üò∫','üêó','üåä','üó°Ô∏è','üìú'];
                     const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0], dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            if (moveType === 'slide' || moveType === 'slide_jump') castRay(dirX, dirY, limit);
                            else { let mul = comp.mul || 1; checkJump(dirX * mul, dirY * mul); }
                        }
                     };
                     if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }

                // –ü—ñ—à–∞–∫–∏
                if (['‚ôô','‚ôü'].includes(type)) {
                    const dir = isWhite ? -1 : 1;
                    const fwd1 = this.getPiece(cx, cy + dir);
                    if (!fwd1) {
                        tryAddMove(cx, cy + dir, false);
                        if (!piece.hasMoved) {
                            const fwd2 = this.getPiece(cx, cy + dir * 2);
                            if (!fwd2) tryAddMove(cx, cy + dir * 2, false);
                        }
                    }
                    [1, -1].forEach(dx => {
                        const tx = cx + dx; const ty = cy + dir;
                        const t = this.getPiece(tx, ty);
                        if (t && t.c !== piece.c) tryAddMove(tx, ty, true);
                    });
                }
            }
            onMouseDown(e) {
                if (this.gameOver || this.isGenerating || this.promotionPending) return;
                
                this.clickStart = { x: e.clientX, y: e.clientY };
                const w = this.screenToWorld(e.clientX, e.clientY);
                const c = Math.floor(w.x / this.cellSize); 
                const r = Math.floor(w.y / this.cellSize);

                // --- –õ–Ü–í–ê –ö–ù–û–ü–ö–ê (–õ–ö–ú): –ì—Ä–∞ –∞–±–æ –ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è –ö–∞–º–µ—Ä–∏ ---
                if (e.button === 0) {
                    this.customArrows = []; // –ö–ª—ñ–∫ –ª—ñ–≤–æ—é —Å—Ç–∏—Ä–∞—î —Å—Ç—Ä—ñ–ª–∫–∏ (—è–∫ –Ω–∞ Lichess)

                    // 1. –Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ì–£–ú–ö–ê (–≤–∏–¥–∞–ª–µ–Ω–Ω—è –º–∏—Ç—Ç—î–≤–µ)
                    if (!this.turnModeEnabled && (this.curSymbol === '‚ùå' || this.curSymbol === 'delete')) {
                        this.tryPlacePiece(c, r); 
                        return; 
                    }
                    
                    // 2. –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î —Ç—É—Ç —Ñ—ñ–≥—É—Ä–∞, —è–∫—É –º–æ–∂–Ω–∞ –≤–∑—è—Ç–∏
                    const piece = this.getPiece(c, r);
                    let canGrabPiece = false;
                    if (piece) {
                        if (!this.turnModeEnabled || piece.c === this.currentTurn) {
                            canGrabPiece = true;
                        }
                    }

                    if (canGrabPiece) {
                        // –Ø–∫—â–æ –ø–æ–ø–∞–ª–∏ –ø–æ —Ñ—ñ–≥—É—Ä—ñ -> –¢–Ø–ì–ù–ï–ú–û –§–Ü–ì–£–†–£
                        this.isDraggingPiece = true;
                        this.draggedPiece = { data: piece, startC: c, startR: r };
                        this.calculateHighlights(piece, c, r);
                    } else {
                        // –Ø–∫—â–æ –ø–æ–ø–∞–ª–∏ –≤ –ø—É—Å—Ç–µ –º—ñ—Å—Ü–µ -> –¢–Ø–ì–ù–ï–ú–û –î–û–®–ö–£ (–ö–ê–ú–ï–†–£)
                        this.isDragging = true; 
                        this.lastMouse = { x: e.clientX, y: e.clientY }; 
                        this.canvas.style.cursor = "grabbing";
                    }
                } 
                
                // --- –ü–†–ê–í–ê –ö–ù–û–ü–ö–ê (–ü–ö–ú): –¢—ñ–ª—å–∫–∏ –º–∞–ª—é–≤–∞–Ω–Ω—è —Å—Ç—Ä—ñ–ª–æ–∫ ---
                else if (e.button === 2) {
                    // –ó–∞–ø–∞–º'—è—Ç–æ–≤—É—î–º–æ —Å—Ç–∞—Ä—Ç —Å—Ç—Ä—ñ–ª–∫–∏ (Shift –±—ñ–ª—å—à–µ –Ω–µ –ø–æ—Ç—Ä—ñ–±–µ–Ω)
                    if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) {
                        this.rmbStart = { c, r };
                    } else {
                        this.rmbStart = null;
                    }
                }
            }
            onMouseMove(e) {
                this.mouse.x = e.clientX; this.mouse.y = e.clientY;
                if (this.promotionPending) return;

                // 1. –õ–æ–≥—ñ–∫–∞ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è –∫–∞–º–µ—Ä–∏ (—Ç–µ–ø–µ—Ä –ø—Ä–∞—Ü—é—î –≤—ñ–¥ –õ–ö–ú)
                if (this.isDragging) { 
                    const dx = e.clientX - this.lastMouse.x;
                    const dy = e.clientY - this.lastMouse.y;

                    this.camera.x += dx; 
                    this.camera.y += dy; 
                    this.targetCamera.x += dx;
                    this.targetCamera.y += dy;

                    this.lastMouse = { x: e.clientX, y: e.clientY }; 
                    this.clampCamera(); 
                }
                
                const w = this.screenToWorld(e.clientX, e.clientY); 
                const c = Math.floor(w.x / this.cellSize); 
                const r = Math.floor(w.y / this.cellSize);

                // 2. –õ–æ–≥—ñ–∫–∞ –º–∞–ª—é–≤–∞–Ω–Ω—è —Ñ—ñ–≥—É—Ä (—Ä–µ–¥–∞–∫—Ç–æ—Ä)
                if (this.isPainting) this.tryPlacePiece(c, r);

                // 3. –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ UI
                if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) { 
                    const file = this.getFileLabel(c); 
                    const rank = this.boardSize - r; 
                    document.getElementById('coord').innerText = `${file}${rank}`; 
                }
            }


                       onMouseUp(e) {
                // --- –ü–†–ê–í–ê –ö–ù–û–ü–ö–ê (–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Å—Ç—Ä—ñ–ª–∫–∏) ---
                if (e.button === 2 && this.rmbStart) {
                    const w = this.screenToWorld(e.clientX, e.clientY);
                    let rawC = Math.floor(w.x / this.cellSize); 
                    let rawR = Math.floor(w.y / this.cellSize);
                    const endC = Math.max(0, Math.min(this.boardSize - 1, rawC));
                    const endR = Math.max(0, Math.min(this.boardSize - 1, rawR));

                    if (this.rmbStart.c !== endC || this.rmbStart.r !== endR) {
                        const newArrow = { sx: this.rmbStart.c, sy: this.rmbStart.r, ex: endC, ey: endR };
                        const idx = this.customArrows.findIndex(a => a.sx === newArrow.sx && a.sy === newArrow.sy && a.ex === newArrow.ex && a.ey === newArrow.ey);
                        if (idx >= 0) this.customArrows.splice(idx, 1); 
                        else this.customArrows.push(newArrow);
                    }
                    this.rmbStart = null; 
                    this.updateUI(); 
                    return;
                }

                if (e.button === 2) this.isPainting = false;
                if (this.promotionPending) return;

                // --- –õ–Ü–í–ê –ö–ù–û–ü–ö–ê (–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ö–æ–¥—É –∞–±–æ –∫–∞–º–µ—Ä–∏) ---
                if (e.button === 0) {
                    const w = this.screenToWorld(e.clientX, e.clientY);
                    const c = Math.floor(w.x / this.cellSize); 
                    const r = Math.floor(w.y / this.cellSize);

                    // 1. –°–ø–æ—á–∞—Ç–∫—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —Ü–µ –±—É–≤ –∫–ª—ñ–∫
                    let isClick = false;
                    if (this.clickStart) {
                        const dist = Math.hypot(e.clientX - this.clickStart.x, e.clientY - this.clickStart.y);
                        if (dist < 5) isClick = true;
                    }

                    // 2. –Ø–∫—â–æ –º–∏ —Ä—É—Ö–∞–ª–∏ –∫–∞–º–µ—Ä—É
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.canvas.style.cursor = "grab";
                        if (!isClick) return; 
                    }

                    // –°–¶–ï–ù–ê–†–Ü–ô –ê: –ö–õ–Ü–ö (–í–∏–±—ñ—Ä –∞–±–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä)
                    if (isClick) {
                        if (!this.turnModeEnabled) {
                            this.tryPlacePiece(c, r);
                        }
                        this.isDraggingPiece = false;
                        this.draggedPiece = null;
                        this.highlightedMoves = [];
                        this.updateUI();
                        return; 
                    }

                    // –°–¶–ï–ù–ê–†–Ü–ô –ë: –ö–Ü–ù–ï–¶–¨ –ü–ï–†–ï–¢–Ø–ì–£–í–ê–ù–ù–Ø –§–Ü–ì–£–†–ò (–•—ñ–¥)
                    if (this.isDraggingPiece && this.draggedPiece) {
                        if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) {
                            if (c !== this.draggedPiece.startC || r !== this.draggedPiece.startR) {
                                
                                // 1. –û—Ç—Ä–∏–º—É—î–º–æ –≤—Å—ñ –ª–µ–≥–∞–ª—å–Ω—ñ —Ö–æ–¥–∏ –¥–ª—è —Ü—ñ—î—ó —Ñ—ñ–≥—É—Ä–∏
                                const potentialMoves = this.generatePotentialMoves(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR);
                                // 2. –®—É–∫–∞—î–º–æ, —á–∏ —î —Å–µ—Ä–µ–¥ –Ω–∏—Ö —Ç–æ–π, —è–∫–∏–π –∑—Ä–æ–±–∏–≤ –≥—Ä–∞–≤–µ—Ü—å (–ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
                                const chosenMove = potentialMoves.find(m => m.c === c && m.r === r);

                                if (chosenMove) {
                                    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –±–µ–∑–ø–µ–∫–∏ (–¥–ª—è —à–∞—Ö—ñ–≤)
                                    let isMoveSafe = true;
                                    if (this.rulesEnabled && !this.checkersSymbols.has(this.draggedPiece.data.s)) {
                                        isMoveSafe = this.simulateMoveAndCheckSafety(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR, c, r);
                                    }
                                    
                                    if (isMoveSafe) {
                                        // --- –õ–û–ì–Ü–ö–ê –î–õ–Ø –®–ê–®–û–ö (–í–ò–ü–†–ê–í–õ–ï–ù–û) ---
                                        if (this.checkersSymbols.has(this.draggedPiece.data.s) && chosenMove.isCapture) {
                                            // –í–∏–¥–∞–ª—è—î–º–æ –ø–æ–±–∏—Ç—É —à–∞—à–∫—É
                                            if (chosenMove.captured) {
                                                this.removePiece(chosenMove.captured.x, chosenMove.captured.y);
                                            }
                                        }

                                        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—ñ—à–∞–∫–∞ –Ω–∞ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è (–®–∞—Ö–∏ —Ç–∞ –®–∞—à–∫–∏)
                                        const isWhite = this.draggedPiece.data.c === 'w';
                                        const isPawn = this.draggedPiece.data.s === '‚ôô' || this.draggedPiece.data.s === '‚ôü';
                                        const isCheckerMan = this.draggedPiece.data.s === '‚õÄ' || this.draggedPiece.data.s === '‚õÇ';
                                        const promotionRow = isWhite ? 0 : this.boardSize - 1;
                                        
                                        // –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –ü—ñ—à–∞–∫–∞ (–®–∞—Ö–∏)
                                        if (isPawn && r === promotionRow) {
                                            this.promotionPending = { piece: this.draggedPiece.data, startC: this.draggedPiece.startC, startR: this.draggedPiece.startR, endC: c, endR: r };
                                            this.showPromotionDialog(this.draggedPiece.data.c);
                                            this.draggedPiece = null; this.isDraggingPiece = false; this.highlightedMoves = []; return;
                                        }
                                        // –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –î–∞–º–∫–∏ (–®–∞—à–∫–∏) - –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
                                        if (isCheckerMan && r === promotionRow) {
                                            this.draggedPiece.data.s = isWhite ? '‚õÅ' : '‚õÉ';
                                        }

                                        // –ó–∞–ø–∏—Å —Ö–æ–¥—É –≤ —ñ—Å—Ç–æ—Ä—ñ—é
                                        const startCoord = this.getCoordString(this.draggedPiece.startC, this.draggedPiece.startR);
                                        const endCoord = this.getCoordString(c, r);
                                        const isCap = !!this.getPiece(c,r) || (chosenMove.isCapture); // –í—Ä–∞—Ö—É–≤–∞–Ω–Ω—è –±–æ—é –≤ —à–∞—à–∫–∞—Ö
                                        
                                        const historyStep = { turn: this.currentTurn, prevKingPos: { w: this.kingPos.w ? {...this.kingPos.w} : null, b: this.kingPos.b ? {...this.kingPos.b} : null }, multiJumpSource: null, changes: [], notation: { icon: this.draggedPiece.data.s, start: startCoord, end: endCoord, cap: isCap } };
                                        
                                        const recordState = (col, row) => { const k = this.getKey(col, row); const v = this.grid.get(k); historyStep.changes.push({ key: k, value: v }); };
                                        recordState(this.draggedPiece.startC, this.draggedPiece.startR); recordState(c, r);
                                        if (chosenMove.captured) recordState(chosenMove.captured.x, chosenMove.captured.y); // –ó–∞–ø–∏—Å –≤–∏–¥–∞–ª–µ–Ω–æ—ó —à–∞—à–∫–∏
                                        
                                        this.moveHistory.push(historyStep);
                                        this.updateLogUI();
                                        
                                        // –§—ñ–∑–∏—á–Ω–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è
                                        this.removePiece(this.draggedPiece.startC, this.draggedPiece.startR);
                                        this.draggedPiece.data.x = c; this.draggedPiece.data.y = r; this.draggedPiece.data.hasMoved = true;
                                        this.setPiece(c, r, this.draggedPiece.data);
                                        
                                        // --- –ü–ï–†–ï–í–Ü–†–ö–ê –ú–£–õ–¨–¢–ò-–ë–Ü–ô (–®–ê–®–ö–ò) ---
                                        if (this.checkersSymbols.has(this.draggedPiece.data.s) && chosenMove.isCapture) {
                                            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î —â–µ –±—ñ–π –∑ –ù–û–í–û–á –ø–æ–∑–∏—Ü—ñ—ó
                                            const followUpMoves = this.getCheckersMoves(this.draggedPiece.data, c, r, true); // true = onlyCaptures
                                            if (followUpMoves.length > 0) {
                                                this.multiJumpSource = { c: c, r: r }; // –§—ñ–∫—Å—É—î–º–æ –¥–∂–µ—Ä–µ–ª–æ —Å—Ç—Ä–∏–±–∫—ñ–≤
                                                // –ù–ï –ü–ï–†–ï–î–ê–Ñ–ú–û –•–Ü–î, –æ–Ω–æ–≤–ª—é—î–º–æ UI —ñ –≤–∏—Ö–æ–¥–∏–º–æ
                                                this.isDraggingPiece = false;
                                                this.draggedPiece = null;
                                                this.highlightedMoves = [];
                                                this.updateUI();
                                                return; 
                                            }
                                        }

                                        this.multiJumpSource = null; // –°–∫–∏–¥–∞—î–º–æ —Å–µ—Ä—ñ—é, —è–∫—â–æ –≤–æ–Ω–∞ –∑–∞–∫—ñ–Ω—á–∏–ª–∞—Å—å
                                        setTimeout(() => this.switchTurn(), 0);
                                    }
                                }
                            }
                        }
                    }
                }

                this.isDragging = false;
                this.isDraggingPiece = false;
                this.draggedPiece = null;
                this.highlightedMoves = []; 
                this.updateUI();
            }


            undoMove() {
                if (this.moveHistory.length === 0) return;
                const last = this.moveHistory.pop();

                last.changes.forEach(change => {
                    if (change.value === undefined) this.grid.delete(change.key);
                    else this.grid.set(change.key, change.value);
                });

                this.currentTurn = last.turn;
                this.kingPos = last.prevKingPos;
                this.multiJumpSource = last.multiJumpSource;
                this.gameOver = false;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.highlightedMoves = [];
                this.updateTurnIndicator();
                this.updateUI();
                this.updateLogUI(); // <--- –í–ê–ñ–õ–ò–í–û
            }

            onKeyDown(e) {
                if (this.gameOver || this.turnModeEnabled || this.promotionPending) return;
                if (e.key === 'Delete') {
                    // Default delete key behavior is now Undo via main listener
                } else if (e.shiftKey && e.key === 'Delete') {
                    // Eraser tool
                    const w = this.screenToWorld(this.mouse.x, this.mouse.y);
                    const c = Math.floor(w.x / this.cellSize);
                    const r = Math.floor(w.y / this.cellSize);
                    this.removePiece(c, r);
                    this.updateUI();
                }
            }

            screenToWorld(sx, sy) { return { x: (sx - this.camera.x) / this.camera.zoom, y: (sy - this.camera.y) / this.camera.zoom }; }

            update() {
                // –ö–ª–∞–≤—ñ–∞—Ç—É—Ä–∞ (—Ä—É—Ö–∞—î —Ü—ñ–ª—å)
                const moveSpeed = 15;
                if (this.keys.ArrowLeft) this.targetCamera.x += moveSpeed;
                if (this.keys.ArrowRight) this.targetCamera.x -= moveSpeed;
                if (this.keys.ArrowUp) this.targetCamera.y += moveSpeed;
                if (this.keys.ArrowDown) this.targetCamera.y -= moveSpeed;

                // –Ü–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è (Lerp)
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –æ–¥–∏–Ω —Ñ–∞–∫—Ç–æ—Ä –¥–ª—è –≤—Å—å–æ–≥–æ, —â–æ–± —Ä—É—Ö –±—É–≤ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–º
                const factor = 0.12; 

                // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—ñ–∑–Ω–∏—Ü—é, —â–æ–± –Ω–µ —Ä–∞—Ö—É–≤–∞—Ç–∏ –∑–∞–π–≤–æ–≥–æ (–µ–∫–æ–Ω–æ–º—ñ—è CPU)
                const diffZ = Math.abs(this.targetCamera.zoom - this.camera.zoom);
                const diffX = Math.abs(this.targetCamera.x - this.camera.x);
                const diffY = Math.abs(this.targetCamera.y - this.camera.y);

                // –ü–æ—Ä—ñ–≥ —á—É—Ç–ª–∏–≤–æ—Å—Ç—ñ –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –º–∞—Å—à—Ç–∞–±—É
                const threshold = Math.max(1e-10, this.targetCamera.zoom * 0.0001);

                if (diffZ > threshold || diffX > 1 || diffY > 1) {
                    this.camera.zoom += (this.targetCamera.zoom - this.camera.zoom) * factor;
                    this.camera.x += (this.targetCamera.x - this.camera.x) * factor;
                    this.camera.y += (this.targetCamera.y - this.camera.y) * factor;

                    // –û–Ω–æ–≤–ª–µ–Ω–Ω—è UI
                    if (this.camera.zoom > 0) {
                        document.getElementById('zoomSlider').value = Math.log10(this.camera.zoom);
                    }
                    let disp = Math.round(this.camera.zoom * 100) + '%';
                    if (this.camera.zoom < 0.01) disp = this.camera.zoom.toExponential(2);
                    document.getElementById('zoomDisplay').innerText = disp;
                } else {
                    // "–ü—Ä–∏–º–∞–≥–Ω—ñ—á—É—î–º–æ" –≤ –∫—ñ–Ω—Ü—ñ –∞–Ω—ñ–º–∞—Ü—ñ—ó, —â–æ–± –ø—Ä–∏–±—Ä–∞—Ç–∏ –º—ñ–∫—Ä–æ-—Ç—Ä–µ–º—Ç—ñ–Ω–Ω—è
                    this.camera.zoom = this.targetCamera.zoom;
                    this.camera.x = this.targetCamera.x;
                    this.camera.y = this.targetCamera.y;
                }

                // –û–±–º–µ–∂—É—î–º–æ –∫–∞–º–µ—Ä—É (—â–æ–± –Ω–µ –ø–æ–ª–µ—Ç—ñ–ª–∞ –≤ –∫–æ—Å–º–æ—Å)
                this.clampCamera();
            }

            drawCustomArrows(ctx, cs, bx, by) {
                if (!this.customArrows.length) return;

                ctx.save();
                
                // –°—Ç–∏–ª—å Lichess: –ó–µ–ª–µ–Ω–∏–π, –Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∏–π
                ctx.fillStyle = "rgba(21, 120, 27, 0.85)"; 
                
                // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø—Ä–æ–ø–æ—Ä—Ü—ñ–π —Å—Ç—Ä—ñ–ª–∫–∏ –≤—ñ–¥–Ω–æ—Å–Ω–æ —Ä–æ–∑–º—ñ—Ä—É –∫–ª—ñ—Ç–∏–Ω–∫–∏ (cs)
                const lineWidth = cs * 0.15;  // –¢–æ–≤—â–∏–Ω–∞ —Ö–≤–æ—Å—Ç–∞
                const headLen = cs * 0.35;    // –î–æ–≤–∂–∏–Ω–∞ –≥–æ–ª–æ–≤–∏
                const headWidth = cs * 0.45;  // –®–∏—Ä–∏–Ω–∞ –≥–æ–ª–æ–≤–∏

                this.customArrows.forEach(arrow => {
                    const startX = bx + arrow.sx * cs + cs / 2;
                    const startY = by + arrow.sy * cs + cs / 2;
                    const endX = bx + arrow.ex * cs + cs / 2;
                    const endY = by + arrow.ey * cs + cs / 2;

                    const dx = endX - startX;
                    const dy = endY - startY;
                    const angle = Math.atan2(dy, dx);
                    const len = Math.hypot(dx, dy);

                    // –Ø–∫—â–æ —Å—Ç—Ä—ñ–ª–∫–∞ –∑–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫–∞, –Ω–µ –º–∞–ª—é—î–º–æ
                    if (len < cs * 0.2) return;

                    // –í—ñ–¥—Å—Ç—É–ø –Ω–∞–∑–∞–¥, —â–æ–± –≤—ñ—Å—Ç—Ä—è –±—É–ª–æ —Ç–æ—á–Ω–æ –≤ —Ü–µ–Ω—Ç—Ä—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏,
                    // –∞–ª–µ –≤—ñ–∑—É–∞–ª—å–Ω–æ –Ω–µ –ø–µ—Ä–µ–∫—Ä–∏–≤–∞–ª–æ —Ñ—ñ–≥—É—Ä—É –ø–æ–≤–Ω—ñ—Å—Ç—é (–æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ)
                    const adjustedLen = len - (cs * 0.05);

                    ctx.save();
                    // –ü–µ—Ä–µ–Ω–æ—Å–∏–º–æ —Ü–µ–Ω—Ç—Ä –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —É –ø–æ—á–∞—Ç–æ–∫ —Å—Ç—Ä—ñ–ª–∫–∏ —ñ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ
                    ctx.translate(startX, startY);
                    ctx.rotate(angle);

                    // –ú–∞–ª—é—î–º–æ —Å—Ç—Ä—ñ–ª–∫—É —è–∫ —î–¥–∏–Ω–∏–π –∫–æ–Ω—Ç—É—Ä (—â–æ–± –Ω–µ –±—É–ª–æ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è –∫–æ–ª—å–æ—Ä—ñ–≤)
                    ctx.beginPath();
                    
                    // 1. –ü–æ—á–∞—Ç–æ–∫ —Ö–≤–æ—Å—Ç–∞ (–≤–µ—Ä—Ö)
                    ctx.lineTo(0, -lineWidth / 2);
                    
                    // 2. –ö—ñ–Ω–µ—Ü—å —Ö–≤–æ—Å—Ç–∞ –ø–µ—Ä–µ–¥ –≥–æ–ª–æ–≤–æ—é (–≤–µ—Ä—Ö)
                    ctx.lineTo(adjustedLen - headLen, -lineWidth / 2);
                    
                    // 3. –í–∏—Å—Ç—É–ø –≥–æ–ª–æ–≤–∏ (–≤–µ—Ä—Ö)
                    ctx.lineTo(adjustedLen - headLen, -headWidth / 2);
                    
                    // 4. –í—ñ—Å—Ç—Ä—è
                    ctx.lineTo(adjustedLen, 0);
                    
                    // 5. –í–∏—Å—Ç—É–ø –≥–æ–ª–æ–≤–∏ (–Ω–∏–∑)
                    ctx.lineTo(adjustedLen - headLen, headWidth / 2);
                    
                    // 6. –ö—ñ–Ω–µ—Ü—å —Ö–≤–æ—Å—Ç–∞ –ø–µ—Ä–µ–¥ –≥–æ–ª–æ–≤–æ—é (–Ω–∏–∑)
                    ctx.lineTo(adjustedLen - headLen, lineWidth / 2);
                    
                    // 7. –ü–æ—á–∞—Ç–æ–∫ —Ö–≤–æ—Å—Ç–∞ (–Ω–∏–∑)
                    ctx.lineTo(0, lineWidth / 2);
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                });
                ctx.restore();
            }
            
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width; const height = this.canvas.height;
                const cs = this.cellSize * this.camera.zoom;

                // 1. –û—á–∏—â–µ–Ω–Ω—è
                ctx.fillStyle = this.colors.void;
                ctx.fillRect(0, 0, width, height);

                const bx = this.camera.x; const by = this.camera.y;
                // –ú–µ–∂—ñ –≤–∏–¥–∏–º–æ–≥–æ –µ–∫—Ä–∞–Ω—É (Viewport) –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö —Å—ñ—Ç–∫–∏
                const startCol = Math.floor((-this.camera.x) / cs);
                const endCol = Math.floor((width - this.camera.x) / cs) + 1;
                const startRow = Math.floor((-this.camera.y) / cs);
                const endRow = Math.floor((height - this.camera.y) / cs) + 1;
                
                const boardPixelW = this.boardSize * cs; const boardPixelH = this.boardSize * cs;

                // 2. –ú–∞–ª—é–≤–∞–Ω–Ω—è –¥–æ—à–∫–∏
                if (bx < width && by < height && bx + boardPixelW > 0 && by + boardPixelH > 0) {
                     ctx.fillStyle = this.colors.light;
                     ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), Math.min(boardPixelW, width), Math.min(boardPixelH, height));
                     ctx.fillStyle = this.colors.dark;

                     if (cs > 0.8) {
                         ctx.beginPath();
                         // –ú–∞–ª—é—î–º–æ —Ç—ñ–ª—å–∫–∏ –≤–∏–¥–∏–º—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏
                         const renderStartC = Math.max(0, startCol);
                         const renderEndC = Math.min(this.boardSize, endCol);
                         const renderStartR = Math.max(0, startRow);
                         const renderEndR = Math.min(this.boardSize, endRow);

                         const gridSkip = (cs < 2) ? 2 : 1;
                         for (let r = renderStartR; r < renderEndR; r += gridSkip) {
                             let c = renderStartC;
                             if ((r % 2) !== 0) { if (c % 2 !== 0) c++; } else { if (c % 2 === 0) c++; }
                             for (; c < renderEndC; c += 2) {
                                 ctx.rect((bx + c * cs) | 0, (by + r * cs) | 0, Math.ceil(cs), Math.ceil(cs));
                             }
                         }
                         ctx.fill();
                     } else {
                         ctx.globalAlpha = 0.5;
                         ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), Math.min(boardPixelW, width), Math.min(boardPixelH, height));
                         ctx.globalAlpha = 1.0;
                     }
                     ctx.strokeStyle = this.colors.border;
                     ctx.lineWidth = Math.max(2, cs * 0.1);
                     ctx.strokeRect(bx, by, boardPixelW, boardPixelH);
                }

                // 3. –ü—ñ–¥—Å–≤—ñ—Ç–∫–∞ –®–∞—Ö/–ú–∞—Ç
                if (this.rulesEnabled && cs > 2) {
                    for (const color of ['w', 'b']) {
                        if (this.kingsInCheck[color]) {
                            const k = this.kingsInCheck[color];
                            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∏–¥–Ω–æ –∫–æ—Ä–æ–ª—è
                            if (k.c >= startCol && k.c <= endCol && k.r >= startRow && k.r <= endRow) {
                                ctx.fillStyle = (this.gameOver && this.currentTurn === color) ? this.colors.mateHighlight : this.colors.checkHighlight;
                                ctx.fillRect(bx + k.c * cs, by + k.r * cs, cs, cs);
                            }
                        }
                    }
                }

                // 4. –ü–Ü–î–°–í–Ü–¢–ö–ê –•–û–î–Ü–í (–û–ü–¢–ò–ú–Ü–ó–û–í–ê–ù–ê –î–õ–Ø 1 –ú–õ–†–î)
                if (this.highlightedMoves.length > 0) {
                    // –¢—Ä–æ—Ö–∏ —Ä–æ–∑—à–∏—Ä—é—î–º–æ –º–µ–∂—ñ –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç—ñ
                    const viewMinC = startCol - 1;
                    const viewMaxC = endCol + 1;
                    const viewMinR = startRow - 1;
                    const viewMaxR = endRow + 1;

                    ctx.fillStyle = "rgba(46, 204, 113, 0.8)"; // –ó–µ–ª–µ–Ω–∏–π –¥–ª—è —Ç–æ—á–æ–∫

                    this.highlightedMoves.forEach(move => {
                        // A. –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –æ–∫—Ä–µ–º–∏—Ö —Ç–æ—á–æ–∫ (—Å—Ç—Ä–∏–±–∫–∏, –∞—Ç–∞–∫–∏)
                        if (move.type === 'point') {
                            if (move.c >= viewMinC && move.c <= viewMaxC && move.r >= viewMinR && move.r <= viewMaxR) {
                                const hx = bx + move.c * cs + cs/2;
                                const hy = by + move.r * cs + cs/2;
                                ctx.beginPath();
                                if (move.capture) {
                                    const capSize = Math.max(cs * 0.35, 4);
                                    ctx.fillStyle = "rgba(200, 50, 50, 0.7)";
                                    ctx.arc(hx, hy, capSize, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.fillStyle = "rgba(46, 204, 113, 0.8)"; // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –∑–µ–ª–µ–Ω–∏–π
                                } else {
                                    const dotSize = Math.max(cs * 0.18, 3);
                                    ctx.arc(hx, hy, dotSize, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        } 
                        // B. –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –ø—Ä–æ–º–µ–Ω—ñ–≤ (RAYS) - –ú–∞–≥—ñ—è –¥–ª—è –º—ñ–ª—å—è—Ä–¥—ñ–≤ –∫–ª—ñ—Ç–∏–Ω–æ–∫
                        else if (move.type === 'ray') {
                            // –ú–∏ –º–∞—î–º–æ –ª—ñ–Ω—ñ—é: P = Start + t * Dir, –¥–µ 0 < t <= len
                            // –ù–∞–º —Ç—Ä–µ–±–∞ –∑–Ω–∞–π—Ç–∏ –¥—ñ–∞–ø–∞–∑–æ–Ω T (t_min, t_max), —è–∫–∏–π –ø–æ—Ç—Ä–∞–ø–ª—è—î —É Viewport.

                            let tMin = 1;         // –ü–æ—á–∏–Ω–∞—î–º–æ –∑ 1 (–Ω–∞—Å—Ç—É–ø–Ω–∞ –∫–ª—ñ—Ç–∏–Ω–∫–∞)
                            let tMax = move.len;  // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –¥–æ–≤–∂–∏–Ω–∞ —Ö–æ–¥—É

                            // –í—ñ–¥—Å—ñ–∫–∞–Ω–Ω—è –ø–æ X
                            if (move.dx > 0) {
                                tMin = Math.max(tMin, viewMinC - move.cx);
                                tMax = Math.min(tMax, viewMaxC - move.cx);
                            } else if (move.dx < 0) {
                                tMin = Math.max(tMin, move.cx - viewMaxC);
                                tMax = Math.min(tMax, move.cx - viewMinC);
                            } else {
                                // –Ø–∫—â–æ —Ä—É—Ö –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏–π, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ X –≤ –º–µ–∂–∞—Ö –µ–∫—Ä–∞–Ω—É
                                if (move.cx < viewMinC || move.cx > viewMaxC) return; // –ü—Ä–æ–º—ñ–Ω—å –∑–∞ –º–µ–∂–∞–º–∏ –µ–∫—Ä–∞–Ω—É –ø–æ X
                            }

                            // –í—ñ–¥—Å—ñ–∫–∞–Ω–Ω—è –ø–æ Y
                            if (move.dy > 0) {
                                tMin = Math.max(tMin, viewMinR - move.cy);
                                tMax = Math.min(tMax, viewMaxR - move.cy);
                            } else if (move.dy < 0) {
                                tMin = Math.max(tMin, move.cy - viewMaxR);
                                tMax = Math.min(tMax, move.cy - viewMinR);
                            } else {
                                // –Ø–∫—â–æ —Ä—É—Ö –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∏–π, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ Y –≤ –º–µ–∂–∞—Ö –µ–∫—Ä–∞–Ω—É
                                if (move.cy < viewMinR || move.cy > viewMaxR) return; // –ü—Ä–æ–º—ñ–Ω—å –∑–∞ –º–µ–∂–∞–º–∏ –µ–∫—Ä–∞–Ω—É –ø–æ Y
                            }

                            // –Ø–∫—â–æ —î –ø–µ—Ä–µ—Ç–∏–Ω (–≤–∏–¥–∏–º–∏–π –≤—ñ–¥—Ä—ñ–∑–æ–∫)
                            if (tMin <= tMax) {
                                // –¶–∏–∫–ª —Ç—ñ–ª—å–∫–∏ –ø–æ –í–ò–î–ò–ú–ò–• –∫–ª—ñ—Ç–∏–Ω–∫–∞—Ö (–∑–∞–∑–≤–∏—á–∞–π 20-50 —ñ—Ç–µ—Ä–∞—Ü—ñ–π, –Ω–∞–≤—ñ—Ç—å —è–∫—â–æ —Ö—ñ–¥ –Ω–∞ –º—ñ–ª—å—è—Ä–¥)
                                for (let t = tMin; t <= tMax; t++) {
                                    const gridX = move.cx + t * move.dx;
                                    const gridY = move.cy + t * move.dy;
                                    
                                    const hx = bx + gridX * cs + cs/2;
                                    const hy = by + gridY * cs + cs/2;
                                    
                                    const dotSize = Math.max(cs * 0.18, 3);
                                    
                                    ctx.beginPath();
                                    ctx.arc(hx, hy, dotSize, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        }
                    });
                }

                // 5. –¢–µ–∫—Å—Ç —ñ –°—Ç—Ä—ñ–ª–∫–∏
                if (cs > 5) this.drawCustomArrows(ctx, cs, bx, by);
                if (cs > 25) {
                    const fontSize = Math.max(cs * 0.25, 12); ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; const labelX = bx - 5;
                    const rStart = Math.max(0, startRow); const rEnd = Math.min(this.boardSize, endRow);
                    for(let r = rStart; r < rEnd; r++) {
                        const rankVal = this.boardSize - r; const labelY = by + r*cs + cs/2;
                        if(labelY > 0 && labelY < height) { ctx.fillStyle = '#ccc'; ctx.fillText(rankVal.toString(), labelX, labelY); }
                    }
                    ctx.textAlign = 'center'; ctx.textBaseline = 'top'; const labelYBottom = by + this.boardSize*cs + 5;
                    const cStart = Math.max(0, startCol); const cEnd = Math.min(this.boardSize, endCol);
                    for(let c = cStart; c < cEnd; c++) {
                        const labelXPos = bx + c*cs + cs/2;
                        if(labelXPos > 0 && labelXPos < width) { ctx.fillStyle = '#ccc'; ctx.fillText(this.getFileLabel(c), labelXPos, labelYBottom); }
                    }
                }

                // 6. –§—ñ–≥—É—Ä–∏
                const visibleCellsW = endCol - startCol;
                const visibleCellsH = endRow - startRow;
                const totalVisible = visibleCellsW * visibleCellsH;
                let skip = 1;
                // –ê–¥–∞–ø—Ç–∏–≤–Ω–∏–π –ø—Ä–æ–ø—É—Å–∫ –ø—Ä–∏ —Å–∏–ª—å–Ω–æ–º—É –≤—ñ–¥–¥–∞–ª–µ–Ω–Ω—ñ, —â–æ–± –Ω–µ –º–∞–ª—é–≤–∞—Ç–∏ —Ç–∏—Å—è—á—ñ —ñ–∫–æ–Ω–æ–∫ –≤ –æ–¥–Ω—ñ–π —Ç–æ—á—Ü—ñ
                if (totalVisible > 50000) skip = Math.ceil(Math.sqrt(totalVisible / 50000));
                
                const minDrawSize = 12;
                const drawSize = Math.max(cs, minDrawSize);

                const renderStartC = Math.max(0, startCol);
                const renderEndC = Math.min(this.boardSize, endCol);
                const renderStartR = Math.max(0, startRow);
                const renderEndR = Math.min(this.boardSize, endRow);

                for (let r = renderStartR; r < renderEndR; r += skip) {
                    for (let c = renderStartC; c < renderEndC; c += skip) {
                        if (this.isDraggingPiece && this.draggedPiece && this.draggedPiece.startC === c && this.draggedPiece.startR === r) continue;
                        const piece = this.getPiece(c, r);
                        if (!piece) continue;
                        const px = (bx + c * cs + cs/2) | 0;
                        const py = (by + r * cs + cs/2) | 0;
                        const sprite = this.getLowResSprite(piece.s, piece.c);
                        ctx.drawImage(sprite, px - drawSize/2, py - drawSize/2, drawSize, drawSize);
                    }
                }

                if (this.isDraggingPiece && this.draggedPiece) {
                    this.drawPiece(ctx, this.draggedPiece.data, this.mouse.x | 0, this.mouse.y | 0, Math.max(cs, 40));
                }
            }

            drawPiece(ctx, pieceData, x, y, size) {
                const sprite = this.getPieceSprite(pieceData.s, pieceData.c);
                const drawSize = size * 0.85;
                ctx.drawImage(sprite, (x - drawSize/2) | 0, (y - drawSize/2) | 0, drawSize | 0, drawSize | 0);
            }

            formatCount(n) {
                if (!isFinite(n)) return "–ù–µ—Å–∫—ñ–Ω—á–µ–Ω–Ω—ñ—Å—Ç—å";
                if (n < 1000) return n;

                // --- –ï—Ç–∞–ø 1: –°–∫–æ—Ä–æ—á–µ–Ω–Ω—è –¥–ª—è "–º–∞–ª–∏—Ö" –≤–µ–ª–∏–∫–∏—Ö —á–∏—Å–µ–ª ---
                // (–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞–≥–∞–ª—å–Ω–æ–ø—Ä–∏–π–Ω—è—Ç—ñ –∞–±—Ä–µ–≤—ñ–∞—Ç—É—Ä–∏)
                if (n < 1e12) {
                    if (n >= 1e9) return (n / 1e9).toFixed(2) + " –º–ª—Ä–¥";
                    if (n >= 1e6) return (n / 1e6).toFixed(2) + " –º–ª–Ω";
                    return (n / 1000).toFixed(1) + " —Ç–∏—Å.";
                }

                // --- –ï—Ç–∞–ø 2: –ü–æ–≤–Ω—ñ –Ω–∞–∑–≤–∏ –≤—ñ–¥ –¢—Ä–∏–ª—å–π–æ–Ω–∞ ---
                
                // –í–∏–∑–Ω–∞—á–∞—î–º–æ –ø–æ—Ä—è–¥–æ–∫ —á–∏—Å–ª–∞
                let exp = Math.floor(Math.log10(n) / 3);

                // –ë–∞–∑–æ–≤–∏–π —Å–ø–∏—Å–æ–∫ –ø–æ–≤–Ω–∏—Ö –Ω–∞–∑–≤ (–¥–æ –î–µ—Ü–∏–ª—å–π–æ–Ω–∞ –≤–∫–ª—é—á–Ω–æ)
                // –Ü–Ω–¥–µ–∫—Å–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å —Å—Ç–µ–ø–µ–Ω—è–º: 3->—Ç–∏—Å, 4->—Ç—Ä–ª–Ω —ñ —Ç.–¥.
                // –ù–∞–º –ø–æ—Ç—Ä—ñ–±–Ω—ñ —ñ–Ω–¥–µ–∫—Å–∏ –≤—ñ–¥ 4 (10^12)
                const fullNames = [
                    "", "", "", "", // 0-3 –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ (—Ç–∞–º —Ç–∏—Å, –º–ª–Ω, –º–ª—Ä–¥)
                    " —Ç—Ä–∏–ª—å–π–æ–Ω—ñ–≤",      // 4 (10^12)
                    " –∫–≤–∞–¥—Ä–∏–ª—å–π–æ–Ω—ñ–≤",   // 5 (10^15)
                    " –∫–≤—ñ–Ω—Ç–∏–ª—å–π–æ–Ω—ñ–≤",   // 6 (10^18)
                    " —Å–µ–∫—Å—Ç–∏–ª—å–π–æ–Ω—ñ–≤",   // 7 (10^21)
                    " —Å–µ–ø—Ç–∏–ª—å–π–æ–Ω—ñ–≤",    // 8 (10^24)
                    " –æ–∫—Ç–∏–ª—å–π–æ–Ω—ñ–≤",     // 9 (10^27)
                    " –Ω–æ–Ω—ñ–ª—å–π–æ–Ω—ñ–≤",     // 10 (10^30)
                    " –¥–µ—Ü–∏–ª—å–π–æ–Ω—ñ–≤"      // 11 (10^33)
                ];

                if (exp < fullNames.length) {
                    return (n / Math.pow(10, exp * 3)).toFixed(2) + fullNames[exp];
                }

                // --- –ï—Ç–∞–ø 3: –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–∫–ª–∞–¥–Ω–∏—Ö –Ω–∞–∑–≤ (–ø—ñ—Å–ª—è –î–µ—Ü–∏–ª—å–π–æ–Ω–∞) ---
                // –§–æ—Ä–º—É–ª–∞: [–ü—Ä–µ—Ñ—ñ–∫—Å –æ–¥–∏–Ω–∏—Ü—å] + [–ö–æ—Ä—ñ–Ω—å –¥–µ—Å—è—Ç–∫—ñ–≤] + "—ñ–ª—å–π–æ–Ω—ñ–≤"
                
                const units = ["", "–£–Ω", "–î—É–æ", "–¢—Ä–µ", "–ö–≤–∞—Ç—É–æ—Ä", "–ö–≤—ñ–Ω", "–°–µ–∫—Å", "–°–µ–ø—Ç–µ–Ω", "–û–∫—Ç–æ", "–ù–æ–≤–µ–º"];
                const tens = ["", "–î–µ—Ü", "–í—ñ–≥—ñ–Ω—Ç", "–¢—Ä–∏–≥—ñ–Ω—Ç", "–ö–≤–∞–¥—Ä–∞–≥—ñ–Ω—Ç", "–ö–≤—ñ–Ω–∫–≤–∞–≥—ñ–Ω—Ç", "–°–µ–∫—Å–∞–≥—ñ–Ω—Ç", "–°–µ–ø—Ç—É–∞–≥—ñ–Ω—Ç", "–û–∫—Ç–æ–≥—ñ–Ω—Ç", "–ù–æ–Ω–∞–≥—ñ–Ω—Ç"];

                // –ö–æ—Ä–µ–∫—Ü—ñ—è —ñ–Ω–¥–µ–∫—Å—É
                let idx = exp - 1; 
                const unitIdx = idx % 10;
                const tenIdx = Math.floor(idx / 10);

                // –û—Å—Ç–∞–Ω–Ω—î —á–∏—Å–ª–æ - –¶–µ–Ω—Ç—ñ–ª—å–π–æ–Ω
                if (tenIdx >= 10) return (n / 1e303).toFixed(2) + " –¶–µ–Ω—Ç—ñ–ª—å–π–æ–Ω—ñ–≤";

                // –°–∫–ª–µ—é—î–º–æ: –Ω–∞–ø—Ä–∏–∫–ª–∞–¥ "–£–Ω" + "–î–µ—Ü" + "—ñ–ª—å–π–æ–Ω—ñ–≤"
                const suffix = " " + units[unitIdx] + tens[tenIdx] + "—ñ–ª—å–π–æ–Ω—ñ–≤";

                return (n / Math.pow(10, exp * 3)).toFixed(2) + suffix;
            }

            updatePieceCounts() {
                let w = 0, b = 0;

                // 1. –ë–ê–ó–û–í–ò–ô –ü–Ü–î–†–ê–•–£–ù–û–ö (–î–ª—è –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–∏—Ö/–ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–∏—Ö –¥–æ—à–æ–∫)
                if (this.virtualGen) {
                    let rows = 0;
                    if (this.virtualGen === 'chess960') {
                        rows = 2; 
                    } else {
                        rows = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                        if (this.virtualGen !== 'checkers' && rows < 2) rows = 2;
                    }
                    
                    let totalBase = this.boardSize * rows; 
                    
                    if (this.virtualGen === 'checkers') {
                        totalBase = Math.floor(totalBase / 2);
                    }

                    w = totalBase;
                    b = totalBase;
                }

                // 2. –ö–û–†–ï–ö–¶–Ü–Ø –ù–ê –û–°–ù–û–í–Ü –ó–ú–Ü–ù (GRID)
                for (const [key, val] of this.grid) {
                    const [cx, cy] = key.split(',').map(Number);

                    if (this.virtualGen) {
                        let rows = 0;
                        if (this.virtualGen === 'chess960') rows = 2;
                        else {
                            rows = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                            if (this.virtualGen !== 'checkers' && rows < 2) rows = 2;
                        }

                        if (cy < rows) {
                            if (this.virtualGen !== 'checkers' || this.isDarkSquare(cx, cy)) {
                                b--; 
                            }
                        }
                        else if (cy >= this.boardSize - rows) {
                            if (this.virtualGen !== 'checkers' || this.isDarkSquare(cx, cy)) {
                                w--;
                            }
                        }
                    }

                    if (val !== GRID_VOID) {
                        const id = val & 0xFFFF;
                        const p = this.palette[id - 1];
                        if (p.c === 'w') w++;
                        else if (p.c === 'b') b++;
                    }
                }

                // --- 3. –ù–û–í–ò–ô –í–ò–í–Ü–î –í HTML (–ó –¢–û–ß–ù–û–Æ –ö–Ü–õ–¨–ö–Ü–°–¢–Æ) ---
                
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ BigInt, —â–æ–± —á–∏—Å–ª–æ –Ω–µ –≤—Ç—Ä–∞—á–∞–ª–æ —Ç–æ—á–Ω—ñ—Å—Ç—å –Ω–∞ –¥–æ—à–∫–∞—Ö 1M x 1M
                const totalSquaresBig = BigInt(this.boardSize) * BigInt(this.boardSize);
                
                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤–∞—à–µ —Å–∫–æ—Ä–æ—á–µ–Ω–Ω—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ "1 –º–ª–Ω")
                const shortStr = this.formatCount(Number(totalSquaresBig));
                
                // –ì–µ–Ω–µ—Ä—É—î–º–æ —Ç–æ—á–Ω–µ —á–∏—Å–ª–æ –∑ –ø—Ä–æ–±—ñ–ª–∞–º–∏ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ "1 000 000")
                const exactStr = totalSquaresBig.toLocaleString('uk-UA');

                // –§–æ—Ä–º—É—î–º–æ —Ä—è–¥–æ–∫: —è–∫—â–æ —á–∏—Å–ª–æ –≤–µ–ª–∏–∫–µ (>999), –ø–æ–∫–∞–∑—É—î–º–æ [—Ç–æ—á–Ω–µ] –ø–æ—Ä—É—á
                let countDisplay = shortStr;
                if (totalSquaresBig > 999n) {
                    countDisplay = `${shortStr} <span style="font-size:0.85em; color:#555; font-weight:normal;">[${exactStr}]</span>`;
                } else {
                    countDisplay = exactStr;
                }

                const boardInfo = `${this.boardSize}x${this.boardSize}, ${countDisplay}`;

                const html = `
                    <div style="margin-bottom: 4px; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 4px; font-size: 13px; color: #333;">
                        üìè –ö–ª—ñ—Ç–∏–Ω–∫–∏: <b>(${boardInfo})</b>
                    </div>
                    <span style="color:#555; font-weight:bold;">–§—ñ–≥—É—Ä: ${this.formatCount(w+b)}</span> 
                    (<span style="color:#27ae60">–ë: ${this.formatCount(w)}</span> | 
                    <span style="color:#c0392b">–ß: ${this.formatCount(b)}</span>)
                `;
                document.getElementById('count').innerHTML = html;
            }

            updateUI() {
                // –í–∏–∫–ª–∏–∫–∞—î–º–æ –Ω–∞—à—É –Ω–æ–≤—É —Ñ—É–Ω–∫—Ü—ñ—é –ø—ñ–¥—Ä–∞—Ö—É–Ω–∫—É
                this.updatePieceCounts();
            }

            animate() {
                const now = performance.now();
                if (Math.random() < 0.05) document.getElementById('fps').innerText = Math.round(1000 / (now - this.renderTime || 16));
                this.renderTime = now;
                this.update();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }

        const game = new SmoothChess();
    </script>
</body>
</html>