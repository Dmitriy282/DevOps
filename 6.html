<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mega Chess: Color Fix</title>
    <style>
        /* --- STYLES --- */
        body { margin: 0; padding: 0; overflow: hidden; font-family: "Segoe UI", Arial, sans-serif; background: #eeeed2; user-select: none; }
        #canvas { display: block; cursor: grab; }
        #canvas:active { cursor: grabbing; }

        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.94);
            padding: 12px; border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            width: 380px;
            max-height: 95vh;
            overflow-y: auto;
            backdrop-filter: blur(8px); z-index: 10;
            transition: opacity 0.3s;
            display: flex; flex-direction: column; gap: 10px;
        }
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 4px; }
        #controls::-webkit-scrollbar-thumb { background: #bbb; border-radius: 4px; }

        #turnIndicator {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px);
            color: #333; padding: 8px 25px; border-radius: 50px; font-size: 20px;
            font-weight: bold; border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); 
            /* Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾: Ñ€Ğ¾Ğ±Ğ¸Ğ¼Ğ¾ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ ĞºĞ»Ñ–ĞºĞ°Ğ±ĞµĞ»ÑŒĞ½Ğ¾Ñ Ñ– Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… Ğ²ÑÑŒĞ¾Ğ³Ğ¾ */
            pointer-events: auto; 
            cursor: pointer; 
            user-select: none;
            display: flex; align-items: center; gap: 10px; transition: 0.2s; 
            z-index: 20; /* ĞŸÑ–Ğ´Ğ½ÑĞ»Ğ¸ Ğ²Ğ¸Ñ‰Ğµ Ğ¼ĞµĞ½Ñ */
        }
        #turnIndicator:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }
        #turnIndicator:active {
            transform: translateX(-50%) scale(0.95);
        }
        /* ĞŸÑ–Ğ´ĞºĞ°Ğ·ĞºĞ° */
        #turnIndicator::after {
            content: "â‡„";
            font-size: 18px;
            margin-left: 5px;
            opacity: 0.5;
        }

        #loadingOverlay {
            position: absolute; bottom: 20px; right: 20px; width: 300px;
            background: rgba(0,0,0,0.8); display: none; padding: 15px; border-radius: 10px;
            flex-direction: column; justify-content: center; align-items: flex-start;
            z-index: 200; color: white; backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        .progress-bar { width: 100%; height: 6px; background: #444; border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.1s; }

        /* --- PROMOTION OVERLAY STYLES --- */
        #promotionOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center;
            z-index: 150; backdrop-filter: blur(8px); animation: fadeIn 0.3s;
        }
        .promo-card {
            background: white; padding: 25px; border-radius: 16px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 2px solid #3498db;
            width: 500px; max-height: 80vh; display: flex; flex-direction: column;
            animation: popIn 0.3s forwards;
        }
        .promo-header { font-size: 24px; margin-bottom: 15px; color: #2c3e50; font-weight: bold; }
        .promo-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 8px;
            overflow-y: auto; padding: 10px; border: 1px solid #eee; border-radius: 8px; background: #f9f9f9;
        }

        .promo-btn {
            font-size: 30px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
            padding: 5px;
            color: #000 !important;
            line-height: 1;
        }
        .promo-btn:hover { background: #e3f2fd; transform: scale(1.1); border-color: #3498db; }

        #gameOverOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center;
            z-index: 100; backdrop-filter: blur(5px); animation: fadeIn 0.5s;
        }
        .victory-card {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 4px solid #f1c40f;
            min-width: 300px; transform: scale(0.9); animation: popIn 0.3s forwards;
        }
        .victory-card h1 { margin: 0; color: #e74c3c; font-size: 48px; text-transform: uppercase; }
        .victory-card h2 { margin: 10px 0 30px 0; color: #2c3e50; font-size: 24px; }
        .victory-card .winner-icon { font-size: 60px; margin: 10px 0; display: block; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes popIn { to { transform: scale(1); } }

        h3 { margin: 0 0 5px 0; color: #2c3e50; font-size: 18px; border-bottom: 1px solid #ddd; padding-bottom: 8px; }
        .control-group { margin-bottom: 5px; }
        label { display: block; margin-bottom: 4px; font-size: 12px; font-weight: 700; color: #555; text-transform: uppercase; }
        input, button { width: 100%; padding: 6px; box-sizing: border-box; border-radius: 6px; border: 1px solid #ccc; font-size: 13px; }

        .btn-row { display: flex; gap: 4px; margin-top: 4px; }
        button { background: #769656; color: white; border: none; cursor: pointer; font-weight: 600; transition: 0.1s; }
        button:hover { background: #5d7c40; transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        button.secondary { background: #9ca3af; }
        button.secondary:hover { background: #6b7280; }
        button.danger { background: #e74c3c; }
        button.danger:hover { background: #c0392b; }
        button.action { background: #f39c12; }
        button.action:hover { background: #d35400; }
        button.checkers { background: #8e44ad; }
        button.checkers:hover { background: #732d91; }
        button.classic { background: #3498db; }
        button.classic:hover { background: #2980b9; }
        button.undo-btn { background: #555; }
        button.undo-btn:hover { background: #333; }

        /* --- LOG STYLES --- */
         #logContainer {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-top: 5px;
            height: 140px;
            overflow-y: auto;
            position: relative;
        }
        #logContainer::-webkit-scrollbar { width: 6px; }
        #logContainer::-webkit-scrollbar-thumb { background: #ccc; }

        #logTable {
            width: 100%;
            border-collapse: collapse;
            font-family: "Segoe UI Mono", monospace;
            font-size: 12px;
            table-layout: fixed;
        }
        #logTable th {
            position: sticky; top: 0;
            background: #e0e0e0;
            color: #555;
            padding: 4px;
            font-size: 11px;
            z-index: 2;
            text-align: center;
            border-bottom: 1px solid #ccc;
        }
        #logTable td {
            padding: 3px 5px;
            border-bottom: 1px solid #f0f0f0;
            color: #333;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }
        #logTable tr:nth-child(even) { background: #f9f9f9; }
        
        .log-num { width: 30px; color: #999; font-weight: bold; border-right: 1px solid #eee; background: #fafafa; }
        .move-icon { font-weight: bold; color: #2c3e50; margin-right: 2px; }
        .move-cap { color: #c0392b; font-weight: bold; margin-left: 2px; font-size: 10px; }
        .move-coords { color: #444; }

        .piece-container { display: flex; flex-direction: column; gap: 8px; }
        .category-block { background: rgba(0,0,0,0.03); border-radius: 6px; padding: 6px; border: 1px solid rgba(0,0,0,0.05); }
        .grid-header { font-size: 11px; font-weight: bold; text-transform: uppercase; color: #666; margin-bottom: 4px; text-align: center; background: #e0e0e0; border-radius: 3px; padding: 2px; }
        .piece-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; }
        .piece-btn { aspect-ratio: 1; padding: 0; font-size: 22px; background: #fff; color: #333; border: 1px solid #ccc; cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: transform 0.1s, background 0.1s; }
        .piece-btn:hover { background: #fff; transform: scale(1.15); z-index: 5; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .piece-btn.selected { background: #769656; color: white; border-color: #4b6334; box-shadow: inset 0 0 5px rgba(0,0,0,0.3); }
        .piece-btn.eraser { 
            background: #ffebee; 
            color: #c0392b; 
            border-color: #e74c3c; 
            font-size: 22px; /* Ğ—Ğ±Ñ–Ğ»ÑŒÑˆĞ¸Ğ¼Ğ¾ Ñ–ĞºĞ¾Ğ½ĞºÑƒ */
            font-weight: bold;
        }
        .piece-btn.eraser:hover {
            background: #ffcdd2;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        .piece-btn.black-piece { background: #333; color: #eee; border-color: #000; }
        .piece-btn.black-piece:hover { background: #555; }

        .info-panel { margin-top: 10px; padding: 8px; background: rgba(241, 242, 246, 0.8); border-radius: 6px; font-size: 12px; color: #555; text-align: center;}
        #debug { position: absolute; top: 10px; right: 10px; color: #555; background: rgba(255,255,255,0.5); padding: 5px 10px; border-radius: 4px; font-family: monospace; pointer-events: none; z-index: 5; }

        .input-row { display: flex; gap: 5px; align-items: center; justify-content: space-between; margin-bottom: 5px;}
        .input-row input[type="number"] { width: 60px; }
        .input-row span { font-size: 12px; font-weight: bold; }
        input[type=range] { padding: 0; margin: 5px 0; }
        .separator { border-top: 1px dashed #ccc; margin: 5px 0; }
        .gen-panel { background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; border: 1px solid rgba(0,0,0,0.1); }

        #opt-warning { color: #d35400; font-weight: bold; display: none; margin-top: 5px; font-size: 11px; text-align: center;}
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="loadingOverlay">
        <strong id="loadingText">Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ ÑĞ²Ñ–Ñ‚Ñƒ...</strong>
        <div class="progress-bar">
            <div id="loadingProgress" class="progress-fill"></div>
        </div>
        <div style="font-size: 10px; margin-top: 5px; color: #ccc">ĞĞ¿Ñ‚Ğ¸Ğ¼Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ...</div>
    </div>

    <!-- PROMOTION OVERLAY -->
    <div id="promotionOverlay">
        <div class="promo-card">
            <div class="promo-header">âœ¨ ĞĞ±ĞµÑ€Ñ–Ñ‚ÑŒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ âœ¨</div>
            <div id="promotionGrid" class="promo-grid">
                <!-- Buttons will be injected here -->
            </div>
            <div style="margin-top:10px; font-size:12px; color:#777;">ĞĞ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ Ğ½Ğ° Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ</div>
        </div>
    </div>

    <div id="turnIndicator">
        <span id="turnIcon" style="font-size: 30px;">â™”</span>
        <span id="turnText">Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ–</span>
    </div>

    <div id="gameOverOverlay">
        <div class="victory-card">
            <h1>ĞœĞĞ¢!</h1>
            <span class="winner-icon" id="winnerIcon">ğŸ†</span>
            <h2 id="winnerTxt">ĞŸĞµÑ€ĞµĞ¼Ğ¾Ğ³Ğ° Ğ‘Ñ–Ğ»Ğ¸Ñ…</h2>
            <button class="action" onclick="game.resetGame()">ğŸ”„ ĞĞ¾Ğ²Ğ° Ğ³Ñ€Ğ°</button>
        </div>
    </div>

    <div id="controls">
        <h3>ğŸš€ Mega Chess: Unlimited</h3>

        <div class="control-group">
            <label>Ğ Ğ¾Ğ·Ğ¼Ñ–Ñ€ Ğ´Ğ¾ÑˆĞºĞ¸:</label>
            <input type="text" id="boardSize" value="32" placeholder="Ğ Ğ¾Ğ·Ğ¼Ñ–Ñ€..." oninput="game.setSize(this.value)">
            <div class="btn-row">
                <button class="secondary" onclick="game.setSize(100)">100</button>
                <button class="secondary" onclick="game.setSize(1000)">1K</button>
                <button class="secondary" onclick="game.setSize(50000)">50K</button>
                <button class="secondary" onclick="game.setSize(1000000)">1M</button>
            </div>
        </div>

        <div class="control-group gen-panel">
             <label>âš”ï¸ Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ:</label>
             <div class="input-row">
                 <span>Ğ—Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½Ñ (%):</span>
                 <input type="number" id="fillPercent" value="25" min="1" max="50">
             </div>
             <div class="input-row">
                <span>Ğ¤ĞµĞ½Ñ‚ĞµĞ·Ñ– %:</span>
                <span id="fantasyPercentDisplay">40%</span>
             </div>
             <input type="range" id="fantasyMix" min="0" max="100" value="40" step="10">

             <div class="btn-row">
                 <button class="classic" onclick="game.fillClassic()">â™Ÿï¸ ĞšĞ»Ğ°Ñ.</button>
                 <button class="classic" onclick="game.fillChess960()">ğŸ² 960</button>
                 <button class="danger" onclick="game.fillArmy()">âš”ï¸ ĞÑ€Ğ¼Ñ–Ñ</button>
                 <button class="action" onclick="game.fillFantasy()">ğŸ² ĞœÑ–ĞºÑ</button>
                 <button class="checkers" onclick="game.fillCheckers()">âšªâš« Ğ¨Ğ°ÑˆĞºĞ¸</button>
             </div>

        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>Ğ ĞµĞ¶Ğ¸Ğ¼Ğ¸:</label>
             <div class="btn-row">
                 <button class="undo-btn" onclick="game.undoMove()">â†©ï¸ ĞĞ°Ğ·Ğ°Ğ´ (Del)</button>
                 <button id="rulesBtn" onclick="game.toggleRules()">ğŸŸ¢ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°</button>
             </div>
             <div class="btn-row">
                 <button id="turnBtn" onclick="game.toggleTurnMode()">ğŸŸ¢ Ğ¥Ñ–Ğ´ (Ğ’ĞšĞ›)</button>
             </div>
        </div>

        <div class="control-group">
            <label>ğŸ“œ Ğ—Ğ°Ğ¿Ğ¸Ñ Ñ…Ğ¾Ğ´Ñ–Ğ²:</label>
            <div id="logContainer">
                <table id="logTable">
                    <thead>
                        <tr>
                            <th class="log-num">#</th>
                            <th>Ğ‘Ñ–Ğ»Ñ–</th>
                            <th>Ğ§Ğ¾Ñ€Ğ½Ñ–</th>
                        </tr>
                    </thead>
                    <tbody id="logTableBody">
                        <!-- Ğ¥Ğ¾Ğ´Ğ¸ Ğ±ÑƒĞ´ÑƒÑ‚ÑŒ Ñ‚ÑƒÑ‚ -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>ğŸ¨ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ (Ğ’ÑÑ– Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸):</label>
             <div id="pieceContainer" class="piece-container"></div>
        </div>

        <div class="separator"></div>

        <div class="control-group">
             <label>ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±: <span id="zoomDisplay">100%</span></label>
             <input type="range" id="zoomSlider" min="-3" max="2" step="0.01">
        </div>
        <div class="separator"></div>
        <div class="control-group">
            <label>ğŸ’¾ Ğ¤Ğ°Ğ¹Ğ» Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ—:</label>
            <div class="btn-row">
                <button class="action" onclick="game.saveGame()">ğŸ“¥ Ğ—Ğ±ĞµÑ€ĞµĞ³Ñ‚Ğ¸ (.json)</button>
                <button class="classic" onclick="document.getElementById('fileInput').click()">ğŸ“‚ Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸</button>
                <!-- ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ñ–Ğ½Ğ¿ÑƒÑ‚ Ğ´Ğ»Ñ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ -->
                <input type="file" id="fileInput" style="display:none" accept=".json" onchange="game.loadGame(this)">
            </div>
        </div>
        <div class="btn-row">
            <button onclick="game.centerBoard()">ğŸ  Ğ¦ĞµĞ½Ñ‚Ñ€</button>
            <button class="danger" onclick="game.clear()">ğŸ—‘ï¸ ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚Ğ¸</button>
        </div>

        <div class="info-panel">
            <span id="coord" style="font-weight:bold; margin-right: 10px">-</span>
            <span id="count"></span>
        </div>
    </div>

    <div id="debug">FPS: <span id="fps">60</span></div>

    <script>
        const PIECE_CATEGORIES = [
            { name: "Ğ†Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¸", bg: "#fff", items: [{ s: 'âŒ', t: 'Ğ“ÑƒĞ¼ĞºĞ°', c: 'eraser' }] },
            { name: "ĞšĞ»Ğ°ÑĞ¸ĞºĞ° (Ğ‘Ñ–Ğ»Ñ–)", bg: "#f0f0f0", items: [{s:'â™”',t:'ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ'}, {s:'â™•',t:'Ğ¤ĞµÑ€Ğ·ÑŒ'}, {s:'â™–',t:'Ğ¢ÑƒÑ€Ğ°'}, {s:'â™—',t:'Ğ¡Ğ»Ğ¾Ğ½'}, {s:'â™˜',t:'ĞšÑ–Ğ½ÑŒ'}, {s:'â™™',t:'ĞŸÑ–ÑˆĞ°Ğº'}] },
            { name: "ĞšĞ»Ğ°ÑĞ¸ĞºĞ° (Ğ§Ğ¾Ñ€Ğ½Ñ–)", bg: "#ddd", items: [{s:'â™š',t:'ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ', cls:'black-piece', color:'b'}, {s:'â™›',t:'Ğ¤ĞµÑ€Ğ·ÑŒ', cls:'black-piece', color:'b'}, {s:'â™œ',t:'Ğ¢ÑƒÑ€Ğ°', cls:'black-piece', color:'b'}, {s:'â™',t:'Ğ¡Ğ»Ğ¾Ğ½', cls:'black-piece', color:'b'}, {s:'â™',t:'ĞšÑ–Ğ½ÑŒ', cls:'black-piece', color:'b'}, {s:'â™Ÿ',t:'ĞŸÑ–ÑˆĞ°Ğº', cls:'black-piece', color:'b'}] },
            { name: "Ğ¨Ğ°ÑˆĞºĞ¸", bg: "#e0e0e0", items: [{s:'â›€',t:'Ğ‘Ñ–Ğ»Ğ° ÑˆĞ°ÑˆĞºĞ°', color:'w'}, {s:'â›',t:'Ğ‘Ñ–Ğ»Ğ° Ğ´Ğ°Ğ¼ĞºĞ°', color:'w'}, {s:'â›‚',t:'Ğ§Ğ¾Ñ€Ğ½Ğ° ÑˆĞ°ÑˆĞºĞ°', color:'b', cls:'black-piece'}, {s:'â›ƒ',t:'Ğ§Ğ¾Ñ€Ğ½Ğ° Ğ´Ğ°Ğ¼ĞºĞ°', color:'b', cls:'black-piece'}] },
            { name: "Mega: Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ğ¸", bg: "#e8daef", items: [{s:'ğŸš€',t:'Ğ Ğ°ĞºĞµÑ‚Ğ°'}, {s:'âš“',t:'Ğ¯ĞºÑ–Ñ€'}, {s:'ğŸ¹',t:'Ğ›ÑƒĞº'}, {s:'ğŸ£',t:'Ğ’ÑƒĞ´ĞºĞ°'}, {s:'ğŸ§œ',t:'Ğ ÑƒÑĞ°Ğ»ĞºĞ°'}, {s:'âš¡',t:'Ğ‘Ğ»Ğ¸ÑĞºĞ°Ğ²ĞºĞ°'}, {s:'ğŸ”±',t:'Ğ¢Ñ€Ğ¸Ğ·ÑƒĞ±'}, {s:'ğŸ¦¯',t:'Ğ¢Ñ€Ğ¾ÑÑ‚Ğ¸Ğ½Ğ°'}, {s:'ğŸ•¯ï¸',t:'Ğ¡Ğ²Ñ–Ñ‡ĞºĞ°'}, {s:'ğŸ“¼',t:'Ğ¢Ğ°Ğ½Ğº'}, {s:'ğŸ“œ',t:'Ğ¡ÑƒĞ²Ñ–Ğ¹'}, {s:'ğŸŒŠ',t:'Ğ¦ÑƒĞ½Ğ°Ğ¼Ñ–'}, {s:'ğŸ§¬',t:'Ğ”ĞĞš'}, {s:'ğŸ—¡ï¸',t:'ĞœĞµÑ‡'}] },
            { name: "Mega: Ğ¡Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ğ¸ (Ğ¢Ğ²Ğ°Ñ€Ğ¸Ğ½Ğ¸)", bg: "#d4e6f1", items: [{s:'ğŸ˜º',t:'ĞšÑ–Ñ‚'}, {s:'ğŸº',t:'Ğ’Ğ¾Ğ²Ğº'}, {s:'ğŸ¦Š',t:'Ğ›Ğ¸Ñ'}, {s:'ğŸ—',t:'ĞšĞ°Ğ±Ğ°Ğ½'}, {s:'ğŸ¦',t:'Ğ“Ğ¾Ñ€Ğ¸Ğ»Ğ°'}, {s:'ğŸƒ',t:'Ğ‘ÑƒĞ¹Ğ²Ğ¾Ğ»'}, {s:'ğŸŠ',t:'ĞšÑ€Ğ¾ĞºĞ¾Ğ´Ğ¸Ğ»'}, {s:'ğŸŒ',t:'Ğ Ğ°Ğ²Ğ»Ğ¸Ğº'}, {s:'ğŸ¦‘',t:'ĞšĞ°Ğ»ÑŒĞ¼Ğ°Ñ€'}, {s:'ğŸ™',t:'Ğ’Ğ¾ÑÑŒĞ¼Ğ¸Ğ½Ñ–Ğ³'}, {s:'ğŸ',t:'Ğ‘Ğ´Ğ¶Ğ¾Ğ»Ğ°'}, {s:'ğŸ¦‹',t:'ĞœĞµÑ‚ĞµĞ»Ğ¸Ğº'}, {s:'ğŸ«',t:'Ğ’ĞµÑ€Ğ±Ğ»ÑĞ´'}, {s:'ğŸ¦“',t:'Ğ—ĞµĞ±Ñ€Ğ°'}, {s:'ğŸ¦’',t:'Ğ–Ğ¸Ñ€Ğ°Ñ„Ğ°'}, {s:'ğŸ•',t:'ĞŸĞµÑ'}, {s:'ğŸ¦€',t:'ĞšÑ€Ğ°Ğ±'}, {s:'ğŸ†',t:'Ğ›ĞµĞ¾Ğ¿Ğ°Ñ€Ğ´'}, {s:'ğŸ¿ï¸',t:'Ğ‘Ñ–Ğ»ĞºĞ°'}, {s:'ğŸ¦‡',t:'ĞšĞ°Ğ¶Ğ°Ğ½'}, {s:'ğŸ¦—',t:'ĞšĞ¾Ğ½Ğ¸Ğº'}] },
            { name: "Mega: ĞšĞ¾Ğ¼Ğ±Ñ–Ğ½Ğ¾Ğ²Ğ°Ğ½Ñ– & Ğ Ğ¾Ğ»Ñ–", bg: "#f9e79f", items: [{s:'ğŸ',t:'Ğ†Ğ¼Ğ¿ĞµÑ€Ğ°Ñ‚Ñ€Ğ¸Ñ†Ñ'}, {s:'ğŸ‘¸',t:'ĞŸÑ€Ğ¸Ğ½Ñ†ĞµÑĞ°'}, {s:'ğŸº',t:'ĞĞ¼Ğ°Ğ·Ğ¾Ğ½ĞºĞ°'}, {s:'ğŸ‘®',t:'ĞŸĞ¾Ğ»Ñ–Ñ†Ñ–Ñ'}, {s:'ğŸ¤–',t:'Ğ Ğ¾Ğ±Ğ¾Ñ‚'}, {s:'ğŸ›¸',t:'ĞĞ›Ğ'}, {s:'ğŸ‡',t:'Ğ’ĞµÑ€ÑˆĞ½Ğ¸Ğº'}, {s:'ğŸŒªï¸',t:'Ğ¢Ğ¾Ñ€Ğ½Ğ°Ğ´Ğ¾'}, {s:'ğŸ§›',t:'Ğ’Ğ°Ğ¼Ğ¿Ñ–Ñ€'}, {s:'ğŸ’‚',t:'Ğ“Ğ²Ğ°Ñ€Ğ´Ñ–Ñ”Ñ†ÑŒ'}, {s:'ğŸ‘·',t:'Ğ‘ÑƒĞ´Ñ–Ğ²ĞµĞ»ÑŒĞ½Ğ¸Ğº'}, {s:'ğŸ§',t:'Ğ”Ğ¶Ğ¸Ğ½'}, {s:'ğŸ§š',t:'Ğ¤ĞµÑ'}, {s:'â˜€ï¸',t:'Ğ¡Ğ¾Ğ½Ñ†Ğµ'}, {s:'ğŸ§™',t:'ĞœĞ°Ğ³'}, {s:'ğŸ•µï¸',t:'Ğ¨Ğ¿Ğ¸Ğ³ÑƒĞ½'}, {s:'ğŸ¥‹',t:'Ğ¡Ğ°Ğ¼ÑƒÑ€Ğ°Ğ¹'}, {s:'ğŸ¥·',t:'ĞÑ–Ğ½Ğ´Ğ·Ñ'}, {s:'ğŸ‘¨',t:'Ğ§Ğ¾Ğ»Ğ¾Ğ²Ñ–Ğº'}, {s:'ğŸ¤´',t:'ĞŸÑ€Ğ¸Ğ½Ñ†'}, {s:'ğŸ‘¼',t:'ĞĞ½Ğ³ĞµĞ»'}] },
            { name: "Mega: ĞÑ€ÑĞµĞ½Ğ°Ğ» & ĞœĞ¾Ğ½ÑÑ‚Ñ€Ğ¸", bg: "#fadbd8", items: [{s:'ğŸ›¡ï¸',t:'Ğ©Ğ¸Ñ‚'}, {s:'ğŸ”ª',t:'ĞšĞ¸Ğ½Ğ´Ğ¶Ğ°Ğ»'}, {s:'ğŸ”¥',t:'Ğ’Ğ¾Ğ³Ğ¾Ğ½ÑŒ'}, {s:'ğŸ’§',t:'Ğ’Ğ¾Ğ´Ğ°'}, {s:'â„ï¸',t:'Ğ¡Ğ½Ñ–Ğ³'}, {s:'ğŸ§Ÿ',t:'Ğ—Ğ¾Ğ¼Ğ±Ñ–'}, {s:'ğŸª¨',t:'ĞšĞ°Ğ¼Ñ–Ğ½ÑŒ'}, {s:'ğŸ§¨',t:'Ğ”Ğ¸Ğ½Ğ°Ğ¼Ñ–Ñ‚'}, {s:'ğŸ’£',t:'Ğ‘Ğ¾Ğ¼Ğ±Ğ°'}, {s:'âš—ï¸',t:'Ğ—Ñ–Ğ»Ğ»Ñ'}, {s:'ğŸ’',t:'ĞšÑ–Ğ»ÑŒÑ†Ğµ'}, {s:'ğŸ”®',t:'Ğ¡Ñ„ĞµÑ€Ğ°'}, {s:'ğŸ¦‚',t:'Ğ¡ĞºĞ¾Ñ€Ğ¿Ñ–Ğ¾Ğ½'}, {s:'ğŸ',t:'Ğ—Ğ¼Ñ–Ñ'}, {s:'ğŸ¦–',t:'Ğ¢Ñ–-Ğ ĞµĞºÑ'}, {s:'ğŸ¦ˆ',t:'ĞĞºÑƒĞ»Ğ°'}, {s:'ğŸ‘¾',t:'Ğ§ÑƒĞ¶Ğ¸Ğ¹'}, {s:'ğŸ‘º',t:'Ğ“Ğ¾Ğ±Ğ»Ñ–Ğ½'}, {s:'ğŸ²',t:'Ğ”Ñ€Ğ°ĞºĞ¾Ğ½'}, {s:'ğŸ¦„',t:'Ğ„Ğ´Ğ¸Ğ½Ğ¾Ñ€Ñ–Ğ³'}, {s:'ğŸ¦…',t:'Ğ“Ñ€Ğ¸Ñ„Ğ¾Ğ½'}, {s:'ğŸ•·ï¸',t:'ĞŸĞ°Ğ²ÑƒĞº'}, {s:'ğŸ¢',t:'Ğ§ĞµÑ€ĞµĞ¿Ğ°Ñ…Ğ°'}] },
            { name: "Mega: ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ñ–Ñ & ĞŸÑ€Ğ¸Ñ€Ğ¾Ğ´Ğ°", bg: "#d5f5e3", items: [{s:'ğŸŒµ',t:'ĞšĞ°ĞºÑ‚ÑƒÑ'}, {s:'ğŸ„',t:'Ğ“Ñ€Ğ¸Ğ±'}, {s:'ğŸŒ²',t:'Ğ”ĞµÑ€ĞµĞ²Ğ¾'}, {s:'ğŸ',t:'Ğ›Ğ¸ÑÑ‚'}, {s:'ğŸŒ‹',t:'Ğ’ÑƒĞ»ĞºĞ°Ğ½'}, {s:'ğŸŒ©ï¸',t:'Ğ“Ñ€Ğ¾Ğ·Ğ°'}, {s:'ğŸ§©',t:'ĞŸĞ°Ğ·Ğ»'}, {s:'ğŸ²',t:'ĞšÑƒĞ±Ğ¸Ğº'}, {s:'âš›ï¸',t:'ĞÑ‚Ğ¾Ğ¼'}, {s:'ğŸšœ',t:'Ğ¢Ñ€Ğ°ĞºÑ‚Ğ¾Ñ€'}, {s:'âš”ï¸',t:'ĞœĞµÑ‡Ñ–'}, {s:'ğŸ˜',t:'Ğ¡Ğ»Ğ¾Ğ½'}, {s:'ğŸŒ›',t:'ĞœÑ–ÑÑÑ†ÑŒ'}, {s:'â­',t:'Ğ—Ñ–Ñ€ĞºĞ°'}, {s:'ğŸª',t:'ĞŸĞ»Ğ°Ğ½ĞµÑ‚Ğ°'}, {s:'ğŸŒŒ',t:'Ğ“Ğ°Ğ»Ğ°ĞºÑ‚Ğ¸ĞºĞ°'}] }
        ];
const megaDefs = {
            'ğŸ•·ï¸': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide_jump', d:'knight'}] },
            'ğŸšœ': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1]]}] },
            'âš”ï¸': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸ˜': { t: 'complex', comps: [{t:'step', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸš€': { t: 'slide', dirs: [[0,-1]] },
            'âš“': { t: 'slide', dirs: [[0,1]] },
            'ğŸ¹': { t: 'slide', dirs: [[-1,-1],[1,-1]] },
            'ğŸ£': { t: 'slide', dirs: [[-1,1],[1,1]] },
            'ğŸ§œ': { t: 'slide', dirs: [[1,0],[-1,0]] },
            'âš¡': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'ğŸ¦¯': { t: 'slide', dirs: [[1,1],[-1,1],[1,-1],[-1,-1]], max: 2 },
            'ğŸ•¯ï¸': { t: 'slide', dirs: [[1,0],[-1,0],[0,1],[0,-1]], max: 3 },
            'ğŸ”±': { t: 'slide', dirs: [[0,-1],[-1,-1],[1,-1]] },
            'ğŸŒŠ': { t: 'slide', dirs: [[0,-1]] },
            'ğŸ“œ': { t: 'slide', dirs: [[0,1]] },
            'ğŸ§¬': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'ğŸ—¡ï¸': { t: 'slide', dirs: [[1,-1],[-1,-1]] },
            'ğŸŒµ': { t: 'step', dirs: 'king' },
            'ğŸ„': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'ğŸŒ²': { t: 'step', dirs: [[0,1],[0,-1]] },
            'ğŸ': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'ğŸŒ‹': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'ğŸŒ©ï¸': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'â„ï¸': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'ğŸ”¥': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]], mul:2}] },
            'ğŸ’§': { t: 'complex', comps: [{t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]], mul:2}] },
            'ğŸª¨': { t: 'none' },
            'ğŸ˜º': { t: 'jump', dirs: [[1,-2],[-1,-2]] },
            'ğŸº': { t: 'jump', dirs: 'knight' },
            'ğŸ¦Š': { t: 'step', dirs: [[1,1],[1,-1],[-1,1],[-1,-1]] },
            'ğŸ—': { t: 'jump', dirs: [[0,-2]] },
            'ğŸ¦': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'ğŸƒ': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'ğŸŠ': { t: 'jump', dirs: [[3,3],[3,-3],[-3,3],[-3,-3]] },
            'ğŸŒ': { t: 'step', dirs: [[1,-1],[-1,-1]] },
            'ğŸ¦‘': { t: 'jump', dirs: [[4,0],[-4,0],[0,4],[0,-4]] },
            'ğŸ™': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[1,2],[1,-2],[-1,2],[-1,-2]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ğŸ¦‹': { t: 'complex', comps: [{t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ¢': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'ğŸ•': { t: 'step', dirs: [[0,1],[0,-1],[1,0],[-1,0]] },
            'ğŸ¿ï¸': { t: 'jump', dirs: 'knight' },
            'ğŸ†': { t: 'slide', dirs: 'bishop' },
            'ğŸ¦“': { t: 'jump', dirs: [[3,2],[3,-2],[-3,2],[-3,-2],[2,3],[2,-3],[-2,3],[-2,-3]] },
            'ğŸ«': { t: 'jump', dirs: [[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]] },
            'ğŸ¦’': { t: 'jump', dirs: [[4,1],[4,-1],[-4,1],[-4,-1],[1,4],[1,-4],[-1,4],[-1,-4]] },
            'ğŸ¦—': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0],[2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¦‡': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ¦€': { t: 'step', dirs: [[0,1],[0,-1],[2,0],[-2,0]] },
            'ğŸ§¨': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¦‚': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[0,2],[0,-2],[2,0],[-2,0]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'step', d:[[0,1],[0,-1],[1,0],[-1,0]]}, {t:'step', d:[[1,1],[1,-1],[-1,1],[-1,-1]]}] },
            'ğŸ¦–': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ğŸ¦ˆ': { t: 'complex', comps: [{t:'slide', d:[[1,-1],[-1,-1]]}, {t:'slide', d:[[0,1]]}] },
            'ğŸ‘¾': { t: 'jump', dirs: [[1,3],[1,-3],[-1,3],[-1,-3],[3,1],[3,-1],[-3,1],[-3,-1]] },
            'ğŸ§Ÿ': { t: 'step', dirs: 'king' },
            'ğŸ‘º': { t: 'slide', dirs: 'bishop' },
            'ğŸ»': { t: 'step', dirs: 'king' },
            'ğŸ”®': { t: 'jump', dirs: [[2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ’': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,3],[3,-3],[-3,3],[-3,-3]]}] },
            'âš—ï¸': { t: 'jump', dirs: [[1,4],[1,-4],[-1,4],[-1,-4],[4,1],[4,-1],[-4,1],[-4,-1]] },
            'ğŸ’£': { t: 'jump', dirs: [[0,2],[0,-2],[2,0],[-2,0]] },
            'ğŸ§©': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ²': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[-2,-2]]}, {t:'jump', d:[[3,3],[-3,-3]]}] },
            'âš›ï¸': { t: 'jump', dirs: [[2,2],[-2,-2],[2,-2],[-2,2], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'ğŸ›¡ï¸': { t: 'step', dirs: [[1,0],[-1,0],[0,1],[0,-1]] },
            'ğŸ”ª': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[-1,1],[-1,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ“¼': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'step', d:[[1,0],[-1,0]]}] },
            'ğŸ¤–': { t: 'complex', comps: [{t:'slide', d:[[0,-1]]}, {t:'slide', d:[[1,1],[-1,1]]}] },
            'ğŸ›¸': { t: 'complex', comps: [{t:'slide', d:[[1,0],[-1,0],[0,1],[0,-1]]}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸŒ›': { t: 'jump', dirs: [[2,3],[2,-3],[-2,3],[-2,-3],[3,2],[3,-2],[-3,2],[-3,-2]] },
            'â­': { t: 'jump', dirs: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2], [2,0],[-2,0],[0,2],[0,-2], [2,2],[-2,-2],[2,-2],[-2,2]] },
            'ğŸª': { t: 'jump', dirs: [[0,3],[0,-3],[3,0],[-3,0]] },
            'ğŸŒŒ': { t: 'jump', dirs: [[3,0],[-3,0],[0,3],[0,-3], [3,3],[-3,-3],[3,-3],[-3,3]] },
            'ğŸ‘¨': { t: 'step', dirs: 'king' },
            'ğŸ‡': { t: 'complex', comps: [{t:'slide_jump', d:[[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]]}] },
            'ğŸ': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'ğŸ‘¸': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸº': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] },
            'ğŸ‘®': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:'knight'}] },
            'ğŸŒªï¸': { t: 'complex', comps: [{t:'jump', d:'knight'}, {t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}] },
            'ğŸ§›': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:[[3,0],[-3,0],[0,3],[0,-3]]}] },
            'ğŸ’‚': { t: 'step', dirs: [[0,-1],[1,0],[-1,0],[1,-1],[-1,-1],[1,1],[-1,1]] },
            'ğŸ‘·': { t: 'slide', dirs: 'rook', max: 2 },
            'ğŸ§': { t: 'slide', dirs: 'queen', max: 3 },
            'ğŸ§š': { t: 'slide', dirs: 'bishop', max: 2 },
            'â˜€ï¸': { t: 'slide', dirs: 'queen', max: 2 },
            'ğŸ§™': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'jump', d:[[3,1],[3,-1],[-3,1],[-3,-1],[1,3],[1,-3],[-1,3],[-1,-3]]}] },
            'ğŸ•µï¸': { t: 'complex', comps: [{t:'jump', d:[[2,2],[2,-2],[-2,2],[-2,-2]]}, {t:'step', d:[[1,0],[-1,0],[0,1],[0,-1]]}] },
            'ğŸ¥‹': { t: 'complex', comps: [{t:'step', d:[[1,1],[-1,-1],[1,-1],[-1,1]]}, {t:'jump', d:[[2,0],[-2,0],[0,2],[0,-2]]}] },
            'ğŸ¥·': { t: 'jump', dirs: [[1,1],[1,-1],[-1,1],[-1,-1], [2,2],[2,-2],[-2,2],[-2,-2]] },
            'ğŸ¤´': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'rook'}] },
            'ğŸ‘¼': { t: 'complex', comps: [{t:'step', d:'king'}, {t:'slide', d:'bishop'}] },
            'ğŸ¦„': { t: 'complex', comps: [{t:'slide', d:'bishop'}, {t:'jump', d:'knight'}] },
            'ğŸ¦…': { t: 'complex', comps: [{t:'slide', d:'rook'}, {t:'jump', d:'knight'}] },
            'ğŸ²': { t: 'complex', comps: [{t:'slide', d:'queen'}, {t:'jump', d:'knight'}] }
        };

        const CHESS_SVGS = {
            'w_â™”': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#101010" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'w_â™•': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#101010" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'w_â™—': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#101010" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'w_â™˜': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#ffffff; stroke:#000000;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#ffffff; stroke:#000000;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#000000; stroke:#000000;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#000000; stroke:#000000;"/></g>`,
            'w_â™–': `<g transform="scale(0.02197265625)"><path fill="#f9f9f9" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#101010" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'w_â™™': `<g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`,
            'b_â™š': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m501.6 1811 48.4-354.4-260-269.2s-166.4-288.2 29.9-481C582.2 448.7 826 727.2 826 727.2l195.6-165.7 184 165.7s216.4-232.5 430.4-76c214 156.5 255.4 317.6 117.4 531.6-138.1 214-250.9 280.7-250.9 280.7L1558 1811z"/><path fill="#f9f9f9" d="M977 298v-95h94v95h107v95h-107v153q-48-16-94 0V393H870v-95zm47 314q-47 0-136 121-31-36-50-55 93-140 186-140 92 0 186 140-20 19-50 55-90-121-136-121zm-447 907-26 156 145-84zm410-206q-1-147-36.5-274.5T870 845q-45-88-131.5-153T570 627q-103 0-208 93T257 949q0 109 86.5 236T546 1408q212-88 441-95zm37 530H448l61-365q-325-280-326-535-1-159 125-274.5T575 553q78 0 158.5 47T876 719q61 74 98.5 164.5T1024 1034q12-60 49-150.5t99-164.5q61-72 142-119t159-47q140 0 266 115.5T1865 943q-2 255-326 535l61 365zm0-74h489l-50-298q-216-84-439-84t-439 84l-50 298zm447-250 26 156-145-84zm-410-206q229 7 441 95 115-96 202-223t87-236q0-136-105.5-229T1478 627q-83 0-169.5 65T1178 845q-46 66-81.5 193.5T1061 1313zm-176 233 141-84 137 86-141 84z"/></g>`,
            'b_â™›': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m508.5 1815.6 48.4-356.7-216.3-554.6-135.8-20.7-16.1-126.5 112.7-43.8 78.3 73.7-18.4 99 246.2 197.8 112.8-568.3L635 428l78.3-108 112.8 43.7-23 161 223.2 474 244-490-66.8-105.9 92-92 105.9 73.6L1337 534l103.5 529.2 260-161-16-142.7 131-46 57.6 131.1-207 103.6-175 529.2 48.4 308.4z"/><path fill="#f9f9f9" d="M1024 1769h478q-53-130-43-280-100-39-213-67.5t-222-28.5q-110 0-223 28.5T589 1489q9 150-43 280zm0-450q111 0 223.5 26.5T1468 1413q17-105 60.5-212.5T1634 988l-220 155-123-601-267 555-267-555-123 601-220-155q61 105 104.5 212.5T580 1413q108-41 220.5-67.5T1024 1319zm0 524H441q114-231 57.5-456.5T296 937q-12 2-19 2-54 0-92.5-38.5T146 808t38.5-92.5T277 677t92.5 38.5T408 808q0 20-6 38-4 14-15 33l196 139 100-486q-64-31-72-103-5-44 29-91t88-53q54-5 96 29t48 88q7 68-46 114l198 412 198-412q-54-46-46-114 6-54 48-88t96-29q54 6 87.5 53t29.5 91q-9 72-72 103l100 486 196-139q-12-19-15-33-6-18-6-38 0-54 38.5-92.5T1771 677t92.5 38.5T1902 808t-38.5 92.5T1771 939q-7 0-19-2-147 224-203 449.5t58 456.5zM276 746q-62 0-62 62t62 62q63 0 63-62t-63-62zm466-394q-62 0-62 62t62 62 62-62-62-62M590 1519l119 72-134 86q19-86 15-158zm1182-773q-63 0-63 62t63 62q62 0 62-62t-62-62zm-466-394q-62 0-62 62t62 62 62-62-62-62zm152 1167-119 72 134 86q-20-86-15-158zm-573 47 139-83 139 86-139 84z"/></g>`,
            'b_â™œ': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m435 1804 16-212 152-115 51-688-148-115-7-276 210-2 4 138 198 2 7-140 212-3 14 145 193-4 5-138h204l-7 285-145 106 42 693 172 124 19 207z"/><path fill="#f9f9f9" d="M1024 1501H643l5-74h752l5 74zm0-661H692l5-74h654l5 74zm0 1003H383l29-264 159-118 50-659-149-107-17-341h289v147h137V354h286v147h137V354h289l-17 341-149 107 50 659 159 118 29 264zm0-74h557l-15-149-161-119-54-735 152-109 13-230h-138v148h-285V427H955v148H670V427H532l13 230 152 109-54 735-161 119-15 149z"/></g>`,
            'b_â™': `<g transform="scale(0.02197265625)"><path fill="#101010" d="m948 366 1-139 148-7 1 147zM564 860c114-267 456-443 456-443s392 176 476 502c-9 209-183 332-183 332l27 221-653 6 46-233s-230-171-169-385zm-101 790c175 6 355 23 425-142h92s0 190-88 246c-163 103-625 38-625 38s-15-146 196-142zm631 37-36-185 102 5s22 153 315 131c381-17 318 153 318 153l-483 5z"/><path fill="#f9f9f9" d="M1024 356q66 0 64-66 1-55-64-55-66 0-64 55-3 66 64 66zm0 1204q0 114-101 199t-223 84H205q0-117 65-179t142-62h250q51 0 88-7t71-60l10-16h76q-7 21-3 13-45 105-109 125t-146 19H409q-52 0-86 40t-34 53h424q66 0 159-65t93-185H624q67-116 72-229-114-119-162-223t-6-224q33-96 118-189t312-247q-17-11-46-36t-29-79q0-58 41-96t100-38q58 0 100 38t41 96q0 54-29 79t-46 36q226 153 311 247t119 189q42 119-6 224t-162 223q4 113 72 229h-341q0 120 93 185t159 65h424q0-13-34-53t-86-40h-240q-83 0-146-19t-109-125q4 8-3-13h76l10 16q33 53 70 60t89 7h250q76 0 142 62t65 179h-495q-123 0-223-84t-101-199zm0-114h283q-28-84-29-154-120-41-254-38-135-3-254 38-2 70-29 154zm0-267q159-1 285 42 189-180 142-346-60-193-427-431-368 238-427 431-48 166 142 346 125-43 285-42zm-47-361V714h94v104h95v89h-95v165h-94V907h-95v-89z"/></g>`,
            'b_â™': `<g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18" style="fill:#000000; stroke:#ffffff;"/><path d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10" style="fill:#000000; stroke:#ffffff;"/><path d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z" style="fill:#ffffff; stroke:#ffffff;"/><path d="M 15 15.5 A 0.5 1.5 0 1 1 14,15.5 A 0.5 1.5 0 1 1 15 15.5 z" style="transform:matrix(0.866,0.5,-0.5,0.866,9.693,-5.173); fill:#ffffff; stroke:#ffffff;"/></g>`,
            'b_â™Ÿ': `<g fill="#000" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z"/></g>`,
            // --- ĞĞĞ’Ğ† Ğ¨ĞĞ¨ĞšĞ˜ (LIDRAUGHTS STYLE) ---
    'w_checker': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#eee" stroke="#000" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#fff" stroke="#000" stroke-width="1.5" />
        </g>`,
    'w_damka': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#eee" stroke="#000" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#fff" stroke="#000" stroke-width="1.5" />
            <path d="M 12,23 L 12,17 L 16.5,20 L 22.5,13 L 28.5,20 L 33,17 L 33,23 Z" fill="#DAA520" stroke="#B8860B" stroke-width="1" />
        </g>`,
    'b_checker': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#333" stroke="#ccc" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#111" stroke="#ccc" stroke-width="1.5" />
        </g>`,
    'b_damka': `
        <g>
            <path d="M 4.5,22 v 10 a 18,7 0 0 0 36,0 v -10" fill="#333" stroke="#ccc" stroke-width="1.5" />
            <ellipse cx="22.5" cy="22" rx="18" ry="7" fill="#111" stroke="#ccc" stroke-width="1.5" />
            <path d="M 12,23 L 12,17 L 16.5,20 L 22.5,13 L 28.5,20 L 33,17 L 33,23 Z" fill="#DAA520" stroke="#B8860B" stroke-width="1" />
        </g>`

        };

        const CLASSIC_MAP = {
            'â™”':'w_â™”', 'â™•':'w_â™•', 'â™–':'w_â™–', 'â™—':'w_â™—', 'â™˜':'w_â™˜', 'â™™':'w_â™™',
            'â™š':'b_â™š', 'â™›':'b_â™›', 'â™œ':'b_â™œ', 'â™':'b_â™', 'â™':'b_â™', 'â™Ÿ':'b_â™Ÿ',

            // ĞĞ¾Ğ²Ñ– Ğ¿Ñ€Ğ¸Ğ²'ÑĞ·ĞºĞ¸ Ğ´Ğ»Ñ ÑˆĞ°ÑˆĞ¾Ğº
    'â›€': 'w_checker', // Ğ‘Ñ–Ğ»Ğ° ÑˆĞ°ÑˆĞºĞ°
    'â›': 'w_damka',   // Ğ‘Ñ–Ğ»Ğ° Ğ´Ğ°Ğ¼ĞºĞ°
    'â›‚': 'b_checker', // Ğ§Ğ¾Ñ€Ğ½Ğ° ÑˆĞ°ÑˆĞºĞ°
    'â›ƒ': 'b_damka'    // Ğ§Ğ¾Ñ€Ğ½Ğ° Ğ´Ğ°Ğ¼ĞºĞ°

        };
        const DIRS = {
            rook: [[0,1],[0,-1],[1,0],[-1,0]],
            bishop: [[1,1],[1,-1],[-1,1],[-1,-1]],
            queen: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            knight: [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]],
            king: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
        };

        const GRID_VOID = -999;

        class SmoothChess {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                this.boardSize = 32;
                this.cellSize = 60;

                this.camera = { x: 0, y: 0, zoom: 1 };
                
                // Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ targetCamera Ğ´Ğ»Ñ ÑÑ‚Ğ°Ğ±Ñ–Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ—
                this.targetCamera = { x: 0, y: 0, zoom: 1 }; 
                
                this.lerpFactor = 0.1;
                this.minZoom = 0.000001;
                this.maxZoom = 5.0;

                this.mouse = { x: 0, y: 0 };
                this.isDragging = false;
                this.isDraggingPiece = false;
                this.draggedPiece = null;
                this.lastMouse = { x: 0, y: 0 };
                this.isPainting = false;
                this.isGenerating = false;

                this.isPainting = false;
                this.isGenerating = false;

                this.customArrows = []; // ĞœĞ°ÑĞ¸Ğ² ÑÑ‚Ñ€Ñ–Ğ»Ğ¾Ğº
                this.rmbStart = null;   // Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºÑƒ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ
                this.previewArrow = null; // <--- Ğ”ĞĞ”ĞĞ¢Ğ˜ Ğ¦Ğ•Ğ™ Ğ Ğ¯Ğ”ĞĞš (Ğ¢Ğ¸Ğ¼Ñ‡Ğ°ÑĞ¾Ğ²Ğ° ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ°)
                // --- PROMOTION STATE ---
                this.promotionPending = null;// ĞœĞ°ÑĞ¸Ğ² ÑÑ‚Ñ€Ñ–Ğ»Ğ¾Ğº
                this.rmbStart = null;   // Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºÑƒ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ
                // --- PROMOTION STATE ---
                this.promotionPending = null;

                // --- KEYBOARD ---
                this.keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

                // Storage for MODIFIED pieces only.
                this.grid = new Map();

                // History for UNDO
                this.moveHistory = [];

                this.virtualGen = null;
                this.virtualProps = { percent: 25, mix: 0 };

                this.generationSeed = 0;

                this.palette = [];
                this.paletteMap = new Map();
                this.pieceCount = 0;
                this.kingPos = { w: null, b: null };

                this.curSymbol = 'â™”';
                this.curColor = 'w';

                this.rulesEnabled = true;
                this.turnModeEnabled = true;
                this.currentTurn = 'w';
                this.gameOver = false;
                this.multiJumpSource = null;

                this.highlightedMoves = [];
                this.kingsInCheck = { w: null, b: null };

                this.colors = {
                    light: '#eeeed2',
                    dark: 'rgba(80, 120, 60, 0.6)',
                    border: '#3a4a2b',
                    whiteP: '#ffffff',
                    blackP: '#000000',
                    neutralP: '#ffcc00',
                    highlight: 'rgba(0, 255, 0, 0.5)',
                    checkHighlight: 'rgba(255, 0, 0, 0.6)',
                    mateHighlight: 'rgba(75, 0, 130, 0.9)'
                };
                this.colors.void = this.colors.light;

                this.checkersSymbols = new Set(['â›€', 'â›', 'â›‚', 'â›ƒ']);
                this.spriteCache = new Map();
                this.lowResCache = new Map();
                this.spriteSize = 100;

                this.initUI();
                this.init();
                this.updateTurnIndicator();
            }
            // ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´: ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ĞºĞ¾Ğ½ĞµÑ† Ğ¿ÑƒÑ‚Ğ¸, Ğ¿ĞµÑ€ĞµĞ¿Ñ€Ñ‹Ğ³Ğ¸Ğ²Ğ°Ñ Ñ‡ĞµÑ€ĞµĞ· Ğ¿ÑƒÑÑ‚Ğ¾Ñ‚Ñƒ
            // Ğ“Ñ–Ğ±Ñ€Ğ¸Ğ´Ğ½Ğ¸Ğ¹ Ğ¿Ğ¾ÑˆÑƒĞº: Ğ¢Ğ¾Ñ‡Ğ½Ğ¸Ğ¹ Ğ¿Ğ¾Ğ±Ğ»Ğ¸Ğ·Ñƒ, ÑˆĞ²Ğ¸Ğ´ĞºĞ¸Ğ¹ Ğ´Ğ°Ğ»ĞµĞºĞ¾
            findRayEnd(cx, cy, dx, dy, maxLimit) {
                let x = cx;
                let y = cy;
                let steps = 0;
                
                // 1. Ğ§Ğ•Ğ¡ĞĞ˜Ğ™ Ğ¡ĞšĞĞĞ•Ğ  (Ğ‘Ğ»Ğ¸Ğ¶Ğ½Ñ Ğ·Ğ¾Ğ½Ğ° - Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğ¸ Ğ½Ñ–Ñ‡Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ€ÑƒÑ‡)
                const SCAN_LIMIT = 50; 

                while (steps < maxLimit && steps < SCAN_LIMIT) {
                    steps++;
                    x += dx; y += dy;

                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¼ĞµĞ¶
                    if (x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize) {
                        return { x: x - dx, y: y - dy, hit: false, edge: true };
                    }

                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ²Ğ»ÑƒÑ‡Ğ°Ğ½Ğ½Ñ
                    const target = this.getPiece(x, y);
                    if (target) {
                        const startP = this.getPiece(cx, cy);
                        const isAlly = startP && target.c === startP.c;
                        return { x, y, hit: true, ally: isAlly };
                    }
                }

                // 2. ĞœĞĞ¢Ğ•ĞœĞĞ¢Ğ˜Ğ§ĞĞ˜Ğ™ Ğ¡Ğ¢Ğ Ğ˜Ğ‘ĞĞš (Ğ”Ğ°Ğ»ĞµĞºĞ° Ğ·Ğ¾Ğ½Ğ°)
                // Ğ¯ĞºÑ‰Ğ¾ Ğ¼Ğ¸ Ğ¿Ñ€Ğ¾Ğ¹ÑˆĞ»Ğ¸ ÑĞºĞ°Ğ½ Ñ– Ğ½Ñ–Ñ‡Ğ¾Ğ³Ğ¾ Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹ÑˆĞ»Ğ¸, Ñ€Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ Ğ¼Ğ°Ñ‚ĞµĞ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ´Ğ¾ ĞºÑ€Ğ°Ñ Ğ°Ğ±Ğ¾ Ğ¿ĞµÑ€ĞµÑˆĞºĞ¾Ğ´Ğ¸
                
                // Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾, ÑĞºÑ–Ğ»ÑŒĞºĞ¸ ĞšĞ ĞĞšĞ†Ğ’ (Ğ° Ğ½Ğµ Ğ¿Ñ–ĞºÑĞµĞ»Ñ–Ğ²) Ğ»Ğ¸ÑˆĞ¸Ğ»Ğ¾ÑÑŒ Ğ´Ğ¾ ĞºÑ€Ğ°Ñ—Ğ² Ğ´Ğ¾ÑˆĞºĞ¸
                let stepsX = Infinity;
                if (dx > 0) stepsX = (this.boardSize - 1 - x) / dx;
                else if (dx < 0) stepsX = (0 - x) / dx;

                let stepsY = Infinity;
                if (dy > 0) stepsY = (this.boardSize - 1 - y) / dy;
                else if (dy < 0) stepsY = (0 - y) / dy;

                // Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ ĞºÑ€Ğ¾ĞºÑ–Ğ² Ğ´Ğ¾ ĞºÑ€Ğ°Ñ Ğ´Ğ¾ÑˆĞºĞ¸
                let stepsToEdge = Math.min(stepsX, stepsY);
                // Ğ’Ñ€Ğ°Ñ…Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ¼Ñ–Ñ‚ Ğ´Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ñ– Ñ…Ğ¾Ğ´Ñƒ Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸
                let remainingLimit = maxLimit - steps;
                
                let bestSteps = Math.floor(Math.min(stepsToEdge, remainingLimit));
                let hitGrid = false;

                // --- ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Grid (Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ñ–ĞºĞ¾Ğ²Ğ°Ğ½Ñ– Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸) ---
                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const comma = key.indexOf(',');
                    const px = parseInt(key.substring(0, comma));
                    const py = parseInt(key.substring(comma + 1));

                    // Ğ’ĞµĞºÑ‚Ğ¾Ñ€ Ğ²Ñ–Ğ´ Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ñ— Ñ‚Ğ¾Ñ‡ĞºĞ¸ x,y
                    const vx = px - x;
                    const vy = py - y;

                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞºĞ¾Ğ»Ñ–Ğ½ĞµĞ°Ñ€Ğ½Ğ¾ÑÑ‚Ñ– (Ñ‡Ğ¸ Ğ»ĞµĞ¶Ğ¸Ñ‚ÑŒ Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ğ½Ğ° Ğ»Ñ–Ğ½Ñ–Ñ— Ğ²ĞµĞºÑ‚Ğ¾Ñ€Ñƒ)
                    // Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ cross product: x1*y2 - x2*y1 == 0
                    if (vx * dy - vy * dx !== 0) continue;

                    // Ğ§Ğ¸ Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ĞºÑƒ?
                    if (Math.sign(vx) !== Math.sign(dx) && dx !== 0) continue;
                    if (Math.sign(vy) !== Math.sign(dy) && dy !== 0) continue;

                    // Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ Ğ´Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ñ–Ñ Ğ² ĞºÑ€Ğ¾ĞºĞ°Ñ…
                    // Ğ‘ĞµÑ€ĞµĞ¼Ğ¾ Ñ‚Ñƒ Ğ²Ñ–ÑÑŒ, Ğ´Ğµ Ñ€ÑƒÑ… Ğ±Ñ–Ğ»ÑŒÑˆĞ¸Ğ¹, Ñ‰Ğ¾Ğ± ÑƒĞ½Ğ¸ĞºĞ½ÑƒÑ‚Ğ¸ Ğ´Ñ–Ğ»ĞµĞ½Ğ½Ñ Ğ½Ğ° 0
                    let s = 0;
                    if (Math.abs(dx) >= Math.abs(dy)) s = vx / dx;
                    else s = vy / dy;

                    if (s > 0 && s < bestSteps) {
                        bestSteps = s;
                        hitGrid = true;
                    }
                }

                // --- ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞÑ€Ğ¼Ñ–Ñ— (Virtual) ---
                if (this.virtualGen) {
                    let rows = 0;
                    if (this.virtualGen === 'chess960') rows = 2;
                    else {
                        rows = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                        if (this.virtualGen !== 'checkers' && rows < 2) rows = 2;
                    }

                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ğ¿ĞµÑ€ĞµÑ‚Ğ¸Ğ½ Ğ· Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¼Ğ¸ Ğ»Ñ–Ğ½Ñ–ÑĞ¼Ğ¸ Ğ°Ñ€Ğ¼Ñ–Ğ¹
                    const checkY = (limitY) => {
                        // (limitY - y) / dy = s
                        if (dy === 0) return;
                        const s = (limitY - y) / dy;
                        // ĞĞºÑ€ÑƒĞ³Ğ»ÑÑ”Ğ¼Ğ¾ Ğ²Ğ³Ğ¾Ñ€Ñƒ, Ğ±Ğ¾ Ğ¼Ğ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµĞ¼Ğ¾ Ğ·ÑƒĞ¿Ğ¸Ğ½Ğ¸Ñ‚Ğ¸ÑÑŒ Ğ¼Ñ–Ğ¶ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ°Ğ¼Ğ¸
                        // Ğ¯ĞºÑ‰Ğ¾ s = 1.5, Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ÑŒ Ğ¼Ğ¸ Ğ¿ĞµÑ€ĞµÑÑ‚Ñ€Ğ¸Ğ±Ğ½ÑƒĞ»Ğ¸ Ğ»Ñ–Ğ½Ñ–Ñ Ğ¼Ñ–Ğ¶ ĞºÑ€Ğ¾ĞºĞ¾Ğ¼ 1 Ñ– 2. 
                        // ĞŸĞµÑ€ÑˆĞ° Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ²Ğ»ÑƒÑ‡Ğ°Ğ½Ğ½Ñ Ğ±ÑƒĞ´Ğµ 2.
                        const sInt = Math.ceil(s); 
                        if (sInt > 0 && sInt < bestSteps) {
                             // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ñ‡Ğ¸ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¼Ğ¸ Ğ²Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ Ğ² Ğ·Ğ¾Ğ½Ñƒ Ğ°Ñ€Ğ¼Ñ–Ñ—
                             const landY = y + sInt * dy;
                             // Ğ”Ğ»Ñ Ğ°Ñ€Ğ¼Ñ–Ñ— Ñ†Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾: ÑĞºÑ‰Ğ¾ Ğ¼Ğ¸ Ğ·Ğ° Ğ¼ĞµĞ¶ĞµÑ rows, Ñ†Ğµ Ğ²Ğ»ÑƒÑ‡Ğ°Ğ½Ğ½Ñ
                             if (dy > 0 && landY >= this.boardSize - rows) { bestSteps = sInt; hitGrid = true; }
                             if (dy < 0 && landY < rows) { bestSteps = sInt; hitGrid = true; }
                        }
                    };

                    if (dy > 0) checkY(this.boardSize - rows); // Ğ›ĞµÑ‚Ğ¸Ğ¼Ğ¾ Ğ²Ğ½Ğ¸Ğ·
                    if (dy < 0) checkY(rows - 1); // Ğ›ĞµÑ‚Ğ¸Ğ¼Ğ¾ Ğ²Ğ³Ğ¾Ñ€Ñƒ
                }

                const finalX = x + dx * bestSteps;
                const finalY = y + dy * bestSteps;

                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ñ„Ñ–Ğ½Ğ°Ğ»ÑŒĞ½Ñƒ Ñ†Ñ–Ğ»ÑŒ
                const finalTarget = this.getPiece(finalX, finalY);
                const startP = this.getPiece(cx, cy);
                const isAlly = finalTarget && startP && finalTarget.c === startP.c;

                return { x: finalX, y: finalY, hit: hitGrid || !!finalTarget, ally: isAlly };
            }

            calculateHighlights(piece, cx, cy) {
                if (!this.rulesEnabled) return;
                
                this.highlightedMoves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // --- 1. Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ğ¸ (Ğ¢ÑƒÑ€Ğ°, Ğ¡Ğ»Ğ¾Ğ½, Ğ¤ĞµÑ€Ğ·ÑŒ) ---
                const castRay = (dx, dy, maxLimit = this.boardSize) => {
                    const end = this.findRayEnd(cx, cy, dx, dy, maxLimit);
                    
                    // Ğ”Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ğ° Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ñ (Ğ¼Ğ°Ñ‚ĞµĞ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ° Ğ´Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ñ–Ñ)
                    let dist = Math.max(Math.abs(end.x - cx), Math.abs(end.y - cy));

                    // Ğ¯ĞºÑ‰Ğ¾ Ğ²Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸, ÑĞºĞ¾Ñ€Ğ¾Ñ‡ÑƒÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ½Ñ–Ñ Ğ½Ğ° 1, Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ ĞĞ Ñ„Ñ–Ğ³ÑƒÑ€Ñ–
                    if (end.hit || end.ally) dist--;

                    if (dist > 0) {
                        this.highlightedMoves.push({
                            type: 'ray', cx: cx, cy: cy, dx: dx, dy: dy, len: dist
                        });
                    }

                    // Ğ§ĞµÑ€Ğ²Ğ¾Ğ½Ğ° ĞºÑ€Ğ°Ğ¿ĞºĞ° Ğ´Ğ»Ñ Ğ°Ñ‚Ğ°ĞºĞ¸
                    if (end.hit && !end.ally) {
                        this.highlightedMoves.push({ type: 'point', c: end.x, r: end.y, capture: true });
                    }
                };

                // --- 2. Ğ¡Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ğ¸ (ĞšÑ–Ğ½ÑŒ, ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ) ---
                // ... (Ğ¿Ğ¾Ñ‡Ğ°Ñ‚Ğ¾Ğº Ğ¼ĞµÑ‚Ğ¾Ğ´Ñƒ calculateHighlights) ...

                // --- 2. Ğ¡Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ğ¸ (ĞšÑ–Ğ½ÑŒ, ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ) ---
                const checkJump = (dx, dy) => {
                    const tx = cx + dx; const ty = cy + dy;
                    if (tx >= 0 && tx < this.boardSize && ty >= 0 && ty < this.boardSize) {
                        const target = this.getPiece(tx, ty);
                        if (!target) {
                             this.highlightedMoves.push({ type: 'point', c: tx, r: ty });
                        } else if (target.c !== piece.c) {
                             this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: true });
                        }
                    }
                };

                // ... (ĞºĞ¾Ğ´ Ğ´Ğ»Ñ ÑˆĞ°ÑˆĞ¾Ğº Ñ– ÑĞ»Ğ°Ğ¹Ğ´ĞµÑ€Ñ–Ğ²) ...
                if (['â™˜','â™'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => checkJump(d[0], d[1])); }
                
                // --- Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯ Ğ”Ğ›Ğ¯ ĞšĞĞ ĞĞ›Ğ¯ (ĞŸÑ€Ğ¸Ğ±Ğ¸Ñ€Ğ°Ñ”Ğ¼Ğ¾ checkJump, Ğ´Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ Ğ°Ñ‚Ğ°ĞºĞ¸) ---
                if (['â™”','â™š'].includes(type)) { 
                    for(let i=-1; i<=1; i++) {
                        for(let j=-1; j<=1; j++) {
                            if(i===0 && j===0) continue;
                            const tx = cx + i; 
                            const ty = cy + j;
                            
                            if (tx >= 0 && tx < this.boardSize && ty >= 0 && ty < this.boardSize) {
                                const target = this.getPiece(tx, ty);
                                if (!target || target.c !== piece.c) {
                                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ñ…Ñ–Ğ´ Ğ±ĞµĞ·Ğ¿ĞµÑ‡Ğ½Ğ¸Ğ¹ (Ğ½Ğµ Ğ¿Ñ–Ğ´ ÑˆĞ°Ñ…)
                                    if (this.rulesEnabled) {
                                        if (this.simulateMoveAndCheckSafety(piece, cx, cy, tx, ty)) {
                                            this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: !!target });
                                        }
                                    } else {
                                        this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: !!target });
                                    }
                                }
                            }
                        }
                    }
                }
                // -----------------------------------------------------------------------------

               
                if (megaDefs[type]) {
                     const def = megaDefs[type];
                     const FLIP_Y_LIST = ['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'];
                     const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0], dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            if (moveType === 'slide' || moveType === 'slide_jump') castRay(dirX, dirY, limit);
                            else { let mul = comp.mul || 1; checkJump(dirX * mul, dirY * mul); }
                        }
                     };
                     if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }

                // --- ĞŸĞ†Ğ¨ĞĞšĞ˜ (Ğ¡ÑƒĞ²Ğ¾Ñ€Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ°) ---
                if (['â™™','â™Ÿ'].includes(type)) {
                    const dir = isWhite ? -1 : 1;
                    
                    // 1. Ğ’Ğ¿ĞµÑ€ĞµĞ´ Ğ½Ğ° 1 (ÑĞºÑ‰Ğ¾ Ğ¿ÑƒÑÑ‚Ğ¾)
                    const fwd1 = this.getPiece(cx, cy + dir);
                    if (!fwd1) {
                        this.highlightedMoves.push({ type: 'point', c: cx, r: cy + dir });
                        
                        // 2. Ğ’Ğ¿ĞµÑ€ĞµĞ´ Ğ½Ğ° 2 (ÑĞºÑ‰Ğ¾ Ğ½Ğµ Ñ…Ğ¾Ğ´Ğ¸Ğ² Ñ– Ğ¿ÑƒÑÑ‚Ğ¾)
                        if (!piece.hasMoved) {
                            const fwd2 = this.getPiece(cx, cy + dir * 2);
                            if (!fwd2) {
                                this.highlightedMoves.push({ type: 'point', c: cx, r: cy + dir * 2 });
                            }
                        }
                    }

                    // 3. ĞÑ‚Ğ°ĞºĞ¸ (ÑĞºÑ‰Ğ¾ Ğ²Ğ¾Ñ€Ğ¾Ğ³)
                    [1, -1].forEach(dx => {
                        const tx = cx + dx; const ty = cy + dir;
                        const t = this.getPiece(tx, ty);
                        if (t && t.c !== piece.c) {
                            this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: true });
                        }
                    });
                }
            }
            
            initUI() {
                const container = document.getElementById('pieceContainer');
                container.innerHTML = '';

                PIECE_CATEGORIES.forEach(cat => {
                    const block = document.createElement('div');
                    block.className = 'category-block';
                    if(cat.bg) block.style.backgroundColor = cat.bg;
                    const header = document.createElement('div');
                    header.className = 'grid-header';
                    header.innerText = cat.name;
                    block.appendChild(header);
                    const grid = document.createElement('div');
                    grid.className = 'piece-grid';

                    cat.items.forEach(item => {
                        const btn = document.createElement('button');
                        btn.className = `piece-btn ${item.cls || ''}`;
                        if(item.s === 'âŒ') btn.classList.add('eraser');

                        btn.innerText = item.s;
                        btn.title = item.t;
                        btn.dataset.s = item.s;
                        btn.dataset.c = item.color || 'w';
                        btn.addEventListener('click', () => {
                            document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            this.curSymbol = btn.dataset.s;
                            this.curColor = btn.dataset.c;
                        });
                        if(item.s === 'â™”' && item.color !== 'b') btn.classList.add('selected');
                        grid.appendChild(btn);
                    });
                    block.appendChild(grid);
                    container.appendChild(block);
                });
            }

            init() {
                this.setSize(32);
                this.resize();
                window.addEventListener('resize', () => { this.resize(); });
                this.canvas.addEventListener('wheel', e => this.onWheel(e), { passive: false });
                this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
                window.addEventListener('mousemove', e => this.onMouseMove(e));
                window.addEventListener('mouseup', e => this.onMouseUp(e));
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());

                window.addEventListener('keydown', e => {
                    if (e.key === 'Delete') {
                        this.undoMove();
                    } else {
                        this.onKeyDown(e);
                        if(this.keys.hasOwnProperty(e.code)) {
                            this.keys[e.code] = true;
                            e.preventDefault();
                        }
                    }
                });
                window.addEventListener('keyup', e => {
                    if(this.keys.hasOwnProperty(e.code)) this.keys[e.code] = false;
                });

                document.getElementById('boardSize').addEventListener('change', e => this.setSize(e.target.value));
                document.getElementById('zoomSlider').addEventListener('input', e => {
    const val = parseFloat(e.target.value);
    const newZoom = Math.pow(10, val);

    // 1. Ğ—Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€ ĞµĞºÑ€Ğ°Ğ½Ñƒ
    const screenCX = this.canvas.width / 2;
    const screenCY = this.canvas.height / 2;

    // 2. Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾, Ğ´Ğµ Ñ†ĞµĞ¹ Ñ†ĞµĞ½Ñ‚Ñ€ Ğ·Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒÑÑ Ñƒ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ°Ñ… Ñ–Ğ³Ñ€Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ÑĞ²Ñ–Ñ‚Ñƒ Ğ·Ğ°Ñ€Ğ°Ğ·
    const worldCX = (screenCX - this.camera.x) / this.camera.zoom;
    const worldCY = (screenCY - this.camera.y) / this.camera.zoom;

    // 3. Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ñ†Ñ–Ğ»ÑŒĞ¾Ğ²Ğ¸Ğ¹ Ğ·ÑƒĞ¼
    this.targetCamera.zoom = newZoom;

    // 4. ĞšĞ¾Ñ€Ğ¸Ğ³ÑƒÑ”Ğ¼Ğ¾ Ñ†Ñ–Ğ»ÑŒĞ¾Ğ²Ñƒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ ĞºĞ°Ğ¼ĞµÑ€Ğ¸, Ñ‰Ğ¾Ğ± ÑĞ²Ñ–Ñ‚ Ğ·Ğ°Ğ»Ğ¸ÑˆĞ¸Ğ²ÑÑ Ğ¿Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ñƒ
    this.targetCamera.x = screenCX - worldCX * newZoom;
    this.targetCamera.y = screenCY - worldCY * newZoom;
});
                document.getElementById('fantasyMix').addEventListener('input', (e) => {
                    document.getElementById('fantasyPercentDisplay').innerText = e.target.value + '%';
                });
                document.getElementById('turnIndicator').addEventListener('click', () => this.toggleTurnColor());

                this.lastTime = performance.now();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.centerBoard();
            }

            getPaletteId(s, c) {
                const key = s + c;
                if (!this.paletteMap.has(key)) {
                    this.palette.push({ s, c });
                    this.paletteMap.set(key, this.palette.length);
                }
                return this.paletteMap.get(key);
            }

            getKey(c, r) {
                return c + "," + r;
            }

            getCoordString(c, r) {
                let label = "";
                let index = c + 1;
                while (index > 0) {
                    let rem = (index - 1) % 26;
                    label = String.fromCharCode(97 + rem) + label;
                    index = Math.floor((index - 1) / 26);
                }
                return label + (this.boardSize - r);
            }

            addLogToUI(pieceIcon, startCoord, endCoord, isCapture) {
                const list = document.getElementById('logList');
                // Remove default placeholder if exists
                if (list.children.length === 1 && list.children[0].innerText === 'Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ”') {
                    list.innerHTML = '';
                }

                const div = document.createElement('div');
                div.className = 'log-entry';

                const moveText = `<span class="move">${pieceIcon}</span> ${startCoord} â†’ ${endCoord}`;
                const capText = isCapture ? `<span class="capture">âš”ï¸</span>` : '';

                div.innerHTML = `${moveText} ${capText}`;
                list.prepend(div); // Newest first
            }

            removeLastLogEntry() {
                const list = document.getElementById('logList');
                if (list.children.length > 0) {
                    list.removeChild(list.firstElementChild);
                }
                if (list.children.length === 0) {
                    list.innerHTML = '<div class="log-entry" style="color:#999; justify-content:center;">Ğ¥Ğ¾Ğ´Ñ–Ğ² Ñ‰Ğµ Ğ½ĞµĞ¼Ğ°Ñ”</div>';
                }
            }

            setSize(n) {
                // Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ "ÑĞ¸Ñ€Ğ¸Ğ¹" Ñ€ÑĞ´Ğ¾Ğº Ğ´Ğ»Ñ BigInt Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½ĞºÑ–Ğ²
                let rawVal = String(n).trim();
                
                // Ğ”Ğ»Ñ Ğ²Ğ½ÑƒÑ‚Ñ€Ñ–ÑˆĞ½ÑŒĞ¾Ñ— Ğ»Ğ¾Ğ³Ñ–ĞºĞ¸ Ğ³Ñ€Ğ¸ (Ñ€ĞµĞ½Ğ´ĞµÑ€Ñ–Ğ½Ğ³Ñƒ) Ğ½Ğ°Ğ¼ Ğ²ÑĞµ Ğ¾Ğ´Ğ½Ğ¾ Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±ĞµĞ½ Number.
                // Ğ¯ĞºÑ‰Ğ¾ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ·Ğ°Ğ²ĞµĞ»Ğ¸ĞºĞµ, Ğ²Ğ¾Ğ½Ğ¾ ÑÑ‚Ğ°Ğ½Ğµ Infinity, Ñ– Ñ†Ğµ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ´Ğ»Ñ Ñ€ĞµĞ½Ğ´ĞµÑ€Ğ° (Ğ¼Ğ¸ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¼Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ ÑĞºÑ–Ğ»ÑŒĞºĞ¸ Ğ²Ğ»Ğ°Ğ·Ğ¸Ñ‚ÑŒ).
                // ĞĞ»Ğµ Ğ¼Ğ¸ Ğ½Ğµ Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ¹Ğ¾Ğ¼Ñƒ Ğ±ÑƒÑ‚Ğ¸ Ğ¼ĞµĞ½ÑˆĞµ 2.
                let parsed = parseInt(rawVal);
                
                // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ½Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ - ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ 32. Ğ¯ĞºÑ‰Ğ¾ Ñ‡Ğ¸ÑĞ»Ğ¾ - Ğ±ĞµÑ€ĞµĞ¼Ğ¾ Ğ¹Ğ¾Ğ³Ğ¾ (Ğ°Ğ±Ğ¾ Infinity).
                this.boardSize = isNaN(parsed) ? 32 : Math.max(2, parsed);

                // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿Ğ¾Ğ»Ğµ Ğ²Ğ²Ğ¾Ğ´Ñƒ Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ ÑĞºÑ‰Ğ¾ Ñ†Ğµ Ğ½Ğµ Ñ€ÑƒÑ‡Ğ½Ğµ Ğ²Ğ²ĞµĞ´ĞµĞ½Ğ½Ñ
                // (Ñ‚Ğ¾Ğ±Ñ‚Ğ¾ ÑĞºÑ‰Ğ¾ Ğ¼Ğ¸ Ğ½Ğ°Ñ‚Ğ¸ÑĞ½ÑƒĞ»Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ "1M", Ğ° Ğ½Ğµ Ğ´Ñ€ÑƒĞºÑƒÑ”Ğ¼Ğ¾ ÑĞ°Ğ¼Ñ–)
                const inputEl = document.getElementById('boardSize');
                if (document.activeElement !== inputEl) {
                    inputEl.value = rawVal;
                }

                this.grid.clear();
                this.moveHistory = [];
                this.virtualGen = null;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';

                this.resetGame();
                this.centerBoard();
            }

            centerBoard() {
                const boardPx = this.boardSize * this.cellSize;
                const screenW = this.canvas.width;
                const screenH = this.canvas.height;
                
                const fitScaleX = screenW / boardPx;
                const fitScaleY = screenH / boardPx;
                const fitZoom = Math.min(fitScaleX, fitScaleY);

                this.minZoom = fitZoom * 0.8; 
                if (this.minZoom > this.maxZoom) this.minZoom = this.maxZoom / 2;

                const startZoom = fitZoom * 0.95;
                
                // Ğ¦ĞµĞ½Ñ‚Ñ€ÑƒÑ”Ğ¼Ğ¾
                const startX = (screenW - boardPx * startZoom) / 2;
                const startY = (screenH - boardPx * startZoom) / 2;

                // Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ¾
                this.camera.x = startX;
                this.camera.y = startY;
                this.camera.zoom = startZoom;

                // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğ¶ Ñ†Ñ–Ğ»Ñ–
                this.targetCamera.x = startX;
                this.targetCamera.y = startY;
                this.targetCamera.zoom = startZoom;

                const slider = document.getElementById('zoomSlider');
                slider.min = Math.log10(this.minZoom);
                slider.value = Math.log10(startZoom);
            }

            clampCamera() {
                // Ğ’Ğ†Ğ›Ğ¬ĞĞ• ĞŸĞ•Ğ Ğ•ĞœĞ†Ğ©Ğ•ĞĞĞ¯ Ğ— ĞœĞ•Ğ–ĞĞœĞ˜ (ĞĞĞ¢Ğ˜-ĞŸĞ£Ğ¡Ğ¢ĞĞ¢Ğ)
                
                const boardPx = this.boardSize * this.cellSize * this.camera.zoom;
                const screenW = this.canvas.width;
                const screenH = this.canvas.height;

                // "Ğ¡Ñ‚Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ñ‚Ñ€Ğ¾Ñ":
                // ĞœĞ¸ Ñ…Ğ¾Ñ‡ĞµĞ¼Ğ¾, Ñ‰Ğ¾Ğ± Ñ…Ğ¾Ñ‡Ğ° Ğ± 150 Ğ¿Ñ–ĞºÑĞµĞ»Ñ–Ğ² Ğ´Ğ¾ÑˆĞºĞ¸ (Ğ°Ğ±Ğ¾ Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ğ° Ñ—Ñ— Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€Ñƒ, ÑĞºÑ‰Ğ¾ Ğ²Ğ¾Ğ½Ğ° Ğ´ÑƒĞ¶Ğµ Ğ¼Ğ°Ğ»Ğ°)
                // Ğ·Ğ°Ğ²Ğ¶Ğ´Ğ¸ Ğ·Ğ°Ğ»Ğ¸ÑˆĞ°Ğ»Ğ¸ÑÑ Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¸Ğ¼Ğ¸ Ğ½Ğ° ĞµĞºÑ€Ğ°Ğ½Ñ–.
                const safeZone = Math.min(150, boardPx / 2);

                // Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº Ğ¼ĞµĞ¶:
                // 1. Min X: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ Ğ´Ğ¾ÑˆĞºĞ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğµ Ğ¿Ñ–Ñ‚Ğ¸ Ğ·Ğ° Ğ»Ñ–Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ ĞµĞºÑ€Ğ°Ğ½Ñƒ (Ğ·Ğ°Ğ»Ğ¸ÑˆĞ°Ñ”Ğ¼Ğ¾ safeZone)
                //    Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: camera.x + boardPx >= safeZone  =>  camera.x >= safeZone - boardPx
                const minX = safeZone - boardPx;

                // 2. Max X: Ğ›Ñ–Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ Ğ´Ğ¾ÑˆĞºĞ¸ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğµ Ğ¿Ñ–Ñ‚Ğ¸ Ğ·Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ¹ ĞºÑ€Ğ°Ğ¹ ĞµĞºÑ€Ğ°Ğ½Ñƒ
                //    Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: camera.x <= screenW - safeZone
                const maxX = screenW - safeZone;

                // 3. Ğ¢Ğµ ÑĞ°Ğ¼Ğµ Ğ´Ğ»Ñ Y (Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒ)
                const minY = safeZone - boardPx;
                const maxY = screenH - safeZone;

                // Ğ—Ğ°ÑÑ‚Ğ¾ÑĞ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ¼Ñ–Ñ‚Ğ¸ Ğ´Ğ¾ Ğ¦Ğ†Ğ›Ğ† (Ğ´Ğ»Ñ Ğ°Ğ½Ñ–Ğ¼Ğ°Ñ†Ñ–Ñ—)
                if (this.targetCamera.x < minX) this.targetCamera.x = minX;
                if (this.targetCamera.x > maxX) this.targetCamera.x = maxX;
                if (this.targetCamera.y < minY) this.targetCamera.y = minY;
                if (this.targetCamera.y > maxY) this.targetCamera.y = maxY;

                // Ğ—Ğ°ÑÑ‚Ğ¾ÑĞ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ¼Ñ–Ñ‚Ğ¸ Ğ´Ğ¾ ĞŸĞĞ¢ĞĞ§ĞĞĞ‡ ĞºĞ°Ğ¼ĞµÑ€Ğ¸ (Ğ´Ğ»Ñ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğ¾Ñ— Ñ€ĞµĞ°ĞºÑ†Ñ–Ñ— Ğ¼Ğ¸ÑˆĞºĞ¸)
                if (this.camera.x < minX) this.camera.x = minX;
                if (this.camera.x > maxX) this.camera.x = maxX;
                if (this.camera.y < minY) this.camera.y = minY;
                if (this.camera.y > maxY) this.camera.y = maxY;
            }
            onWheel(e) {
                if (this.promotionPending) return;
                e.preventDefault();

                // 1. Ğ”Ğµ Ğ¼Ğ¸ÑˆĞºĞ° Ğ·Ğ°Ñ€Ğ°Ğ· (Ğ½Ğ° ĞµĞºÑ€Ğ°Ğ½Ñ–)
                const mx = e.clientX;
                const my = e.clientY;

                // 2. Ğ”Ğµ Ğ¼Ğ¸ÑˆĞºĞ° Ñƒ "Ğ¡Ğ²Ñ–Ñ‚Ñ–" (Ğ½Ğ° Ğ´Ğ¾ÑˆÑ†Ñ–) Ğ· ĞŸĞĞ¢ĞĞ§ĞĞ˜Ğœ Ğ·ÑƒĞ¼Ğ¾Ğ¼
                // Ğ’Ğ°Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒĞ²Ğ°Ñ‚Ğ¸ this.camera (Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğµ), Ğ° Ğ½Ğµ target
                const worldX = (mx - this.camera.x) / this.camera.zoom;
                const worldY = (my - this.camera.y) / this.camera.zoom;

                // 3. Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ ĞĞĞ’Ğ˜Ğ™ Ğ·ÑƒĞ¼
                const sensitivity = 0.0015; // Ğ§ÑƒÑ‚Ğ»Ğ¸Ğ²Ñ–ÑÑ‚ÑŒ
                let newZoom = this.targetCamera.zoom * (1 - e.deltaY * sensitivity);
                newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));

                // 4. ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ñ†Ñ–Ğ»ÑŒ Ğ´Ğ»Ñ Ğ·ÑƒĞ¼Ñƒ
                this.targetCamera.zoom = newZoom;

                // 5. ĞœĞĞ“Ğ†Ğ¯ Ğ¡Ğ¢ĞĞ‘Ğ†Ğ›Ğ†Ğ—ĞĞ¦Ğ†Ğ‡:
                // Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾, Ğ´Ğµ Ğ¿Ğ¾Ğ²Ğ¸Ğ½Ğ½Ğ° Ğ±ÑƒÑ‚Ğ¸ ĞºĞ°Ğ¼ĞµÑ€Ğ° (X, Y), Ñ‰Ğ¾Ğ± Ñ‚Ğ¾Ñ‡ĞºĞ° worldX 
                // Ğ·Ğ°Ğ»Ğ¸ÑˆĞ¸Ğ»Ğ°ÑÑ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ–Ğ´ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ¾Ğ¼ (mx) Ğ¿Ñ€Ğ¸ ĞĞĞ’ĞĞœĞ£ Ğ·ÑƒĞ¼Ñ– (newZoom).
                // Ğ¤Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°: Screen = Cam + World * Zoom  =>  Cam = Screen - World * Zoom
                
                this.targetCamera.x = mx - worldX * newZoom;
                this.targetCamera.y = my - worldY * newZoom;
            }

            isDarkSquare(c, r) { return (c + r) % 2 !== 0; }

            getPieceSprite(symbol, color) {
                const key = `${symbol}_${color}`;
                if (this.spriteCache.has(key)) return this.spriteCache.get(key);

                // Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑƒÑ”Ğ¼Ğ¾ Ñ€Ğ¾Ğ·Ğ´Ñ–Ğ»ÑŒĞ½Ñƒ Ğ·Ğ´Ğ°Ñ‚Ğ½Ñ–ÑÑ‚ÑŒ Ğ´Ğ»Ñ Ñ‡Ñ–Ñ‚ĞºĞ¾ÑÑ‚Ñ–
                this.spriteSize = 256;

                const c = document.createElement('canvas');
                c.width = this.spriteSize;
                c.height = this.spriteSize;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();

                    // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ width/height Ñ– viewBox 0 0 45 45, Ñ‰Ğ¾Ğ± Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ñ€Ğ¾Ğ·Ñ‚ÑĞ³Ğ½ÑƒĞ»Ğ°ÑÑŒ Ğ½Ğ° Ğ²ĞµÑÑŒ ÑĞ¿Ñ€Ğ°Ğ¹Ñ‚
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${this.spriteSize}" height="${this.spriteSize}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0, 0, this.spriteSize, this.spriteSize);
                        ctx.drawImage(img, 0, 0, this.spriteSize, this.spriteSize);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;

                } else {
                    // Ğ”Ğ»Ñ Ñ„ĞµĞ½Ñ‚ĞµĞ·Ñ– Ñ„Ñ–Ğ³ÑƒÑ€
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `bold ${this.spriteSize * 0.8}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.lineWidth = this.spriteSize * 0.05; ctx.lineJoin = 'round';
                    const cx = this.spriteSize / 2; const cy = this.spriteSize / 2 * 1.1;

                    if (isWhite) ctx.strokeStyle = '#000000';
                    else if (isBlack) ctx.strokeStyle = '#ffffff';
                    else ctx.strokeStyle = '#333333';

                    ctx.strokeText(symbol, cx, cy);
                    ctx.fillStyle = isWhite ? this.colors.whiteP : (isBlack ? this.colors.blackP : this.colors.neutralP);
                    ctx.fillText(symbol, cx, cy);
                }

                this.spriteCache.set(key, c);
                return c;
            }

            getLowResSprite(symbol, color) {
                const key = `${symbol}_${color}_lo`;
                if (this.lowResCache.has(key)) return this.lowResCache.get(key);

                // Ğ—Ğ±Ñ–Ğ»ÑŒÑˆÑƒÑ”Ğ¼Ğ¾ ÑĞºÑ–ÑÑ‚ÑŒ "Ğ½Ğ¸Ğ·ÑŒĞºĞ¾Ñ— Ñ€Ğ¾Ğ·Ğ´Ñ–Ğ»ÑŒĞ½Ğ¾Ñ— Ğ·Ğ´Ğ°Ñ‚Ğ½Ğ¾ÑÑ‚Ñ–"
                const size = 128;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');

                const svgKey = CLASSIC_MAP[symbol];

                if (svgKey && ((color === 'w' && svgKey.startsWith('w')) || (color === 'b' && svgKey.startsWith('b')))) {
                    const svgContent = CHESS_SVGS[svgKey];
                    const img = new Image();
                    // Ğ¢ĞµĞ¶ ÑĞ°Ğ¼Ğµ: Ñ„Ñ–ĞºÑÑƒÑ”Ğ¼Ğ¾ Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€ SVG Ğ¿Ñ–Ğ´ ĞºĞ°Ğ½Ğ²Ğ°Ñ
                    const svgData = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 45 45">${svgContent}</svg>`;
                    const blob = new Blob([svgData], {type: 'image/svg+xml'});
                    const url = URL.createObjectURL(blob);

                    img.onload = () => {
                        ctx.clearRect(0,0,size,size);
                        ctx.drawImage(img, 0, 0, size, size);
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;
                } else {
                    const isWhite = color === 'w'; const isBlack = color === 'b';
                    ctx.font = `${size}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    const cx = size / 2; const cy = size / 2 * 1.1;
                    ctx.fillStyle = isWhite ? '#fff' : (isBlack ? '#000' : '#fa0');
                    ctx.fillText(symbol, cx, cy);
                }

                this.lowResCache.set(key, c);
                return c;
            }

            pseudoRandom(x, y) {
                return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
            }

            getPiece(c, r) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return null;

                const key = this.getKey(c, r);
                const val = this.grid.get(key);

                if (val !== undefined) {
                    if (val === GRID_VOID) return null;
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    return { x: c, y: r, s: p.s, c: p.c, hasMoved: hasMoved };
                }

                if (this.virtualGen) {
                    return this.getVirtualPiece(c, r);
                }

                return null;
            }
getVirtualPiece(c, r) {
                if (this.virtualGen === 'checkers') {
                     const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                     const armyHeight = rowsCalc;
                     if (!this.isDarkSquare(c, r)) return null;

                     if (r < armyHeight) return { x:c, y:r, s:'â›‚', c:'b' };
                     if (r >= this.boardSize - armyHeight) return { x:c, y:r, s:'â›€', c:'w' };
                     return null;
                }

                const rowsCalc = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                const armyHeight = Math.max(2, rowsCalc);
                const whiteStart = this.boardSize - armyHeight;

                let relativeRow = -1;
                let color = '';

                // Identify if this row belongs to an army and normalize row index
                if (r < armyHeight) {
                    color = 'b';
                    relativeRow = r;
                } else if (r >= whiteStart) {
                    color = 'w';
                    relativeRow = (this.boardSize - 1) - r; // Mirror row index
                } else {
                    return null;
                }

                // --- Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯ Ğ¢Ğ£Ğ¢: ĞŸÑ€Ğ¸Ğ¼ÑƒÑĞ¾Ğ²Ğ¾ Ğ²ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¸Ğ¹ Y ---
                const p = this.generateProceduralPiece(c, relativeRow, color, armyHeight);
                if (p) p.y = r; 
                return p;
            }
            
            generateProceduralPiece(c, relativeRow, color, height) {
                // 1. Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€ Ğ´Ğ»Ñ ĞšĞ¾Ñ€Ğ¾Ğ»Ñ (Ğ±ĞµĞ·Ğ¿ĞµĞºĞ°)
                let armyCenterCol = Math.floor(this.boardSize / 2);

                if (this.virtualGen === '3player') {
                    if (color === 'b') armyCenterCol = Math.floor((this.boardSize / 2) / 2);
                    else if (color === 'r') {
                        const mid = Math.floor(this.boardSize / 2);
                        armyCenterCol = mid + Math.floor((this.boardSize - mid) / 2);
                    }
                }

                // Ğ—Ğ°Ğ²Ğ¶Ğ´Ğ¸ ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ "Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾" ĞºĞ¾Ñ€Ğ¾Ğ»Ñ Ğ¿Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ñƒ (Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ñ–ĞºĞ¸ Ğ³Ñ€Ğ¸)
                if (c === armyCenterCol && relativeRow === 0) {
                    return { x: c, y: -1, s: color === 'w' ? 'â™”' : 'â™š', c: color };
                }
                
                // --- ĞĞĞ’Ğ Ğ›ĞĞ“Ğ†ĞšĞ Ğ”Ğ›Ğ¯ ĞĞ ĞœĞ†Ğ‡ (Ğ©Ğ¾Ğ± Ğ½Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ°Ğ»Ğ¾) ---
                if (this.virtualGen === 'army') {
                    // ĞŸĞ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ğ° Ñ€ÑĞ´Ñ–Ğ² - Ğ¾Ñ„Ñ–Ñ†ĞµÑ€Ğ¸, Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ğ° - Ğ¿Ñ–ÑˆĞ°ĞºĞ¸
                    const officerRows = Math.floor(height / 2);
                    
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ– Ñ€ÑĞ´Ğ¸ - ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ ĞŸÑ–ÑˆĞ°ĞºÑ–Ğ²
                    if (relativeRow >= officerRows) {
                         return { x: c, y: -1, s: color === 'w' ? 'â™™' : 'â™Ÿ', c: color };
                    }
                    
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ·Ğ°Ğ´Ğ½Ñ– Ñ€ÑĞ´Ğ¸ - ÑÑ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ğ¿Ğ°Ñ‚ĞµÑ€Ğ½ ĞÑ„Ñ–Ñ†ĞµÑ€Ñ–Ğ²
                    const pattern = ['â™–', 'â™˜', 'â™—', 'â™•', 'â™”', 'â™—', 'â™˜', 'â™–'];
                    const mirrorMap = { 'â™–':'â™œ', 'â™˜':'â™', 'â™—':'â™', 'â™•':'â™›', 'â™”':'â™š' };
                    
                    let sym = pattern[c % 8]; // ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ¶Ğ½Ñ– 8 ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ğ¾Ğº
                    if (color !== 'w') sym = mirrorMap[sym]; // Ğ”Ğ»Ñ Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ…/Ñ‡ĞµÑ€Ğ²Ğ¾Ğ½Ğ¸Ñ…
                    
                    return { x: c, y: -1, s: sym, c: color };
                }
                // -----------------------------------------------

                // Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ– Ğ¿Ñ–ÑˆĞ°ĞºĞ¸ Ğ´Ğ»Ñ Ñ–Ğ½ÑˆĞ¸Ñ… Ñ€ĞµĞ¶Ğ¸Ğ¼Ñ–Ğ² (Classic/Fantasy)
                if (relativeRow === height - 1) {
                    return { x: c, y: -1, s: color === 'w' ? 'â™™' : 'â™Ÿ', c: color };
                }

                // Ğ›Ğ¾Ğ³Ñ–ĞºĞ° Ğ´Ğ»Ñ Classic/Fantasy (Random)
                const classicMajors = ['â™–', 'â™˜', 'â™—', 'â™•'];
                const mirrorMap = { 'â™–': 'â™œ', 'â™˜': 'â™', 'â™—': 'â™', 'â™•': 'â™›' };
                const fantasyMajors = ['ğŸ¦„', 'ğŸ¦…', 'ğŸ²', 'ğŸ•·ï¸', 'ğŸ¢', 'ğŸ§¨', 'ğŸ«', 'ğŸ¦“', 'ğŸ¦’', 'ğŸ˜', 'ğŸšœ', 'âš”ï¸', 'ğŸ›¡ï¸', 'ğŸ‘¨', 'ğŸ¦—', 'ğŸ¦‡', 'ğŸ¹', 'ğŸ»', 'ğŸ•', 'ğŸ¦€', 'ğŸ†', 'ğŸ¿ï¸', 'ğŸ¤´', 'ğŸ‘¼', 'ğŸ‘º', 'ğŸ„', 'ğŸŒµ', 'ğŸŒ²', 'ğŸ', 'ğŸŒ‹', 'ğŸŒŠ', 'ğŸŒªï¸', 'ğŸŒ©ï¸', 'ğŸ¦‚', 'ğŸ', 'ğŸ¦–', 'ğŸ¦ˆ', 'ğŸ', 'ğŸ¦‹', 'ğŸ™', 'ğŸ‘¾', 'ğŸ—¡ï¸', 'ğŸ”®', 'ğŸ“œ', 'ğŸ’', 'âš—ï¸', 'ğŸ’£', 'ğŸ§©', 'ğŸ²', 'ğŸ§¬', 'âš›ï¸', ...Object.keys(megaDefs)];
                
                const seed = c * 49297 + relativeRow * 9301 + this.generationSeed;
                const rnd = Math.abs(Math.sin(seed) * 10000) % 100;
                let symbol;

                if (this.virtualGen === 'fantasy' && rnd < this.virtualProps.mix) {
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 5) * fantasyMajors.length);
                    symbol = fantasyMajors[idx];
                } else {
                    const idx = Math.floor(this.pseudoRandom(c + this.generationSeed, relativeRow * 7) * classicMajors.length);
                    let base = classicMajors[idx];
                    if (color !== 'w') symbol = mirrorMap[base];
                    else symbol = base;
                }
                return { x: c, y: -1, s: symbol, c: color };
            }

            setPiece(c, r, data) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return;
                const key = this.getKey(c, r);

                if (!data) {
                    if (this.virtualGen) {
                        this.grid.set(key, GRID_VOID);
                    } else {
                        this.grid.delete(key);
                    }
                    return;
                }

                const paletteId = this.getPaletteId(data.s, data.c);
                const hasMovedBit = (data.hasMoved ? 1 : 0) << 16;
                this.grid.set(key, paletteId | hasMovedBit);

                if (data.s === 'â™”' && data.c === 'w') this.kingPos.w = {c, r};
                if (data.s === 'â™š' && data.c === 'b') this.kingPos.b = {c, r};
            }

            removePiece(c, r) { this.setPiece(c, r, null); }
            
            updateLogUI() {
                const tbody = document.getElementById('logTableBody');
                if (!tbody) return;
                tbody.innerHTML = '';
                
                let moveCount = 1;
                let currentRow = null;

                this.moveHistory.forEach((step) => {
                    const not = step.notation;
                    if (!not) return; // ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ ÑÑ‚Ğ°Ñ€Ñ–/Ğ±Ğ¸Ñ‚Ñ– Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸

                    const moveHTML = `<span class="move-icon">${not.icon}</span><span class="move-coords">${not.start}â†’${not.end}</span>${not.cap ? '<span class="move-cap">x</span>' : ''}`;

                    if (step.turn === 'w') {
                        // Ğ¥Ñ–Ğ´ Ğ±Ñ–Ğ»Ğ¸Ñ… - ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ”Ğ¼Ğ¾ Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ñ€ÑĞ´Ğ¾Ğº
                        currentRow = document.createElement('tr');
                        currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>${moveHTML}</td><td></td>`;
                        tbody.appendChild(currentRow);
                    } else {
                        // Ğ¥Ñ–Ğ´ Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ…
                        if (!currentRow) {
                            // Ğ¯ĞºÑ‰Ğ¾ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ğ¿Ğ¾Ñ‡Ğ°Ğ»Ğ°ÑÑ Ğ· Ñ‡Ğ¾Ñ€Ğ½Ğ¸Ñ… (Ñ€Ñ–Ğ´ĞºÑ–ÑĞ½Ğ¸Ğ¹ Ğ²Ğ¸Ğ¿Ğ°Ğ´Ğ¾Ğº)
                            currentRow = document.createElement('tr');
                            currentRow.innerHTML = `<td class="log-num">${moveCount}.</td><td>...</td><td></td>`;
                            tbody.appendChild(currentRow);
                        }
                        currentRow.children[2].innerHTML = moveHTML;
                        moveCount++;
                        currentRow = null;
                    }
                });
                
                // ĞŸÑ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ° Ğ²Ğ½Ğ¸Ğ·
                const container = document.getElementById('logContainer');
                if(container) container.scrollTop = container.scrollHeight;
            }

            resetGame() {
                this.customArrows = [];

                this.grid.clear();
                this.moveHistory = [];
                this.pieceCount = 0;
                this.currentTurn = 'w'; this.gameOver = false;
                this.multiJumpSource = null;
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.updateUI(); 
                this.updateTurnIndicator();
                this.updateLogUI(); // <--- Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ–
            }

            fillCheckers() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.virtualGen = 'checkers';
                this.virtualProps.percent = percent;
                this.updateUI();
            }

            fillClassic() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'classic';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = 0;
                this.updateUI();
            }
            fillArmy() {
                // ĞÑ‚Ñ€Ğ¸Ğ¼ÑƒÑ”Ğ¼Ğ¾ Ğ²Ñ–Ğ´ÑĞ¾Ñ‚Ğ¾Ğº Ğ·Ğ°Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½Ñ
                let percent = parseFloat(document.getElementById('fillPercent').value);
                if (isNaN(percent) || percent < 1) percent = 1; 
                if (percent > 50) percent = 50;

                this.resetGame();
                
                // Ğ’ĞœĞ˜ĞšĞĞ„ĞœĞ Ğ’Ğ†Ğ Ğ¢Ğ£ĞĞ›Ğ¬ĞĞ£ Ğ“Ğ•ĞĞ•Ğ ĞĞ¦Ğ†Ğ® Ğ—ĞĞœĞ†Ğ¡Ğ¢Ğ¬ Ğ¦Ğ˜ĞšĞ›Ğ£
                this.virtualGen = 'army'; 
                this.virtualProps.percent = percent;
                
                this.updateUI();
                console.log("Mode: Army (Optimized/Virtual)");
            }
            fillChess960() {
                this.resetGame();
                this.virtualGen = null; // Ğ’Ğ¸Ğ¼Ğ¸ĞºĞ°Ñ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ´ÑƒÑ€Ğ½Ñƒ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ

                // Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¸ Ñ€ÑĞ´Ñ–Ğ²
                const whiteRow = this.boardSize - 1;
                const whitePawnRow = this.boardSize - 2;
                const blackRow = 0;
                const blackPawnRow = 1;

                // Ğ¯ĞºÑ‰Ğ¾ Ğ´Ğ¾ÑˆĞºĞ° ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ° (8 ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ğ¾Ğº) â€” ĞºĞ»Ğ°ÑĞ¸Ñ‡Ğ½Ğ¸Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ 960
                // Ğ¯ĞºÑ‰Ğ¾ Ğ²ĞµĞ»Ğ¸ĞºĞ° â€” Ñ€Ğ¾Ğ·ÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼
                const width = this.boardSize;
                let rank = new Array(width).fill(null);
                let available = Array.from({length: width}, (_, i) => i);

                // --- Ğ›ĞĞ“Ğ†ĞšĞ Ğ“Ğ•ĞĞ•Ğ ĞĞ¦Ğ†Ğ‡ ---

                // 1. ĞšĞĞ ĞĞ›Ğ¬: Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ğ´ĞµÑÑŒ Ğ±Ğ»Ğ¸Ğ¶Ñ‡Ğµ Ğ´Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ñƒ
                // Ğ©Ğ¾Ğ± Ğ½Ğµ Ğ·Ğ°Ğ³Ğ½Ğ°Ñ‚Ğ¸ Ğ¹Ğ¾Ğ³Ğ¾ Ğ² ĞºÑƒÑ‚ Ğ½Ğ° Ğ´Ğ¾ÑˆÑ†Ñ– 100Ñ…100
                const centerStart = Math.floor(width * 0.3);
                const centerEnd = Math.floor(width * 0.7);
                const possibleKingSpots = available.filter(i => i >= centerStart && i <= centerEnd);
                
                const kIdx = Math.floor(Math.random() * possibleKingSpots.length);
                const kPos = possibleKingSpots[kIdx];
                rank[kPos] = 'â™”';
                
                // Ğ’Ğ¸Ğ´Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ Ğ·Ñ– ÑĞ¿Ğ¸ÑĞºÑƒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ñ…
                available = available.filter(i => i !== kPos);

                // 2. Ğ¢Ğ£Ğ Ğ˜: ĞœÑ–Ğ½Ñ–Ğ¼ÑƒĞ¼ Ğ¾Ğ´Ğ½Ğ° Ğ·Ğ»Ñ–Ğ²Ğ° Ñ– Ğ¾Ğ´Ğ½Ğ° ÑĞ¿Ñ€Ğ°Ğ²Ğ° Ğ²Ñ–Ğ´ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ
                const leftSide = available.filter(i => i < kPos);
                const rightSide = available.filter(i => i > kPos);

                if (leftSide.length === 0 || rightSide.length === 0) {
                    // Ğ¦Ğµ Ñ‚ĞµĞ¾Ñ€ĞµÑ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ½ĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¾ Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ centerStart, Ğ°Ğ»Ğµ Ğ¿Ñ€Ğ¾ Ğ²ÑÑĞº Ğ²Ğ¸Ğ¿Ğ°Ğ´Ğ¾Ğº
                    alert("ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ— (Ğ·Ğ°Ğ¼Ğ°Ğ»Ğ° Ğ´Ğ¾ÑˆĞºĞ°)"); 
                    return;
                }

                const r1 = leftSide[Math.floor(Math.random() * leftSide.length)];
                const r2 = rightSide[Math.floor(Math.random() * rightSide.length)];
                rank[r1] = 'â™–';
                rank[r2] = 'â™–';
                
                // ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ available
                available = available.filter(i => i !== r1 && i !== r2);

                // 3. Ğ¡Ğ›ĞĞĞ˜: Ğ“ĞµĞ½ĞµÑ€ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼Ğ¸ (Ñ€Ñ–Ğ·Ğ½Ğ¾ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ğ¾Ğ²Ğ¸Ğ¼Ğ¸)
                // ĞĞ° Ğ²ĞµĞ»Ğ¸ĞºĞ¸Ñ… Ğ´Ğ¾ÑˆĞºĞ°Ñ… ÑĞ»Ğ¾Ğ½Ñ–Ğ² Ğ¼Ğ°Ñ” Ğ±ÑƒÑ‚Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆĞµ. Ğ¡ĞºĞ°Ğ¶Ñ–Ğ¼Ğ¾, ~15% Ñ„Ñ–Ğ³ÑƒÑ€.
                let bishopsCount = Math.max(2, Math.floor(width * 0.15));
                if (bishopsCount % 2 !== 0) bishopsCount++; // Ğ Ğ¾Ğ±Ğ¸Ğ¼Ğ¾ Ğ¿Ğ°Ñ€Ğ½Ğ¸Ğ¼

                // Ğ Ğ¾Ğ·Ğ´Ñ–Ğ»ÑÑ”Ğ¼Ğ¾ Ğ²Ñ–Ğ»ÑŒĞ½Ñ– ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸ Ğ½Ğ° Ğ±Ñ–Ğ»Ñ– Ñ‚Ğ° Ñ‡Ğ¾Ñ€Ğ½Ñ– (Ğ¿Ğ°Ñ€Ğ½Ñ–/Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ñ– Ñ–Ğ½Ğ´ĞµĞºÑĞ¸)
                // Ğ£Ğ²Ğ°Ğ³Ğ°: Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ñƒ Ğ·Ğ°Ğ»ĞµĞ¶Ğ¸Ñ‚ÑŒ Ğ²Ñ–Ğ´ (col + row), Ğ°Ğ»Ğµ Ğ¾ÑĞºÑ–Ğ»ÑŒĞºĞ¸ row Ğ¾Ğ´Ğ½Ğ°ĞºĞ¾Ğ²Ğ¸Ğ¹, 
                // Ñ‚Ğ¾ Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½ÑŒĞ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ‚Ğ¸ Ğ¿Ğ°Ñ€Ğ½Ñ–ÑÑ‚ÑŒ Ñ–Ğ½Ğ´ĞµĞºÑÑƒ column.
                let evens = available.filter(i => i % 2 === 0);
                let odds = available.filter(i => i % 2 !== 0);

                for (let i = 0; i < bishopsCount / 2; i++) {
                    if (evens.length > 0 && odds.length > 0) {
                        // Ğ‘ĞµÑ€ĞµĞ¼Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ğ· Ğ¿Ğ°Ñ€Ğ½Ğ¾Ğ³Ğ¾
                        const eIdx = Math.floor(Math.random() * evens.length);
                        const ePos = evens[eIdx];
                        rank[ePos] = 'â™—';
                        evens.splice(eIdx, 1);

                        // Ğ‘ĞµÑ€ĞµĞ¼Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ğ· Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğ¾Ğ³Ğ¾
                        const oIdx = Math.floor(Math.random() * odds.length);
                        const oPos = odds[oIdx];
                        rank[oPos] = 'â™—';
                        odds.splice(oIdx, 1);
                    }
                }

                // Ğ—Ğ±Ğ¸Ñ€Ğ°Ñ”Ğ¼Ğ¾ Ğ·Ğ°Ğ»Ğ¸ÑˆĞ¾Ğº available Ğ· Ğ½ĞµĞ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ¸Ñ… Ğ¿Ğ°Ñ€Ğ½Ğ¸Ñ…/Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğ¸Ñ…
                available = [...evens, ...odds];

                // 4. Ğ—ĞĞŸĞĞ’ĞĞ•ĞĞĞ¯ (Ğ¤ĞµÑ€Ğ·Ñ–, ĞšĞ¾Ğ½Ñ– Ñ‚Ğ° Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ñ– Ğ¢ÑƒÑ€Ğ¸)
                // ĞĞ° Ğ²ĞµĞ»Ğ¸ĞºĞ¸Ñ… Ğ´Ğ¾ÑˆĞºĞ°Ñ… Ğ´Ğ¾Ğ´Ğ°Ğ¼Ğ¾ Ñ‚Ñ€Ğ¾Ñ…Ğ¸ Ñ€Ñ–Ğ·Ğ½Ğ¾Ğ¼Ğ°Ğ½Ñ–Ñ‚Ñ‚Ñ
                available.forEach(pos => {
                    const rand = Math.random();
                    if (rand < 0.45) rank[pos] = 'â™˜';       // 45% ĞšÑ–Ğ½ÑŒ
                    else if (rand < 0.80) rank[pos] = 'â™•';  // 35% Ğ¤ĞµÑ€Ğ·ÑŒ
                    else rank[pos] = 'â™–';                   // 20% Ğ”Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ğ° Ğ¢ÑƒÑ€Ğ°
                });

                // --- Ğ ĞĞ—ĞœĞ†Ğ©Ğ•ĞĞĞ¯ ĞĞ Ğ”ĞĞ¨Ğ¦Ğ† ---
                const blackMirror = { 'â™–':'â™œ', 'â™˜':'â™', 'â™—':'â™', 'â™•':'â™›', 'â™”':'â™š' };

                for (let c = 0; c < width; c++) {
                    const wSym = rank[c];
                    const bSym = blackMirror[wSym];

                    // Ğ‘Ñ–Ğ»Ñ–
                    this.setPiece(c, whiteRow, { s: wSym, c: 'w' });
                    this.setPiece(c, whitePawnRow, { s: 'â™™', c: 'w' });

                    // Ğ§Ğ¾Ñ€Ğ½Ñ– (Ğ´Ğ·ĞµÑ€ĞºĞ°Ğ»ÑŒĞ½Ğ¾)
                    this.setPiece(c, blackRow, { s: bSym, c: 'b' });
                    this.setPiece(c, blackPawnRow, { s: 'â™Ÿ', c: 'b' });
                }

                this.updateUI();
                console.log(`Mega 960 Generated: Size ${width}`);
            }

            fillFantasy() {
                let percent = parseFloat(document.getElementById('fillPercent').value);
                let mix = parseFloat(document.getElementById('fantasyMix').value);
                if (isNaN(percent) || percent < 1) percent = 1; if (percent > 50) percent = 50;
                this.resetGame();
                this.generationSeed = Math.random() * 100000; // Change seed
                this.virtualGen = 'fantasy';
                this.virtualProps.percent = percent;
                this.virtualProps.mix = mix;
                this.updateUI();
            }

            clear() {
                this.virtualGen = null;
                this.resetGame();
            }

            saveGame() {
                const pieces = [];
                // Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ Ğ»Ğ¸ÑˆĞµ Ğ·Ğ¼Ñ–Ğ½ĞµĞ½Ñ– Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸ (Ñ‚Ñ–, Ñ‰Ğ¾ Ñƒ grid)
                for (const [key, val] of this.grid) {
                    const coord = key.split(',').map(Number);
                    if (val === GRID_VOID) {
                        pieces.push({ x: coord[0], y: coord[1], void: true });
                        continue;
                    }
                    const id = val & 0xFFFF;
                    const hasMoved = !!((val >> 16) & 1);
                    const p = this.palette[id - 1];
                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ½Ğ° Ñ–ÑĞ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ, Ñ‰Ğ¾Ğ± ÑƒĞ½Ğ¸ĞºĞ½ÑƒÑ‚Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ğ¾Ğº
                    if (p) {
                        pieces.push({
                            x: coord[0], y: coord[1], s: p.s, c: p.c, m: hasMoved ? 1 : 0
                        });
                    }
                }

                const saveData = {
                    format: "MegaChess_v5_Full", // ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚
                    timestamp: Date.now(),
                    boardSize: this.boardSize,
                    turn: this.currentTurn,
                    virtualGen: this.virtualGen,
                    virtualProps: this.virtualProps,
                    generationSeed: this.generationSeed,
                    moveHistory: this.moveHistory,
                    palette: this.palette, // Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ: Ğ—Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ Ğ¿Ğ°Ğ»Ñ–Ñ‚Ñ€Ñƒ Ğ´Ğ»Ñ ĞºĞ¾Ñ€ĞµĞºÑ‚Ğ½Ğ¾ÑÑ‚Ñ– Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ—
                    pieces: pieces
                };

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(saveData));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                const date = new Date().toISOString().slice(0,10);
                downloadAnchorNode.setAttribute("download", `megachess_${this.boardSize}x_${date}.json`);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            loadGame(inputElement) {
                const file = inputElement.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.applyLoadedData(data);
                    } catch (err) {
                        alert("ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ Ñ„Ğ°Ğ¹Ğ»Ñƒ! ĞŸĞµÑ€ĞµĞºĞ¾Ğ½Ğ°Ğ¹Ñ‚ĞµÑÑ, Ñ‰Ğ¾ Ñ†Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¸Ğ¹ JSON.");
                        console.error(err);
                    }
                    inputElement.value = '';
                };
                reader.readAsText(file);
            }

            applyLoadedData(data) {
                // ĞŸĞ¾Ğ²Ğ½Ğµ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½ÑĞ¼
                this.grid.clear();
                this.moveHistory = [];
                this.kingsInCheck = { w: null, b: null };
                this.kingPos = { w: null, b: null };
                this.promotionPending = null;
                
                // ĞÑ‡Ğ¸Ñ‰ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ°Ğ»Ñ–Ñ‚Ñ€Ñƒ, Ñ‰Ğ¾Ğ± ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ñ–Ğ·ÑƒĞ²Ğ°Ñ‚Ğ¸ ID Ğ· Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ¸Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ¼
                this.palette = [];
                this.paletteMap.clear();

                if (data.boardSize) {
                    document.getElementById('boardSize').value = data.boardSize;
                    this.boardSize = data.boardSize;
                }

                this.virtualGen = data.virtualGen || null;
                if (data.virtualProps) this.virtualProps = data.virtualProps;
                if (data.generationSeed) this.generationSeed = data.generationSeed;

                this.currentTurn = data.turn || 'w';

                // 1. Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ĞŸĞĞ›Ğ†Ğ¢Ğ Ğ˜ (ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ´Ğ»Ñ ĞºĞ¾Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ñ— Ñ€Ğ¾Ğ±Ğ¾Ñ‚Ğ¸ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ñ‚Ğ° Undo/Redo)
                if (Array.isArray(data.palette)) {
                    this.palette = data.palette;
                    // Ğ’Ñ–Ğ´Ğ±ÑƒĞ´Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ¼Ğ°Ğ¿Ñƒ Ğ´Ğ»Ñ ÑˆĞ²Ğ¸Ğ´ĞºĞ¾Ğ³Ğ¾ Ğ¿Ğ¾ÑˆÑƒĞºÑƒ
                    this.palette.forEach((p, index) => {
                        this.paletteMap.set(p.s + p.c, index + 1);
                    });
                }

                // 2. Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ„Ñ–Ğ³ÑƒÑ€ Ğ½Ğ° Ğ´Ğ¾ÑˆÑ†Ñ–
                if (Array.isArray(data.pieces)) {
                    data.pieces.forEach(p => {
                        if (p.x >= 0 && p.x < this.boardSize && p.y >= 0 && p.y < this.boardSize) {
                            if (p.void) {
                                this.grid.set(this.getKey(p.x, p.y), GRID_VOID);
                            } else {
                                this.setPiece(p.x, p.y, { s: p.s, c: p.c, hasMoved: !!p.m });
                            }
                        }
                    });
                }

                // 3. Ğ’Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ— Ñ‚Ğ° Ğ»Ğ¾Ğ³Ñƒ
                const logList = document.getElementById('logTableBody'); // Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¸Ğ¹ ID Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ–
                if (logList) logList.innerHTML = ''; 

                if (data.moveHistory && Array.isArray(data.moveHistory)) {
                    this.moveHistory = data.moveHistory;
                    this.updateLogUI(); // ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ Ñ…Ğ¾Ğ´Ñ–Ğ²
                }

                this.updateTurnIndicator();
                this.centerBoard();
                this.updateUI();

                console.log("ğŸ“‚ Ğ“Ñ€Ğ° ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ° Ğ· Ğ¿Ğ¾Ğ²Ğ½Ğ¾Ñ Ğ¿Ğ°Ğ»Ñ–Ñ‚Ñ€Ğ¾Ñ.");
            }

                // Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ğµ Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ½Ñ Ğ² Ğ»Ğ¾Ğ³ Ğ¿Ñ€Ğ¾ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğµ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ
               

            getFileLabel(index) { let label = ""; index++; while (index > 0) { let rem = (index - 1) % 26; label = String.fromCharCode(97 + rem) + label; index = Math.floor((index - 1) / 26); } return label; }
            isPathClear(c1, r1, c2, r2) { const dx = Math.sign(c2 - c1); const dy = Math.sign(r2 - r1); let x = c1 + dx; let y = r1 + dy; while (x !== c2 || y !== r2) { if (this.getPiece(x,y)) return false; x += dx; y += dy; } return true; }

             canCheckersCapture(piece, cx, cy, ignoredPiece) {
                const isKing = ['â›', 'â›ƒ'].includes(piece.s);
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                for (const d of dirs) {
                    if (!isKing) {
                        // Ğ›Ğ¾Ğ³Ñ–ĞºĞ° Ğ¿Ñ–ÑˆĞ°ĞºĞ°
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;
                        
                        // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ñ†Ğµ Ğ½Ğµ Ñ‚Ğ° ÑĞ°Ğ¼Ğ° Ñ„Ñ–Ğ³ÑƒÑ€Ğ°, ÑĞºÑƒ Ğ¼Ğ¸ Ñ‰Ğ¾Ğ¹Ğ½Ğ¾ Ğ¿Ğ¾Ğ±Ğ¸Ğ»Ğ¸ (ignoredPiece)
                        if (enemyX === ignoredPiece.x && enemyY === ignoredPiece.y) continue;

                        if (landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);
                            if (enemy && enemy.c !== piece.c && !landing) return true;
                        }
                    } else {
                        // Ğ›Ğ¾Ğ³Ñ–ĞºĞ° Ğ”Ğ°Ğ¼ĞºĞ¸ (ÑĞºĞ°Ğ½ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ½Ñ–)
                        for (let dist = 1; dist < this.boardSize; dist++) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;
                            
                            // Ğ¯ĞºÑ‰Ğ¾ Ğ½Ğ°Ñ‚Ñ€Ğ°Ğ¿Ğ¸Ğ»Ğ¸ Ğ½Ğ° "Ñ–Ğ³Ğ½Ğ¾Ñ€Ğ¾Ğ²Ğ°Ğ½Ñƒ" (Ñ‰Ğ¾Ğ¹Ğ½Ğ¾ Ğ¿Ğ¾Ğ±Ğ¸Ñ‚Ñƒ) Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ Ñ—Ñ— ÑĞº Ğ¿Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ñ” Ğ¼Ñ–ÑÑ†Ğµ
                            if (tx === ignoredPiece.x && ty === ignoredPiece.y) continue;

                            const target = this.getPiece(tx, ty);
                            
                            if (target) {
                                if (target.c !== piece.c) {
                                    // Ğ—Ğ½Ğ°Ğ¹ÑˆĞ»Ğ¸ Ğ²Ğ¾Ñ€Ğ¾Ğ³Ğ°, Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ñ‡Ğ¸ Ñ” Ğ¼Ñ–ÑÑ†Ğµ Ğ·Ğ° Ğ½Ğ¸Ğ¼
                                    // ĞŸĞ¾Ñ‚Ñ€Ñ–Ğ±Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€Ğ¸Ñ‚Ğ¸ Ñ…Ğ¾Ñ‡Ğ° Ğ± Ğ¾Ğ´Ğ½Ñƒ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºÑƒ Ğ·Ğ° Ğ²Ğ¾Ñ€Ğ¾Ğ³Ğ¾Ğ¼
                                    let landDist = 1;
                                    while (true) {
                                        const lx = tx + d[0] * landDist;
                                        const ly = ty + d[1] * landDist;
                                        if (lx < 0 || lx >= this.boardSize || ly < 0 || ly >= this.boardSize) break;
                                        
                                        const landingPiece = this.getPiece(lx, ly);
                                        // Ğ¯ĞºÑ‰Ğ¾ Ğ½Ğ°Ñ‚Ñ€Ğ°Ğ¿Ğ¸Ğ»Ğ¸ Ğ½Ğ° Ñ‰Ğµ Ğ¾Ğ´Ğ½Ñƒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ Ğ·Ñ€Ğ°Ğ·Ñƒ Ğ¶, Ğ±Ñ–Ğ¹ Ğ½ĞµĞ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¸Ğ¹ Ğ² Ñ†ÑŒĞ¾Ğ¼Ñƒ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ĞºÑƒ
                                        if (landingPiece && (lx !== ignoredPiece.x || ly !== ignoredPiece.y)) break;
                                        
                                        // Ğ¯ĞºÑ‰Ğ¾ Ğ²Ñ–Ğ»ÑŒĞ½Ğ¾ (Ğ°Ğ±Ğ¾ Ñ†Ğµ Ñ–Ğ³Ğ½Ğ¾Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ñ„Ñ–Ğ³ÑƒÑ€Ğ°, Ñ‰Ğ¾ Ğ¼Ğ°Ğ»Ğ¾Ğ¹Ğ¼Ğ¾Ğ²Ñ–Ñ€Ğ½Ğ¾ Ñ‚ÑƒÑ‚), Ñ‚Ğ¾ Ğ±Ñ–Ğ¹ Ğ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¸Ğ¹
                                        return true;
                                    }
                                    break; // Ğ—Ğ° Ğ²Ğ¾Ñ€Ğ¾Ğ³Ğ¾Ğ¼ Ğ½ĞµĞ¼Ğ°Ñ” Ğ¼Ñ–ÑÑ†Ñ Ğ°Ğ±Ğ¾ Ğ²Ğ¿ĞµÑ€Ğ»Ğ¸ÑÑ Ğ² Ñ–Ğ½ÑˆÑƒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ
                                } else {
                                    break; // Ğ’Ğ¿ĞµÑ€Ğ»Ğ¸ÑÑ Ğ² ÑĞ²Ğ¾Ğ³Ğ¾
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            // --- ĞĞĞ’Ğ˜Ğ™ ĞœĞ•Ğ¢ĞĞ”: Ğ Ğ•ĞšĞ£Ğ Ğ¡Ğ˜Ğ’ĞĞ˜Ğ™ ĞŸĞ†Ğ”Ğ ĞĞ¥Ğ£ĞĞĞš Ğ”ĞĞ’Ğ–Ğ˜ĞĞ˜ Ğ‘ĞĞ® ---
            // Ğ Ğ°Ñ…ÑƒÑ”, ÑĞºÑ–Ğ»ÑŒĞºĞ¸ Ğ²ÑÑŒĞ¾Ğ³Ğ¾ ÑˆĞ°ÑˆĞ¾Ğº Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ·Ğ°Ğ±Ñ€Ğ°Ñ‚Ğ¸, ÑÑ‚Ğ°Ñ€Ñ‚ÑƒÑÑ‡Ğ¸ Ğ· (cx, cy)
            _measureCaptureChain(piece, cx, cy, ignoredPieces) {
                const isKing = ['â›', 'â›ƒ'].includes(piece.s);
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                let maxChain = 0;

                for (const d of dirs) {
                    // --- Ğ›ĞĞ“Ğ†ĞšĞ Ğ”ĞĞœĞšĞ˜ ---
                    if (isKing) {
                        let foundEnemy = null;
                        // Ğ¡ĞºĞ°Ğ½ÑƒÑ”Ğ¼Ğ¾ Ğ´Ñ–Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ
                        for (let dist = 1; dist < this.boardSize; dist++) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;

                            // Ğ’Ğ¸Ñ…Ñ–Ğ´ Ğ·Ğ° Ğ¼ĞµĞ¶Ñ–
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;

                            // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° "Ñ–Ğ³Ğ½Ğ¾Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ…" (ÑƒĞ±Ğ¸Ñ‚Ğ¸Ñ… Ñƒ Ñ†ÑŒĞ¾Ğ¼Ñƒ Ğ»Ğ°Ğ½Ñ†ÑĞ¶ĞºÑƒ)
                            let isIgnored = false;
                            for (const ip of ignoredPieces) {
                                if (ip.x === tx && ip.y === ty) { isIgnored = true; break; }
                            }
                            if (isIgnored) continue; // ĞŸÑ€Ğ¾Ğ»Ñ–Ñ‚Ğ°Ñ”Ğ¼Ğ¾ ĞºÑ€Ñ–Ğ·ÑŒ ÑƒĞ±Ğ¸Ñ‚Ñƒ ÑˆĞ°ÑˆĞºÑƒ ÑĞº Ñ‡ĞµÑ€ĞµĞ· Ğ¿ÑƒÑÑ‚Ñƒ

                            const target = this.getPiece(tx, ty);

                            if (!foundEnemy) {
                                // Ğ¨ÑƒĞºĞ°Ñ”Ğ¼Ğ¾ Ğ²Ğ¾Ñ€Ğ¾Ğ³Ğ°
                                if (target) {
                                    if (target.c !== piece.c) {
                                        foundEnemy = { x: tx, y: ty };
                                    } else {
                                        break; // Ğ’Ğ¿ĞµÑ€Ğ»Ğ¸ÑÑ Ğ² ÑĞ²Ğ¾Ğ³Ğ¾
                                    }
                                }
                            } else {
                                // Ğ’Ğ¾Ñ€Ğ¾Ğ³Ğ° Ğ²Ğ¶Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾, ÑˆÑƒĞºĞ°Ñ”Ğ¼Ğ¾ Ğ²Ñ–Ğ»ÑŒĞ½Ñ– ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸ Ğ·Ğ° Ğ½Ğ¸Ğ¼
                                if (target) {
                                    break; // Ğ’Ğ¿ĞµÑ€Ğ»Ğ¸ÑÑ Ğ² Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ Ğ·Ğ° Ğ²Ğ¾Ñ€Ğ¾Ğ³Ğ¾Ğ¼
                                } else {
                                    // Ğ—Ğ½Ğ°Ğ¹ÑˆĞ»Ğ¸ Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ¿Ñ€Ğ¸Ğ·ĞµĞ¼Ğ»ĞµĞ½Ğ½Ñ!
                                    // Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‰Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ±Ğ¸Ñ‚Ğ¸ Ğ´Ğ°Ğ»Ñ– Ğ· Ñ†Ñ–Ñ”Ñ— Ñ‚Ğ¾Ñ‡ĞºĞ¸
                                    const newIgnored = [...ignoredPieces, foundEnemy];
                                    const depth = 1 + this._measureCaptureChain(piece, tx, ty, newIgnored);
                                    if (depth > maxChain) maxChain = depth;
                                }
                            }
                        }
                    } 
                    // --- Ğ›ĞĞ“Ğ†ĞšĞ ĞŸĞ ĞĞ¡Ğ¢ĞĞ‡ Ğ¨ĞĞ¨ĞšĞ˜ ---
                    else {
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;

                        // Ğ§Ğ¸ Ğ½Ğµ Ñ–Ğ³Ğ½Ğ¾Ñ€ÑƒÑ”Ğ¼Ğ¾ Ğ¼Ğ¸ Ñ†ÑŒĞ¾Ğ³Ğ¾ Ğ²Ğ¾Ñ€Ğ¾Ğ³Ğ°?
                        let isIgnored = false;
                        for (const ip of ignoredPieces) { if (ip.x === enemyX && ip.y === enemyY) isIgnored = true; }

                        if (!isIgnored && landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);

                            if (enemy && enemy.c !== piece.c && !landing) {
                                // Ğ‘Ñ–Ğ¹ Ğ¼Ğ¾Ğ¶Ğ»Ğ¸Ğ²Ğ¸Ğ¹
                                const newIgnored = [...ignoredPieces, {x: enemyX, y: enemyY}];
                                const depth = 1 + this._measureCaptureChain(piece, landX, landY, newIgnored);
                                if (depth > maxChain) maxChain = depth;
                            }
                        }
                    }
                }
                return maxChain;
            }

            // --- ĞĞĞĞ’Ğ›Ğ•ĞĞ˜Ğ™ ĞœĞ•Ğ¢ĞĞ” ĞĞ¢Ğ Ğ˜ĞœĞĞĞĞ¯ Ğ¥ĞĞ”Ğ†Ğ’ ---
            getCheckersMoves(piece, cx, cy, onlyCaptures = false) {
                const moves = [];
                const possibleCaptures = [];
                const isKing = ['â›', 'â›ƒ'].includes(piece.s);
                const isWhite = piece.c === 'w';
                const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                // 1. Ğ—Ğ±Ğ¸Ñ€Ğ°Ñ”Ğ¼Ğ¾ Ğ²ÑÑ– "ÑĞ¸Ñ€Ñ–" Ñ…Ğ¾Ğ´Ğ¸ (Ñ‚Ğ¸Ñ…Ñ– Ñ‚Ğ° Ğ±Ğ¾Ğ¹Ğ¾Ğ²Ñ–)
                for (const d of dirs) {
                    if (!isKing) {
                        // ĞŸÑ–ÑˆĞ°Ğº
                        const enemyX = cx + d[0];
                        const enemyY = cy + d[1];
                        const landX = cx + d[0] * 2;
                        const landY = cy + d[1] * 2;

                        // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ±Ğ¾Ñ
                        if (landX >= 0 && landX < this.boardSize && landY >= 0 && landY < this.boardSize) {
                            const enemy = this.getPiece(enemyX, enemyY);
                            const landing = this.getPiece(landX, landY);
                            if (enemy && enemy.c !== piece.c && !landing) {
                                possibleCaptures.push({ 
                                    c: landX, r: landY, 
                                    isCapture: true, 
                                    captured: {x: enemyX, y: enemyY} 
                                });
                            }
                        }
                        // Ğ¢Ğ¸Ñ…Ğ¸Ğ¹ Ñ…Ñ–Ğ´
                        if (!onlyCaptures) {
                            const forward = isWhite ? -1 : 1;
                            if (d[1] === forward) {
                                if (enemyX >= 0 && enemyX < this.boardSize && enemyY >= 0 && enemyY < this.boardSize) {
                                    if (!this.getPiece(enemyX, enemyY)) moves.push({ c: enemyX, r: enemyY });
                                }
                            }
                        }
                    } else {
                        // Ğ”Ğ°Ğ¼ĞºĞ°
                        let foundEnemy = null;
                        for (let dist = 1; dist < this.boardSize; dist++) {
                            const tx = cx + d[0] * dist;
                            const ty = cy + d[1] * dist;
                            if (tx < 0 || tx >= this.boardSize || ty < 0 || ty >= this.boardSize) break;
                            const target = this.getPiece(tx, ty);

                            if (!foundEnemy) {
                                if (target) {
                                    if (target.c !== piece.c) foundEnemy = { x: tx, y: ty };
                                    else break;
                                } else {
                                    if (!onlyCaptures) moves.push({ c: tx, r: ty });
                                }
                            } else {
                                if (target) break; // Ğ‘Ğ»Ğ¾ĞºĞ¾Ğ²Ğ°Ğ½Ğ¾
                                // Ğ¦Ğµ Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ¿Ñ€Ğ¸Ğ·ĞµĞ¼Ğ»ĞµĞ½Ğ½Ñ Ğ¿Ñ–ÑĞ»Ñ Ğ±Ğ¾Ñ
                                possibleCaptures.push({ 
                                    c: tx, r: ty, 
                                    isCapture: true, 
                                    captured: { x: foundEnemy.x, y: foundEnemy.y } 
                                });
                            }
                        }
                    }
                }

                // 2. Ğ¤Ñ–Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ñ–Ñ Ğ·Ğ³Ñ–Ğ´Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ° ĞœĞĞšĞ¡Ğ˜ĞœĞĞ›Ğ¬ĞĞĞ“Ğ Ğ‘ĞĞ®
                if (possibleCaptures.length > 0) {
                    // Ğ”Ğ»Ñ ĞºĞ¾Ğ¶Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ğ°Ñ€Ñ–Ğ°Ğ½Ñ‚Ñƒ Ğ±Ğ¾Ñ Ñ€Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ¾Ğ²Ğ½Ñƒ Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ñƒ Ğ»Ğ°Ğ½Ñ†ÑĞ¶ĞºĞ°
                    let maxChainLen = 0;
                    
                    possibleCaptures.forEach(move => {
                        // ĞŸĞ¾Ñ‡Ğ°Ñ‚ĞºĞ¾Ğ²Ğ° Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ğ° = 1 (Ğ¼Ğ¸ Ğ²Ğ¶Ğµ Ğ·Ñ€Ğ¾Ğ±Ğ¸Ğ»Ğ¸ Ñ†ĞµĞ¹ ÑÑ‚Ñ€Ğ¸Ğ±Ğ¾Ğº).
                        // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ Ñ€ĞµĞºÑƒÑ€ÑÑ–Ñ Ğ· Ğ½Ğ¾Ğ²Ğ¾Ñ— Ñ‚Ğ¾Ñ‡ĞºĞ¸, Ñ–Ğ³Ğ½Ğ¾Ñ€ÑƒÑÑ‡Ğ¸ Ñ‰Ğ¾Ğ¹Ğ½Ğ¾ Ğ¿Ğ¾Ğ±Ğ¸Ñ‚Ñƒ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ.
                        const chainRest = this._measureCaptureChain(piece, move.c, move.r, [move.captured]);
                        move.totalChain = 1 + chainRest;
                        
                        if (move.totalChain > maxChainLen) maxChainLen = move.totalChain;
                    });

                    // Ğ—Ğ°Ğ»Ğ¸ÑˆĞ°Ñ”Ğ¼Ğ¾ Ğ¢Ğ†Ğ›Ğ¬ĞšĞ˜ Ñ‚Ñ– Ñ…Ğ¾Ğ´Ğ¸, ÑĞºÑ– Ğ²ĞµĞ´ÑƒÑ‚ÑŒ Ğ´Ğ¾ Ğ½Ğ°Ğ¹Ğ´Ğ¾Ğ²ÑˆĞ¾Ğ³Ğ¾ Ğ»Ğ°Ğ½Ñ†ÑĞ¶ĞºĞ°
                    // (Ğ¦Ğµ Ğ·Ğ¼ÑƒÑˆÑƒÑ” Ğ´Ğ°Ğ¼ĞºÑƒ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ¸ ÑĞ°Ğ¼Ğµ Ñ‚Ñƒ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºÑƒ, Ğ· ÑĞºĞ¾Ñ— Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ±Ğ¸Ñ‚Ğ¸ Ğ´Ğ°Ğ»Ñ–)
                    return possibleCaptures.filter(m => m.totalChain === maxChainLen);
                }

                return onlyCaptures ? [] : moves;
            }

            validateMove(piece, c1, r1, c2, r2, checkingAttack = false) {
                if (!this.rulesEnabled) return true;
                if (this.checkersSymbols.has(piece.s) && !checkingAttack) {
                    const legalMoves = this.generatePotentialMoves(piece, c1, r1);
                    return legalMoves.some(m => m.c === c2 && m.r === r2);
                }
                const dx = c2 - c1; const dy = r2 - r1;
                if (dx === 0 && dy === 0) return false;
                const target = this.getPiece(c2, r2);
                if (!checkingAttack && target && target.c === piece.c) return false;
                const absDx = Math.abs(dx); const absDy = Math.abs(dy);
                const type = piece.s; const isWhite = piece.c === 'w';

                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const checkComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && (['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'].includes(type))) { dirY = -dirY; }
                            if (comp.t === 'slide' || def.t === 'slide') {
                                if (dirX === 0) { if (dx === 0 && Math.sign(dy) === Math.sign(dirY) && absDy <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else if (dirY === 0) { if (dy === 0 && Math.sign(dx) === Math.sign(dirX) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                                else { if (absDx === absDy && Math.sign(dx) === Math.sign(dirX) && Math.sign(dy) === Math.sign(dirY) && absDx <= limit) return this.isPathClear(c1, r1, c2, r2); }
                            }
                            else if (comp.t === 'jump' || def.t === 'jump') { if (dx === dirX && dy === dirY) return true; }
                            else if (comp.t === 'step' || def.t === 'step') { let mul = comp.mul || 1; if (dx === dirX*mul && dy === dirY*mul) return true; }
                            else if (comp.t === 'slide_jump') { if (dx % dirX === 0 && dy % dirY === 0) { const steps = dx / dirX; if (steps === dy / dirY && steps > 0) { let cx = c1 + dirX, cy = r1 + dirY; while (cx !== c2 || cy !== r2) { if (this.getPiece(cx, cy)) return false; cx += dirX; cy += dirY; } return true; } } }
                        }
                        return false;
                    };
                    if (def.t === 'complex') { return def.comps.some(c => checkComp(c)); } else { return checkComp(def); }
                }

                const isRook = (dx === 0 || dy === 0) && this.isPathClear(c1, r1, c2, r2);
                const isBishop = (absDx === absDy) && this.isPathClear(c1, r1, c2, r2);
                const isKnight = (absDx === 2 && absDy === 1) || (absDx === 1 && absDy === 2);
                if (['â™–','â™œ','â™•','â™›','ğŸ¦…','ğŸ²','ğŸ¤´','ğŸ„'].includes(type)) { if (isRook) return true; }
                if (['â™—','â™','â™•','â™›','â›','â›ƒ','ğŸ¦„','ğŸ²','ğŸ‘¼','ğŸ†','ğŸ‘º'].includes(type)) { if (isBishop) return true; }
                if (['â™˜','â™','ğŸ¦„','ğŸ¦…','ğŸ²','ğŸ¿ï¸'].includes(type)) { if (isKnight) return true; }
                if (['â™”','â™š','ğŸ‘¨','ğŸ»','ğŸ¤´','ğŸ‘¼'].includes(type)) return absDx <= 1 && absDy <= 1;
                if (type === 'â™™' || type === 'â™Ÿ') { const dir = isWhite ? -1 : 1; if (dx === 0 && dy === dir) return !target && !checkingAttack; if (dx === 0 && dy === dir * 2) { return !piece.hasMoved && !target && !checkingAttack && !this.getPiece(c1, r1 + dir); } if (absDx === 1 && dy === dir) return checkingAttack || (target && target.c !== piece.c); return false; }
                if (['ğŸ¢','ğŸ•'].includes(type)) return (absDx + absDy === 1) || (absDx===0 && dy===(isWhite?-1:1));
                return false;
            }
findKing(color) {
                if(color === 'w' && this.kingPos.w) return this.kingPos.w;
                if(color === 'b' && this.kingPos.b) return this.kingPos.b;

                // Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯: Ğ”Ğ¾Ğ´Ğ°Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ, Ñ‡Ğ¸ Ğ½Ğµ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ° Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ğ³ÑƒĞ¼ĞºĞ¾Ñ (GRID_VOID)
                if (this.virtualGen === 'classic' || this.virtualGen === 'fantasy' || this.virtualGen === 'army') {
                     const kingCol = Math.floor(this.boardSize/2);
                     let kR = -1;
                     if (color === 'b') kR = 0;
                     if (color === 'w') kR = this.boardSize - 1;
                     
                     if (kR !== -1) {
                        // Ğ¯ĞºÑ‰Ğ¾ Ğ½Ğ° Ğ¼Ñ–ÑÑ†Ñ– ĞºĞ¾Ñ€Ğ¾Ğ»Ñ ÑÑ‚Ğ¾Ñ—Ñ‚ÑŒ "Ğ¿ÑƒÑÑ‚Ğ¾Ñ‚Ğ°" (Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ¾), Ğ½Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ğ¼Ğ¾ Ğ¹Ğ¾Ğ³Ğ¾
                        if (this.grid.get(this.getKey(kingCol, kR)) !== GRID_VOID) {
                             return {c: kingCol, r: kR};
                        }
                     }
                }

                const kingSymbol = color === 'w' ? 'â™”' : 'â™š';
                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    if(p.s === kingSymbol && p.c === color) {
                         const parts = key.split(',');
                         return {c: parseInt(parts[0]), r: parseInt(parts[1])};
                    }
                }
                return null;
            }
            
           endGame(title = "ĞœĞĞ¢!") {
                this.gameOver = true;
                
                // Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ğ¿ĞµÑ€ĞµĞ¼Ğ¾Ğ¶Ñ†Ñ (Ñ‚Ğ¾Ğ¹, Ñ…Ñ‚Ğ¾ Ğ·Ñ€Ğ¾Ğ±Ğ¸Ğ² Ğ¿Ğ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ Ñ…Ñ–Ğ´)
                // Ğ¯ĞºÑ‰Ğ¾ Ğ·Ğ°Ñ€Ğ°Ğ· Ñ…Ñ–Ğ´ 'w' Ñ– Ñ…Ğ¾Ğ´Ñ–Ğ² Ğ½ĞµĞ¼Ğ°Ñ” -> Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ»Ğ¸ Ğ§Ğ¾Ñ€Ğ½Ñ–.
                const winner = this.currentTurn === 'w' ? "Ğ§Ğ¾Ñ€Ğ½Ñ–" : "Ğ‘Ñ–Ğ»Ñ–";
                
                let icon = "";
                
                if (this.virtualGen === 'checkers') {
                    // Ğ¯ĞºÑ‰Ğ¾ ÑˆĞ°ÑˆĞºĞ¸: Ğ¿Ğ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾ ÑˆĞ°ÑˆĞºÑƒ Ğ¿ĞµÑ€ĞµĞ¼Ğ¾Ğ¶Ñ†Ñ
                    // Ğ¯ĞºÑ‰Ğ¾ Ğ²Ğ¸Ğ³Ñ€Ğ°Ğ»Ğ¸ Ğ§Ğ¾Ñ€Ğ½Ñ– -> Ğ§Ğ¾Ñ€Ğ½Ğ° ÑˆĞ°ÑˆĞºĞ°, Ñ–Ğ½Ğ°ĞºÑˆĞµ Ğ‘Ñ–Ğ»Ğ°
                    icon = this.currentTurn === 'w' ? "â›‚" : "â›€"; 
                } else {
                    // Ğ¯ĞºÑ‰Ğ¾ ÑˆĞ°Ñ…Ğ¸: Ğ¿Ğ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ¼Ğ¾Ğ¶Ñ†Ñ
                    icon = this.currentTurn === 'w' ? "â™š" : "â™”";
                }
                
                const titleEl = document.querySelector('.victory-card h1');
                if (titleEl) titleEl.innerText = title;

                document.getElementById('winnerTxt').innerText = `ĞŸĞµÑ€ĞµĞ¼Ğ¾Ğ³Ğ°: ${winner}`;
                document.getElementById('winnerIcon').innerText = icon;
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }

            showStalemate() {
                this.gameOver = true;
                document.getElementById('winnerTxt').innerText = "ĞÑ–Ñ‡Ğ¸Ñ (ĞŸĞ°Ñ‚)";
                document.getElementById('winnerIcon').innerText = "ğŸ¤"; // Ğ†ĞºĞ¾Ğ½ĞºĞ° Ñ€ÑƒĞºĞ¾ÑÑ‚Ğ¸ÑĞºĞ°Ğ½Ğ½Ñ
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }
            // ĞœĞµÑ‚Ğ¾Ğ´ Ğ´Ğ»Ñ Ñ€ÑƒÑ‡Ğ½Ğ¾Ñ— Ğ·Ğ¼Ñ–Ğ½Ğ¸ ÑÑ‚Ğ¾Ñ€Ğ¾Ğ½Ğ¸ (Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€Ğ°)
            toggleTurnColor() {
                // ĞœÑ–Ğ½ÑÑ”Ğ¼Ğ¾ ÑÑ‚Ğ¾Ñ€Ğ¾Ğ½Ñƒ
                this.currentTurn = this.currentTurn === 'w' ? 'b' : 'w';
                
                // Ğ¡ĞºĞ¸Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ°Ğ¿Ğ¾Ñ€ "ĞšÑ–Ğ½ĞµÑ†ÑŒ Ğ³Ñ€Ğ¸", Ñ‰Ğ¾Ğ± Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ±ÑƒĞ»Ğ¾ Ğ´Ğ¾Ğ³Ñ€Ğ°Ñ‚Ğ¸ Ğ°Ğ±Ğ¾ Ğ²Ğ¸Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚Ğ¸ ÑĞ¸Ñ‚ÑƒĞ°Ñ†Ñ–Ñ
                this.gameOver = false;
                document.getElementById('gameOverOverlay').style.display = 'none';

                // ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ ÑˆĞ°Ñ…Ñ–Ğ² Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ñ— ÑÑ‚Ğ¾Ñ€Ğ¾Ğ½Ğ¸
                if (this.virtualGen !== 'checkers') {
                    this.kingsInCheck.w = this.isInCheck('w') ? this.findKing('w') : null;
                    this.kingsInCheck.b = this.isInCheck('b') ? this.findKing('b') : null;
                }

                // ĞĞ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ñ–Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
                this.updateTurnIndicator();
                
                // Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ Ğ·Ğ°Ğ¿Ğ¸Ñ Ğ² Ğ»Ğ¾Ğ³ Ğ¿Ñ€Ğ¾ Ğ·Ğ¼Ñ–Ğ½Ñƒ Ñ‡ĞµÑ€Ğ³Ğ¸ (Ğ¾Ğ¿Ñ†Ñ–Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾, Ñ‰Ğ¾Ğ± Ğ±ÑƒĞ»Ğ¾ Ğ²Ğ¸Ğ´Ğ½Ğ¾ Ğ² Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ—)
                const logList = document.getElementById('logList'); // Ğ¯ĞºÑ‰Ğ¾ Ğ²Ğ¸ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ñ‚Ğµ ÑÑ‚Ğ°Ñ€Ñƒ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ
                // ĞĞ±Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ, Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ·Ğ°ÑĞ¼Ñ–Ñ‡ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ»Ğ¾Ğ³ Ñ…Ğ¾Ğ´Ñ–Ğ²
                console.log(`Ğ§ĞµÑ€Ğ³Ñƒ Ğ·Ğ¼Ñ–Ğ½ĞµĞ½Ğ¾ Ğ½Ğ°: ${this.currentTurn === 'w' ? 'Ğ‘Ñ–Ğ»Ñ–' : 'Ğ§Ğ¾Ñ€Ğ½Ñ–'}`);
            }
switchTurn() {
                if (!this.turnModeEnabled) return;

                this.currentTurn = this.currentTurn === 'w' ? 'b' : 'w';

                // ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ ÑˆĞ°Ñ…Ñƒ (Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ Ğ´Ğ»Ñ ÑˆĞ°Ñ…Ñ–Ğ²)
                if (this.virtualGen !== 'checkers') {
                    this.kingsInCheck.w = this.isInCheck('w') ? this.findKing('w') : null;
                    this.kingsInCheck.b = this.isInCheck('b') ? this.findKing('b') : null;
                } else {
                    this.kingsInCheck = { w: null, b: null };
                }

                this.updateTurnIndicator();

                // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ Ğ· Ğ·Ğ°Ñ‚Ñ€Ğ¸Ğ¼ĞºĞ¾Ñ, Ñ‰Ğ¾Ğ± Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€ Ğ²ÑÑ‚Ğ¸Ğ³ Ğ½Ğ°Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ñ…Ñ–Ğ´
                setTimeout(() => {
                    // Ğ¯ĞºÑ‰Ğ¾ Ñƒ Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ³Ñ€Ğ°Ğ²Ñ†Ñ Ğ½ĞµĞ¼Ğ°Ñ” Ñ…Ğ¾Ğ´Ñ–Ğ²...
                    if (!this.hasAnyLegalMoves(this.currentTurn)) {
                        
                        if (this.virtualGen === 'checkers') {
                             this.endGame("ĞŸĞ•Ğ Ğ•ĞœĞĞ“Ğ!"); 
                        } 
                        else {
                            if (this.kingsInCheck[this.currentTurn]) {
                                this.endGame("ĞœĞĞ¢!"); 
                            } else {
                                this.showStalemate(); 
                            }
                        }
                    }
                }, 20);
            }
            
            updateTurnIndicator() {
                const ind = document.getElementById('turnIndicator');
                const txt = document.getElementById('turnText');
                const icon = document.getElementById('turnIcon');
                
                // Ğ—ĞĞ’Ğ–Ğ”Ğ˜ Ğ¿Ğ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾ Ñ–Ğ½Ğ´Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€, Ğ½Ğ°Ğ²Ñ–Ñ‚ÑŒ ÑĞºÑ‰Ğ¾ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ñ…Ğ¾Ğ´Ñ–Ğ² Ğ²Ğ¸Ğ¼ĞºĞ½ĞµĞ½Ğ¾
                ind.style.display = 'flex';
                
                if (!this.turnModeEnabled) {
                    // --- Ğ Ğ•Ğ–Ğ˜Ğœ Ğ Ğ•Ğ”ĞĞšĞ¢ĞĞ Ğ (Ğ–Ğ¾Ğ²Ñ‚Ğ¸Ğ¹) ---
                    ind.style.background = '#f1c40f'; 
                    ind.style.color = '#000';
                    ind.style.borderColor = '#f39c12';
                    // ĞŸĞ¾ĞºĞ°Ğ·ÑƒÑ”Ğ¼Ğ¾, Ñ‡Ğ¸Ğ¹ Ğ±ÑƒĞ´Ğµ Ñ…Ñ–Ğ´, ĞºĞ¾Ğ»Ğ¸ Ğ³Ñ€Ñƒ Ğ·Ğ°Ğ¿ÑƒÑÑ‚ÑÑ‚ÑŒ
                    const label = this.currentTurn === 'w' ? "Ğ‘Ñ–Ğ»Ñ–" : "Ğ§Ğ¾Ñ€Ğ½Ñ–";
                    txt.innerText = `Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€ (${label})`;
                    icon.innerText = this.currentTurn === 'w' ? "â™”" : "â™š";
                } else {
                    // --- Ğ Ğ•Ğ–Ğ˜Ğœ Ğ“Ğ Ğ˜ ---
                    if (this.currentTurn === 'w') {
                        ind.style.background = 'rgba(255, 255, 255, 0.95)'; 
                        ind.style.color = '#000';
                        ind.style.borderColor = (this.kingsInCheck.w) ? 'red' : '#ccc';
                        txt.innerText = (this.kingsInCheck.w) ? "Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ– (Ğ¨ĞĞ¥!)" : "Ğ¥Ñ–Ğ´: Ğ‘Ñ–Ğ»Ñ–";
                        icon.innerText = "â™”";
                    } else {
                        ind.style.background = 'rgba(30, 30, 30, 0.95)'; 
                        ind.style.color = '#fff';
                        ind.style.borderColor = (this.kingsInCheck.b) ? 'red' : '#555';
                        txt.innerText = (this.kingsInCheck.b) ? "Ğ¥Ñ–Ğ´: Ğ§Ğ¾Ñ€Ğ½Ñ– (Ğ¨ĞĞ¥!)" : "Ğ¥Ñ–Ğ´: Ğ§Ğ¾Ñ€Ğ½Ñ–";
                        icon.innerText = "â™š";
                    }
                }
            }

            toggleRules() { this.rulesEnabled = !this.rulesEnabled; if(!this.rulesEnabled) this.kingsInCheck = { w: null, b: null }; document.getElementById('rulesBtn').innerText = this.rulesEnabled ? "ğŸŸ¢ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°" : "ğŸ”´ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°"; }
            toggleTurnMode() { this.turnModeEnabled = !this.turnModeEnabled; this.updateTurnIndicator(); document.getElementById('turnBtn').innerText = this.turnModeEnabled ? "ğŸŸ¢ Ğ¥Ñ–Ğ´ (Ğ’ĞšĞ›)" : "ğŸ”´ Ğ¥Ñ–Ğ´ (Ğ’Ğ˜ĞšĞ›)"; }

            findKing(color) {
                if(color === 'w' && this.kingPos.w) return this.kingPos.w;
                if(color === 'b' && this.kingPos.b) return this.kingPos.b;

                // Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ¯: Ğ”Ğ¾Ğ´Ğ°Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºÑƒ, Ñ‡Ğ¸ Ğ½Ğµ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ° Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ğ³ÑƒĞ¼ĞºĞ¾Ñ (GRID_VOID)
                if (this.virtualGen === 'classic' || this.virtualGen === 'fantasy' || this.virtualGen === 'army') {
                     const kingCol = Math.floor(this.boardSize/2);
                     let kR = -1;
                     if (color === 'b') kR = 0;
                     if (color === 'w') kR = this.boardSize - 1;
                     
                     if (kR !== -1) {
                        // Ğ¯ĞºÑ‰Ğ¾ Ğ½Ğ° Ğ¼Ñ–ÑÑ†Ñ– ĞºĞ¾Ñ€Ğ¾Ğ»Ñ ÑÑ‚Ğ¾Ñ—Ñ‚ÑŒ "Ğ¿ÑƒÑÑ‚Ğ¾Ñ‚Ğ°" (Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ¾), Ğ½Ğµ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ğ¼Ğ¾ Ğ¹Ğ¾Ğ³Ğ¾
                        if (this.grid.get(this.getKey(kingCol, kR)) !== GRID_VOID) {
                             return {c: kingCol, r: kR};
                        }
                     }
                }

                const kingSymbol = color === 'w' ? 'â™”' : 'â™š';
                for (const [key, val] of this.grid) {
                    if (val === GRID_VOID) continue;
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    if(p.s === kingSymbol && p.c === color) {
                         const parts = key.split(',');
                         return {c: parseInt(parts[0]), r: parseInt(parts[1])};
                    }
                }
                return null;
            }

            isSquareAttacked(targetC, targetR, byOpponentOfColor) {
                // 1. Ğ¨Ğ²Ğ¸Ğ´ĞºĞ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ²Ğ¾Ñ€Ğ¾Ğ¶Ğ¾Ğ³Ğ¾ ĞšĞĞ ĞĞ›Ğ¯ (Ğ¦Ğµ Ñ‚Ğµ, Ñ‡Ğ¾Ğ³Ğ¾ Ğ½Ğµ Ğ²Ğ¸ÑÑ‚Ğ°Ñ‡Ğ°Ğ»Ğ¾!)
                const enemyKingPos = this.findKing(byOpponentOfColor);
                if (enemyKingPos) {
                    const dkx = Math.abs(enemyKingPos.c - targetC);
                    const dky = Math.abs(enemyKingPos.r - targetR);
                    // Ğ¯ĞºÑ‰Ğ¾ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ° Ğ¿Ğ¾Ñ€ÑƒÑ‡ Ğ· Ğ²Ğ¾Ñ€Ğ¾Ğ¶Ğ¸Ğ¼ ĞºĞ¾Ñ€Ğ¾Ğ»ĞµĞ¼ â€” Ğ²Ğ¾Ğ½Ğ° Ğ¿Ñ–Ğ´ Ğ°Ñ‚Ğ°ĞºĞ¾Ñ
                    if (dkx <= 1 && dky <= 1) return true;
                }

                // 2. Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ– Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸ (ĞšĞ¾Ğ½Ñ–, ĞŸÑ–ÑˆĞ°ĞºĞ¸, ĞŸÑ€Ğ¾Ğ¼ĞµĞ½Ñ–)
                const enemyQueen = byOpponentOfColor === 'w' ? 'â™•' : 'â™›';
                const enemyRook = byOpponentOfColor === 'w' ? 'â™–' : 'â™œ';
                const enemyBishop = byOpponentOfColor === 'w' ? 'â™—' : 'â™';
                const enemyKnight = byOpponentOfColor === 'w' ? 'â™˜' : 'â™';
                const enemyPawn = byOpponentOfColor === 'w' ? 'â™™' : 'â™Ÿ';

                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞšĞ¾Ğ½Ñ–Ğ²
                const knights = [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]];
                for (const [dx, dy] of knights) {
                    const p = this.getPiece(targetC + dx, targetR + dy);
                    if (p && p.c === byOpponentOfColor && (p.s === enemyKnight || p.s === 'ğŸ¦„')) return true;
                }

                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞŸÑ–ÑˆĞ°ĞºÑ–Ğ²
                const pawnDy = byOpponentOfColor === 'w' ? 1 : -1;
                const checkPawn = (offset) => {
                     const p = this.getPiece(targetC + offset, targetR + pawnDy);
                     return p && p.c === byOpponentOfColor && p.s === enemyPawn;
                }
                if (checkPawn(1) || checkPawn(-1)) return true;

                // ĞĞŸĞ¢Ğ˜ĞœĞ†Ğ—ĞĞ’ĞĞĞ ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ Ğ›Ğ†ĞĞ†Ğ™ (Raycast)
                const checkRayOptimized = (dx, dy, types) => {
                    let closestDist = Infinity;
                    let closestPiece = null;

                    // Ğ. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¸Ñ… Ñ„Ñ–Ğ³ÑƒÑ€
                    for (const [key, val] of this.grid) {
                        if (val === GRID_VOID) continue; 
                        const comma = key.indexOf(',');
                        const pc = parseInt(key.substring(0, comma));
                        const pr = parseInt(key.substring(comma + 1));
                        const distC = pc - targetC;
                        const distR = pr - targetR;
                        
                        let valid = false;
                        let d = Infinity;
                        
                        if (dx !== 0 && dy !== 0) { // Ğ”Ñ–Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒ
                            if (Math.abs(distC) === Math.abs(distR) && Math.sign(distC) === dx && Math.sign(distR) === dy) {
                                valid = true; d = Math.abs(distC);
                            }
                        } else if (dx !== 0) { // Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒ
                            if (distR === 0 && Math.sign(distC) === dx) { valid = true; d = Math.abs(distC); }
                        } else { // Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒ
                            if (distC === 0 && Math.sign(distR) === dy) { valid = true; d = Math.abs(distR); }
                        }

                        if (valid && d < closestDist) {
                            closestDist = d;
                            const id = val & 0xFFFF;
                            closestPiece = this.palette[id-1];
                        }
                    }

                    // Ğ‘. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ’Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ñ… ĞÑ€Ğ¼Ñ–Ğ¹
                    if (this.virtualGen) {
                         let armyH = 0;
                         if (this.virtualGen === 'chess960') armyH = 2;
                         else if (this.virtualGen !== 'checkers') {
                             armyH = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                             if (armyH < 2) armyH = 2;
                         } else {
                             armyH = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                         }
                         const topBoundary = armyH; 
                         const botBoundary = this.boardSize - armyH;
                         let vDist = Infinity;

                         if (dy !== 0) {
                             if (dy < 0) { if (targetR >= topBoundary) vDist = targetR - (topBoundary - 1); } 
                             else { if (targetR < botBoundary) vDist = botBoundary - targetR; }
                         } else {
                             if (targetR < topBoundary || targetR >= botBoundary) vDist = 1;
                         }

                         if (vDist < closestDist) {
                             const vx = targetC + dx * vDist; const vy = targetR + dy * vDist;
                             if (vx >= 0 && vx < this.boardSize && vy >= 0 && vy < this.boardSize) {
                                 const vp = this.getPiece(vx, vy);
                                 if (vp) { closestDist = vDist; closestPiece = vp; }
                             }
                         }
                    }

                    // Ğ’. Ğ¤Ñ–Ğ½Ğ°Ğ»ÑŒĞ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ°
                    if (closestPiece && closestPiece.c === byOpponentOfColor) {
                        if (types.includes(closestPiece.s)) return true;
                        if (types.includes(enemyQueen) && ['ğŸ§œ','ğŸ”±','ğŸ¦…'].includes(closestPiece.s)) return true;
                    }
                    return false;
                };

                if (checkRayOptimized(0, 1, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(0, -1, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(1, 0, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(-1, 0, [enemyRook, enemyQueen])) return true;
                if (checkRayOptimized(1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(1, -1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(-1, 1, [enemyBishop, enemyQueen])) return true;
                if (checkRayOptimized(-1, -1, [enemyBishop, enemyQueen])) return true;

                return false;
            }

            isInCheck(kingColor) { const kingPos = this.findKing(kingColor); if (!kingPos) return false; return this.isSquareAttacked(kingPos.c, kingPos.r, kingColor === 'w' ? 'b' : 'w'); }
            updateKingCheckStatus(color) { this.kingsInCheck[color] = this.isInCheck(color) ? this.findKing(color) : null; }

            hasAnyLegalMoves(color) {
                // Ğ¢Ğ°Ğ¹Ğ¼ĞµÑ€ Ğ´Ğ»Ñ Ğ·Ğ°Ñ…Ğ¸ÑÑ‚Ñƒ Ğ²Ñ–Ğ´ Ğ¿Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°Ğ²Ğ¸ÑĞ°Ğ½Ğ½Ñ
                const startTime = performance.now();
                // Ğ”Ğ°Ñ”Ğ¼Ğ¾ Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ñ‡Ğ°ÑÑƒ (200Ğ¼Ñ), Ñ‰Ğ¾Ğ± Ğ²ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚Ğ¸ Ğ·Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ñ…Ñ–Ğ´
                const MAX_CALC_TIME_MS = 200; 

                // 1. Ğ”Ğ»Ñ Ğ³Ñ–Ğ³Ğ°Ğ½Ñ‚ÑÑŒĞºĞ¸Ñ… Ğ´Ğ¾ÑˆĞ¾Ğº (>64) Ğ²Ğ·Ğ°Ğ³Ğ°Ğ»Ñ– Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ (Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ»Ğ°Ğ³Ğ°Ğ»Ğ¾ Ğ¿Ñ€Ğ¸ Ñ…Ğ¾Ğ´ÑŒĞ±Ñ–)
                if (this.boardSize > 64) return true;

                // 2. Ğ”Ğ»Ñ Ğ¼Ğ°Ğ»Ğ¸Ñ… Ğ´Ğ¾ÑˆĞ¾Ğº (<= 20) Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ ĞŸĞĞ’ĞĞ†Ğ¡Ğ¢Ğ® (Ñ–Ğ³Ğ½Ğ¾Ñ€ÑƒÑ”Ğ¼Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€), 
                // Ñ‰Ğ¾Ğ± Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚Ğ¸ ĞœĞĞ¢.
                const allowTimeout = (this.boardSize > 20);

                const checkPiece = (p, cx, cy) => {
                    const moves = this.generatePotentialMoves(p, cx, cy);
                    for (const m of moves) {
                        if (this.checkersSymbols.has(p.s)) return true;
                        if (this.simulateMoveAndCheckSafety(p, cx, cy, m.c, m.r)) {
                            return true;
                        }
                    }
                    return false;
                };

                // Ğ¡ĞºĞ°Ğ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ GRID (Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ– Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸)
                for (const [key, val] of this.grid) {
                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€ Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ ÑĞºÑ‰Ğ¾ Ğ´Ğ¾ÑˆĞºĞ° Ğ²ĞµĞ»Ğ¸ĞºĞ°
                    if (allowTimeout && (performance.now() - startTime > MAX_CALC_TIME_MS)) return true;

                    if (val === GRID_VOID) continue;
                    const comma = key.indexOf(',');
                    const cx = parseInt(key.substring(0, comma));
                    const cy = parseInt(key.substring(comma + 1));
                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    
                    if (p.c === color) {
                        if (checkPiece(p, cx, cy)) return true;
                    }
                }

                // Ğ¡ĞºĞ°Ğ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ Virtual (Ğ°Ñ€Ğ¼Ñ–Ñ)
                if (this.virtualGen) {
                    let armyHeight = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                    if (this.virtualGen === 'chess960') armyHeight = 2;
                    else if (armyHeight < 2 && this.virtualGen !== 'checkers') armyHeight = 2;

                    const ranges = [
                        {start: 0, end: armyHeight},
                        {start: this.boardSize - armyHeight, end: this.boardSize}
                    ];

                    for (const range of ranges) {
                        for (let r = range.start; r < range.end; r++) {
                            for (let c = 0; c < this.boardSize; c++) {
                                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ° Ğ²ÑĞµÑ€ĞµĞ´Ğ¸Ğ½Ñ– Ñ†Ğ¸ĞºĞ»Ñƒ (Ñ€Ñ–Ğ´ÑˆĞµ, ĞºĞ¾Ğ¶Ğ½Ñ– 10 ÑÑ‚Ğ¾Ğ²Ğ¿Ñ†Ñ–Ğ²)
                                if (allowTimeout && (c % 10 === 0) && (performance.now() - startTime > MAX_CALC_TIME_MS)) return true;

                                if (this.grid.has(this.getKey(c, r))) continue;

                                const p = this.getVirtualPiece(c, r);
                                if (p && p.c === color) {
                                    if (checkPiece(p, c, r)) return true;
                                }
                            }
                        }
                    }
                }

                return false;
            }hasAnyLegalMoves(color) {
                // Ğ¢Ğ°Ğ¹Ğ¼ĞµÑ€: Ğ´Ğ°Ñ”Ğ¼Ğ¾ 500Ğ¼Ñ Ğ½Ğ° Ğ¿Ğ¾ÑˆÑƒĞº Ñ…Ğ¾Ğ´Ñƒ (Ğ¿Ñ–Ğ² ÑĞµĞºÑƒĞ½Ğ´Ğ¸ - Ñ†Ğµ Ğ½ĞµĞ¿Ğ¾Ğ¼Ñ–Ñ‚Ğ½Ğ¾ Ğ¿Ñ€Ğ¸ Ğ¼Ğ°Ñ‚Ñ–)
                const startTime = performance.now();
                const MAX_CALC_TIME_MS = 500;

                // Ğ¯ĞºÑ‰Ğ¾ Ğ´Ğ¾ÑˆĞºĞ° Ğ³Ñ–Ğ³Ğ°Ğ½Ñ‚ÑÑŒĞºĞ° (>64x64), Ğ°Ğ²Ñ‚Ğ¾-Ğ¼Ğ°Ñ‚ Ğ²Ğ¸Ğ¼Ğ¸ĞºĞ°Ñ”Ğ¼Ğ¾ Ğ¿Ğ¾Ğ²Ğ½Ñ–ÑÑ‚Ñ
                if (this.boardSize > 64) return true;

                // Ğ”Ğ¾Ğ¿Ğ¾Ğ¼Ñ–Ğ¶Ğ½Ğ° Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸
                const checkPiece = (p, cx, cy) => {
                    const moves = this.generatePotentialMoves(p, cx, cy);
                    // Ğ”Ğ»Ñ ÑˆĞ°ÑˆĞ¾Ğº Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ½Ğ°ÑĞ²Ğ½Ñ–ÑÑ‚ÑŒ Ñ…Ğ¾Ğ´Ñƒ
                    if (this.checkersSymbols.has(p.s)) return moves.length > 0;
                    
                    // Ğ”Ğ»Ñ ÑˆĞ°Ñ…Ñ–Ğ² - Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ½Ğ° Ğ±ĞµĞ·Ğ¿ĞµĞºÑƒ
                    for (const m of moves) {
                        if (this.simulateMoveAndCheckSafety(p, cx, cy, m.c, m.r)) {
                            return true; // Ğ—Ğ½Ğ°Ğ¹ÑˆĞ»Ğ¸ Ñ€ÑÑ‚Ñ–Ğ²Ğ½Ğ¸Ğ¹ Ñ…Ñ–Ğ´!
                        }
                    }
                    return false;
                };

                // --- ĞšĞ ĞĞš 1: ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ ĞšĞĞ ĞĞ›Ğ¯ (ĞŸĞ Ğ†ĞĞ Ğ˜Ğ¢Ğ•Ğ¢) ---
                // ĞĞ°Ğ¹Ñ‡Ğ°ÑÑ‚Ñ–ÑˆĞµ Ğ¿Ñ€Ğ¸ ÑˆĞ°Ñ…Ñƒ Ñ‚Ñ€ĞµĞ±Ğ° Ñ‚Ñ–ĞºĞ°Ñ‚Ğ¸ ĞºĞ¾Ñ€Ğ¾Ğ»ĞµĞ¼. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€Ğ¸Ğ¼Ğ¾ Ñ†Ğµ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¼, Ñ†Ğµ Ğ´ÑƒĞ¶Ğµ ÑˆĞ²Ğ¸Ğ´ĞºĞ¾.
                const kPos = this.findKing(color);
                if (kPos) {
                    const kPiece = this.getPiece(kPos.c, kPos.r);
                    if (kPiece && checkPiece(kPiece, kPos.c, kPos.r)) return true;
                }

                // --- ĞšĞ ĞĞš 2: ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ Ğ†ĞĞ¨Ğ˜Ğ¥ Ğ¤Ğ†Ğ“Ğ£Ğ  ---
                
                // Ğ. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¸Ñ… Ñ„Ñ–Ğ³ÑƒÑ€ (Grid)
                for (const [key, val] of this.grid) {
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ‡Ğ°Ñ Ğ²Ğ¸Ğ¹ÑˆĞ¾Ğ² - Ğ¿ĞµÑ€ĞµÑ€Ğ¸Ğ²Ğ°Ñ”Ğ¼Ğ¾ Ñ– Ğ²Ğ²Ğ°Ğ¶Ğ°Ñ”Ğ¼Ğ¾, Ñ‰Ğ¾ Ñ…Ñ–Ğ´ Ñ” (Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ²Ğ¸ÑĞ»Ğ¾)
                    if (performance.now() - startTime > MAX_CALC_TIME_MS) return true;

                    if (val === GRID_VOID) continue;
                    const comma = key.indexOf(',');
                    const cx = parseInt(key.substring(0, comma));
                    const cy = parseInt(key.substring(comma + 1));
                    
                    // ĞšĞ¾Ñ€Ğ¾Ğ»Ñ Ğ¼Ğ¸ Ğ²Ğ¶Ğµ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€Ğ¸Ğ»Ğ¸, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾
                    if (cx === kPos?.c && cy === kPos?.r) continue;

                    const id = val & 0xFFFF;
                    const p = this.palette[id-1];
                    
                    if (p.c === color) {
                        if (checkPiece(p, cx, cy)) return true;
                    }
                }

                // Ğ‘. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ²Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ñ… Ñ„Ñ–Ğ³ÑƒÑ€ (ĞÑ€Ğ¼Ñ–Ñ)
                if (this.virtualGen) {
                    let armyHeight = Math.floor(this.boardSize * (this.virtualProps.percent / 100));
                    if (this.virtualGen === 'chess960') armyHeight = 2;
                    else if (armyHeight < 2 && this.virtualGen !== 'checkers') armyHeight = 2;

                    const ranges = [
                        {start: 0, end: armyHeight},
                        {start: this.boardSize - armyHeight, end: this.boardSize}
                    ];

                    for (const range of ranges) {
                        for (let r = range.start; r < range.end; r++) {
                            for (let c = 0; c < this.boardSize; c++) {
                                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ°ÑÑƒ ĞºĞ¾Ğ¶Ğ½Ñ– 10 ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½Ğ¾Ğº
                                if ((c % 10 === 0) && (performance.now() - startTime > MAX_CALC_TIME_MS)) return true;

                                // Ğ¯ĞºÑ‰Ğ¾ Ñ„Ñ–Ğ³ÑƒÑ€Ğ° Ğ²Ğ¶Ğµ Ğ·Ğ¼Ñ–Ğ½ĞµĞ½Ğ° (Ğ² Grid), Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾
                                if (this.grid.has(this.getKey(c, r))) continue;
                                // ĞšĞ¾Ñ€Ğ¾Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ”Ğ¼Ğ¾
                                if (c === kPos?.c && r === kPos?.r) continue;

                                const p = this.getVirtualPiece(c, r);
                                if (p && p.c === color) {
                                    if (checkPiece(p, c, r)) return true;
                                }
                            }
                        }
                    }
                }

                return false;
            }
            _resolveDirs(d) { return typeof d === 'string' ? DIRS[d] : d; }

            generatePotentialMoves(piece, cx, cy, bounds = null) {
                // Ğ•ÑĞ»Ğ¸ ÑÑ‚Ğ¾ ÑˆĞ°ÑˆĞºĞ¸, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑÑ‚Ğ°Ñ€ÑƒÑ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ (Ğ¾Ğ½Ğ° Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ°Ñ, Ğ½Ğµ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ°Ñ)
                if (this.checkersSymbols.has(piece.s)) {
                    if (!this.multiJumpSource && this.rulesEnabled) return this.getCheckersMoves(piece, cx, cy);
                    else if (this.multiJumpSource) {
                        if (cx !== this.multiJumpSource.c || cy !== this.multiJumpSource.r) return [];
                        return this.getCheckersMoves(piece, cx, cy, true);
                    }
                    return this.getCheckersMoves(piece, cx, cy);
                }

                let moves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ‚Ğ¾Ñ‡ĞºĞ¸ (Ğ¿Ñ€Ñ‹Ğ¶Ğ¾Ğº ĞºĞ¾Ğ½Ñ, ĞºĞ¾Ñ€Ğ¾Ğ»Ñ)
                const addStep = (dx, dy) => {
                    let x = cx + dx; let y = cy + dy;
                    if (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize) {
                        moves.push({c: x, r: y});
                    }
                };

                // Ğ’ĞĞ–ĞĞ: ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ‚Ñ€Ğ°ÑÑĞ¸Ñ€Ğ¾Ğ²ĞºĞ° (Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ñ‹: Ğ›Ğ°Ğ´ÑŒÑ, Ğ¡Ğ»Ğ¾Ğ½, Ğ¤ĞµÑ€Ğ·ÑŒ)
                const addTrace = (dx, dy) => {
                    let x = cx + dx; 
                    let y = cy + dy;
                    
                    // Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ Ğ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ğ¾Ğ³Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°, Ğ½Ğ¾ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ° ÑĞºÑ€Ğ°Ğ½Ğ¾Ğ¼ Ğ¸Ğ»Ğ¸ Ğ´Ğ¾ÑĞºĞ¾Ğ¹
                    let steps = 0;
                    // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ ÑˆĞ°Ğ³Ğ¾Ğ² Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ¾Ğ¼ Ğ´Ğ¾ÑĞºĞ¸, Ğ½Ğ¾ Ğ¿Ñ€ĞµÑ€Ğ²ĞµĞ¼ Ñ€Ğ°Ğ½ÑŒÑˆĞµ
                    const maxSteps = this.boardSize; 

                    while (x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize && steps < maxSteps) {
                        // 1. Ğ’Ğ˜Ğ Ğ¢Ğ£ĞĞ›Ğ¬ĞĞĞ¯ ĞĞŸĞ¢Ğ˜ĞœĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯:
                        // Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ ÑĞºÑ€Ğ°Ğ½Ğ° (bounds) Ğ¸ Ğ¼Ñ‹ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ·Ğ° Ğ½Ğ¸Ñ… â€” ĞŸĞ Ğ•Ğ Ğ«Ğ’ĞĞ•ĞœĞ¡Ğ¯.
                        // ĞĞµÑ‚ ÑĞ¼Ñ‹ÑĞ»Ğ° Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ñ‚Ğ°Ğ¼, Ğ³Ğ´Ğµ Ğ¸Ğ³Ñ€Ğ¾Ğº Ğ½Ğµ Ğ²Ğ¸Ğ´Ğ¸Ñ‚.
                        if (bounds) {
                            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ´Ğ²Ğ¸Ğ¶ĞµĞ¼ÑÑ Ğ»Ğ¸ Ğ¼Ñ‹ ĞĞ¢ Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹ Ğ—Ğ Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‹ ÑĞºÑ€Ğ°Ğ½Ğ°
                            // (Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ¾: ĞµÑĞ»Ğ¸ Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ²Ğ½Ğµ ÑĞºÑ€Ğ°Ğ½Ğ°, Ğ¿ĞµÑ€ĞµÑÑ‚Ğ°ĞµĞ¼ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ)
                            if (x < bounds.minC || x > bounds.maxC || y < bounds.minR || y > bounds.maxR) {
                                // ĞĞ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ Ğ¾ÑÑ‚Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ñ‹Ğ¼: ĞµÑĞ»Ğ¸ Ñ„Ğ¸Ğ³ÑƒÑ€Ğ° ÑĞ°Ğ¼Ğ° Ğ·Ğ° ÑĞºÑ€Ğ°Ğ½Ğ¾Ğ¼, Ğ° Ğ±ÑŒĞµÑ‚ Ğ’ ÑĞºÑ€Ğ°Ğ½.
                                // ĞŸĞ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼: ĞµÑĞ»Ğ¸ Ğ¼Ñ‹ Ğ£Ğ–Ğ• Ğ´Ğ°Ğ»ĞµĞºĞ¾ Ğ¾Ñ‚ Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹ Ğ¸ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ·Ğ° ÑĞºÑ€Ğ°Ğ½.
                                if (Math.abs(x - cx) > 50 || Math.abs(y - cy) > 50) break;
                                
                                // Ğ˜Ğ»Ğ¸ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾: ĞµÑĞ»Ğ¸ Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ´Ğ°Ğ»ĞµĞºĞ¾ Ğ·Ğ° Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ğ¼Ğ¸ Ğ²ÑŒÑĞ¿Ğ¾Ñ€Ñ‚Ğ°, break.
                                // Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµĞ¼ Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ "Ğ¾Ğ²ĞµÑ€Ğ´Ñ€Ğ°Ñ„Ñ‚", Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ»Ğ¸Ğ½Ğ¸Ğ¸ Ğ½Ğµ Ğ¾Ğ±Ñ€Ñ‹Ğ²Ğ°Ğ»Ğ¸ÑÑŒ Ñ€ĞµĞ·ĞºĞ¾ Ğ¿Ñ€Ğ¸ ÑĞºÑ€Ğ¾Ğ»Ğ»Ğµ
                            }
                        }

                        const target = this.getPiece(x, y);
                        if (target) {
                            // Ğ•ÑĞ»Ğ¸ Ğ²ÑÑ‚Ñ€ĞµÑ‚Ğ¸Ğ»Ğ¸ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ
                            if (target.c !== piece.c) moves.push({c: x, r: y}); // Ğ‘ÑŒĞµĞ¼ Ğ²Ñ€Ğ°Ğ³Ğ°
                            break; // Ğ˜ Ğ¾ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ÑÑ
                        }
                        
                        // Ğ•ÑĞ»Ğ¸ Ğ¿ÑƒÑÑ‚Ğ¾ - Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ…Ğ¾Ğ´
                        moves.push({c: x, r: y});
                        
                        x += dx; y += dy;
                        steps++;
                    }
                };

                // Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ
                if (['â™–','â™œ','â™•','â™›'].includes(type)) { addTrace(1,0); addTrace(-1,0); addTrace(0,1); addTrace(0,-1); }
                if (['â™—','â™','â™•','â™›'].includes(type)) { addTrace(1,1); addTrace(-1,1); addTrace(1,-1); addTrace(-1,-1); }
                if (['â™˜','â™'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => addStep(d[0], d[1])); }
                if (['â™”','â™š'].includes(type)) { for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i||j) addStep(i,j); }
                
                // ĞŸĞµÑˆĞºĞ¸
                if (['â™™','â™Ÿ'].includes(type)) {
                    const d = isWhite ? -1 : 1;
                    if (!this.getPiece(cx, cy + d)) addStep(0, d);
                    if (!this.getPiece(cx, cy + d*2) && !this.getPiece(cx, cy + d) && !piece.hasMoved) addStep(0, d*2);
                    const t1 = this.getPiece(cx + 1, cy + d); if (t1 && t1.c !== piece.c) addStep(1, d);
                    const t2 = this.getPiece(cx - 1, cy + d); if (t2 && t2.c !== piece.c) addStep(-1, d);
                }
                
                // ĞœĞµĞ³Ğ°-Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹
                if (megaDefs[type]) {
                    const def = megaDefs[type];
                    const FLIP_Y_LIST = ['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'];
                    const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0]; let dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            
                            if (moveType === 'slide' || moveType === 'slide_jump') {
                                // Ğ—Ğ´ĞµÑÑŒ Ğ¼Ñ‹ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ limit, Ñ‚Ğ°Ğº ĞºĞ°Ğº addTrace Ñ‚ĞµĞ¿ĞµÑ€ÑŒ ÑĞ°Ğ¼ Ñ€ĞµÑˆĞ°ĞµÑ‚ ĞºĞ¾Ğ³Ğ´Ğ° Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÑÑ
                                // ĞĞ¾ Ğ´Ğ»Ñ "ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ñ…" ÑĞ»Ğ°Ğ¹Ğ´ĞµÑ€Ğ¾Ğ² (Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ½Ñ‹Ñ… max), Ğ¼Ñ‹ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ‚ÑŒ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸
                                // Ğ”Ğ»Ñ ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ¸Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ¾Ñ‚ Ğ¶Ğµ addTrace, Ğ¾Ğ½ ÑĞ°Ğ¼ Ğ¾Ğ±Ñ€ĞµĞ¶ĞµÑ‚ÑÑ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°Ğ¼Ğ¸ ÑĞºÑ€Ğ°Ğ½Ğ°
                                addTrace(dirX, dirY); 
                            } else { 
                                let mul = comp.mul || 1; 
                                addStep(dirX * mul, dirY * mul); 
                            }
                        }
                    };
                    if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }
                return moves;
            }

            simulateMoveAndCheckSafety(piece, startC, startR, targetC, targetR) {
                if (!this.validateMove(piece, startC, startR, targetC, targetR)) return false;

                const keyStart = this.getKey(startC, startR);
                const keyTarget = this.getKey(targetC, targetR);

                const valStart = this.grid.get(keyStart);
                const valTarget = this.grid.get(keyTarget);

                const wasKingW = this.kingPos.w;
                const wasKingB = this.kingPos.b;

                if (valStart === undefined && this.virtualGen) {
                    const p = this.getVirtualPiece(startC, startR);
                    const pid = this.getPaletteId(p.s, p.c);
                    this.grid.set(keyTarget, pid);
                    this.grid.set(keyStart, GRID_VOID);
                } else {
                    this.grid.set(keyTarget, valStart);
                    this.grid.delete(keyStart);
                }

                if(piece.s === 'â™”') this.kingPos.w = {c: targetC, r: targetR};
                if(piece.s === 'â™š') this.kingPos.b = {c: targetC, r: targetR};

                const isSafe = !this.isInCheck(piece.c);

                if (valTarget === undefined) this.grid.delete(keyTarget); else this.grid.set(keyTarget, valTarget);
                if (valStart === undefined) this.grid.delete(keyStart); else this.grid.set(keyStart, valStart);

                this.kingPos.w = wasKingW;
                this.kingPos.b = wasKingB;

                return isSafe;
            }
            tryPlacePiece(c, r) {
                if (c < 0 || c >= this.boardSize || r < 0 || r >= this.boardSize) return;
                // ĞŸÑ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ĞºĞ° Ğ³ÑƒĞ¼ĞºĞ¸
                if (this.curSymbol === 'âŒ' || this.curSymbol === 'eraser') {
                    this.removePiece(c, r);
                } else {
                    // Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ğ¼Ğ¾ Ñ„Ñ–Ğ³ÑƒÑ€Ñƒ
                    this.setPiece(c, r, { s: this.curSymbol, c: this.curColor, hasMoved: false });
                }
            }

              calculateHighlights(piece, cx, cy) {
                if (!this.rulesEnabled) return;
                
                this.highlightedMoves = [];
                const type = piece.s;
                const isWhite = piece.c === 'w';

                // Ğ”Ğ¾Ğ¿Ğ¾Ğ¼Ñ–Ğ¶Ğ½Ğ° Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ: Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”, Ñ‡Ğ¸ Ğ±ĞµĞ·Ğ¿ĞµÑ‡Ğ½Ğ¸Ğ¹ Ñ…Ñ–Ğ´, Ğ¿ĞµÑ€Ñˆ Ğ½Ñ–Ğ¶ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ ĞºÑ€Ğ°Ğ¿ĞºÑƒ
                const tryAddMove = (tx, ty, isCapture) => {
                    if (this.simulateMoveAndCheckSafety(piece, cx, cy, tx, ty)) {
                        this.highlightedMoves.push({ type: 'point', c: tx, r: ty, capture: isCapture });
                    }
                };

                // --- 1. Ğ¡Ğ»Ğ°Ğ¹Ğ´ĞµÑ€Ğ¸ ---
                const castRay = (dx, dy, maxLimit = this.boardSize) => {
                    const end = this.findRayEnd(cx, cy, dx, dy, maxLimit);
                    let dist = Math.max(Math.abs(end.x - cx), Math.abs(end.y - cy));
                    if (end.hit || end.ally) dist--;

                    // ĞœĞ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ»Ñ–Ğ½Ñ–Ñ (Ğ±ĞµĞ·Ğ¿ĞµĞºÑƒ Ğ¿Ñ€Ğ¾Ğ¼Ñ–Ğ¶Ğ½Ğ¸Ñ… Ñ‚Ğ¾Ñ‡Ğ¾Ğº Ğ·Ğ°Ğ·Ğ²Ğ¸Ñ‡Ğ°Ğ¹ Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑÑ‚ÑŒ Ğ´Ğ»Ñ ÑˆĞ²Ğ¸Ğ´ĞºĞ¾ÑÑ‚Ñ–, 
                    // Ğ°Ğ»Ğµ ĞºĞ¾Ñ€Ğ¾Ğ»Ñ– Ğ½Ğµ Ñ…Ğ¾Ğ´ÑÑ‚ÑŒ Ğ»Ñ–Ğ½Ñ–ÑĞ¼Ğ¸, Ñ‚Ğ¾Ğ¼Ñƒ Ñ†Ğµ ĞĞš)
                    if (dist > 0) {
                        this.highlightedMoves.push({ type: 'ray', cx: cx, cy: cy, dx: dx, dy: dy, len: dist });
                    }

                    // ĞÑ‚Ğ°ĞºĞ° Ğ² ĞºÑ–Ğ½Ñ†Ñ– Ğ»Ñ–Ğ½Ñ–Ñ—
                    if (end.hit && !end.ally) {
                        tryAddMove(end.x, end.y, true);
                    }
                };

                // --- 2. Ğ¡Ñ‚Ñ€Ğ¸Ğ±ÑƒĞ½Ğ¸ (ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ, ĞšÑ–Ğ½ÑŒ) ---
                const checkJump = (dx, dy) => {
                    const tx = cx + dx; const ty = cy + dy;
                    if (tx >= 0 && tx < this.boardSize && ty >= 0 && ty < this.boardSize) {
                        const target = this.getPiece(tx, ty);
                        if (!target) {
                             tryAddMove(tx, ty, false);
                        } else if (target.c !== piece.c) {
                             tryAddMove(tx, ty, true);
                        }
                    }
                };

                // Ğ¨Ğ°ÑˆĞºĞ¸
                if (this.checkersSymbols.has(type)) {
                    const moves = this.generatePotentialMoves(piece, cx, cy);
                    moves.forEach(m => this.highlightedMoves.push({ type: 'point', c: m.c, r: m.r, capture: !!m.isCapture }));
                    return;
                }

                if (['â™–','â™œ','â™•','â™›'].includes(type)) { castRay(1,0); castRay(-1,0); castRay(0,1); castRay(0,-1); }
                if (['â™—','â™','â™•','â™›'].includes(type)) { castRay(1,1); castRay(-1,1); castRay(1,-1); castRay(-1,-1); }
                if (['â™˜','â™'].includes(type)) { [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d => checkJump(d[0], d[1])); }
                if (['â™”','â™š'].includes(type)) { for(let i=-1;i<=1;i++) for(let j=-1;j<=1;j++) if(i||j) checkJump(i,j); }

                // Mega Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸
                if (megaDefs[type]) {
                     const def = megaDefs[type];
                     const FLIP_Y_LIST = ['ğŸš€','âš“','ğŸ¹','ğŸ£','ğŸ˜º','ğŸ—','ğŸŒŠ','ğŸ—¡ï¸','ğŸ“œ'];
                     const processComp = (comp) => {
                        const dirs = this._resolveDirs(comp.d || comp.dirs);
                        const limit = comp.max || this.boardSize;
                        const moveType = comp.t || def.t;
                        for (const d of dirs) {
                            let dirX = d[0], dirY = d[1];
                            if (!isWhite && FLIP_Y_LIST.includes(type)) dirY = -dirY;
                            if (moveType === 'slide' || moveType === 'slide_jump') castRay(dirX, dirY, limit);
                            else { let mul = comp.mul || 1; checkJump(dirX * mul, dirY * mul); }
                        }
                     };
                     if (def.t === 'complex') def.comps.forEach(c => processComp(c)); else processComp(def);
                }

                // ĞŸÑ–ÑˆĞ°ĞºĞ¸
                if (['â™™','â™Ÿ'].includes(type)) {
                    const dir = isWhite ? -1 : 1;
                    const fwd1 = this.getPiece(cx, cy + dir);
                    if (!fwd1) {
                        tryAddMove(cx, cy + dir, false);
                        if (!piece.hasMoved) {
                            const fwd2 = this.getPiece(cx, cy + dir * 2);
                            if (!fwd2) tryAddMove(cx, cy + dir * 2, false);
                        }
                    }
                    [1, -1].forEach(dx => {
                        const tx = cx + dx; const ty = cy + dir;
                        const t = this.getPiece(tx, ty);
                        if (t && t.c !== piece.c) tryAddMove(tx, ty, true);
                    });
                }
            }
            onMouseDown(e) {
                if (this.gameOver || this.isGenerating || this.promotionPending) return;
                
                this.clickStart = { x: e.clientX, y: e.clientY };
                const w = this.screenToWorld(e.clientX, e.clientY);
                const c = Math.floor(w.x / this.cellSize); 
                const r = Math.floor(w.y / this.cellSize);

                // --- Ğ›Ğ†Ğ’Ğ ĞšĞĞĞŸĞšĞ (Ğ›ĞšĞœ): Ğ“Ñ€Ğ° Ğ°Ğ±Ğ¾ ĞŸĞµÑ€ĞµĞ¼Ñ–Ñ‰ĞµĞ½Ğ½Ñ ĞšĞ°Ğ¼ĞµÑ€Ğ¸ ---
                if (e.button === 0) {
                    this.customArrows = []; // ĞšĞ»Ñ–Ğº Ğ»Ñ–Ğ²Ğ¾Ñ ÑÑ‚Ğ¸Ñ€Ğ°Ñ” ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ¸ (ÑĞº Ğ½Ğ° Lichess)

                    // 1. Ğ†Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ“Ğ£ĞœĞšĞ (Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ¼Ğ¸Ñ‚Ñ‚Ñ”Ğ²Ğµ)
                    if (!this.turnModeEnabled && (this.curSymbol === 'âŒ' || this.curSymbol === 'delete')) {
                        this.tryPlacePiece(c, r); 
                        return; 
                    }
                    
                    // 2. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ñ” Ñ‚ÑƒÑ‚ Ñ„Ñ–Ğ³ÑƒÑ€Ğ°, ÑĞºÑƒ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ²Ğ·ÑÑ‚Ğ¸
                    const piece = this.getPiece(c, r);
                    let canGrabPiece = false;
                    if (piece) {
                        if (!this.turnModeEnabled || piece.c === this.currentTurn) {
                            canGrabPiece = true;
                        }
                    }

                    if (canGrabPiece) {
                        // Ğ¯ĞºÑ‰Ğ¾ Ğ¿Ğ¾Ğ¿Ğ°Ğ»Ğ¸ Ğ¿Ğ¾ Ñ„Ñ–Ğ³ÑƒÑ€Ñ– -> Ğ¢Ğ¯Ğ“ĞĞ•ĞœĞ Ğ¤Ğ†Ğ“Ğ£Ğ Ğ£
                        this.isDraggingPiece = true;
                        this.draggedPiece = { data: piece, startC: c, startR: r };
                        this.calculateHighlights(piece, c, r);
                    } else {
                        // Ğ¯ĞºÑ‰Ğ¾ Ğ¿Ğ¾Ğ¿Ğ°Ğ»Ğ¸ Ğ² Ğ¿ÑƒÑÑ‚Ğµ Ğ¼Ñ–ÑÑ†Ğµ -> Ğ¢Ğ¯Ğ“ĞĞ•ĞœĞ Ğ”ĞĞ¨ĞšĞ£ (ĞšĞĞœĞ•Ğ Ğ£)
                        this.isDragging = true; 
                        this.lastMouse = { x: e.clientX, y: e.clientY }; 
                        this.canvas.style.cursor = "grabbing";
                    }
                } 
                
                // --- ĞŸĞ ĞĞ’Ğ ĞšĞĞĞŸĞšĞ (ĞŸĞšĞœ): Ğ¢Ñ–Ğ»ÑŒĞºĞ¸ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ ÑÑ‚Ñ€Ñ–Ğ»Ğ¾Ğº ---
                else if (e.button === 2) {
                    // Ğ—Ğ°Ğ¿Ğ°Ğ¼'ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ ÑÑ‚Ğ°Ñ€Ñ‚ ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ¸ (Shift Ğ±Ñ–Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±ĞµĞ½)
                    if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) {
                        this.rmbStart = { c, r };
                    } else {
                        this.rmbStart = null;
                    }
                }
            }
           onMouseMove(e) {
                this.mouse.x = e.clientX; this.mouse.y = e.clientY;
                if (this.promotionPending) return;

                const w = this.screenToWorld(e.clientX, e.clientY); 
                const c = Math.floor(w.x / this.cellSize); 
                const r = Math.floor(w.y / this.cellSize);

                // --- Ğ›ĞĞ“Ğ†ĞšĞ ĞœĞĞ›Ğ®Ğ’ĞĞĞĞ¯ Ğ¡Ğ¢Ğ Ğ†Ğ›ĞšĞ˜ (REAL-TIME) ---
                if (this.rmbStart) {
                    const endC = Math.max(0, Math.min(this.boardSize - 1, c));
                    const endR = Math.max(0, Math.min(this.boardSize - 1, r));

                    // Ğ¯ĞºÑ‰Ğ¾ Ğ¼Ğ¸ÑˆĞºÑƒ Ğ²Ñ–Ğ´Ğ²ĞµĞ»Ğ¸ Ğ²Ñ–Ğ´ ÑÑ‚Ğ°Ñ€Ñ‚Ğ¾Ğ²Ğ¾Ñ— ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸, ÑÑ‚Ğ²Ğ¾Ñ€ÑÑ”Ğ¼Ğ¾ Ğ¿Ñ€ĞµĞ²'Ñ
                    if (this.rmbStart.c !== endC || this.rmbStart.r !== endR) {
                        this.previewArrow = { sx: this.rmbStart.c, sy: this.rmbStart.r, ex: endC, ey: endR };
                    } else {
                        this.previewArrow = null;
                    }
                    // ĞŸÑ€Ğ¸Ğ¼ÑƒÑĞ¾Ğ²Ğµ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ĞµĞºÑ€Ğ°Ğ½Ñƒ Ğ±ĞµĞ· Ğ¿Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ĞµÑ€ĞµÑ€Ğ°Ñ…ÑƒĞ½ĞºÑƒ UI
                    // (Ğ²Ğ¸ĞºĞ»Ğ¸ĞºĞ°Ñ”Ğ¼Ğ¾ render Ñƒ Ñ†Ğ¸ĞºĞ»Ñ– animate, Ñ‚Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ñ‡ĞµĞºĞ°Ñ”Ğ¼Ğ¾ Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ°Ğ´Ñ€Ñƒ)
                }

                // 1. Ğ›Ğ¾Ğ³Ñ–ĞºĞ° Ğ¿ĞµÑ€ĞµĞ¼Ñ–Ñ‰ĞµĞ½Ğ½Ñ ĞºĞ°Ğ¼ĞµÑ€Ğ¸ (Ñ‚ĞµĞ¿ĞµÑ€ Ğ¿Ñ€Ğ°Ñ†ÑÑ” Ğ²Ñ–Ğ´ Ğ›ĞšĞœ)
                if (this.isDragging) { 
                    const dx = e.clientX - this.lastMouse.x;
                    const dy = e.clientY - this.lastMouse.y;

                    this.camera.x += dx; 
                    this.camera.y += dy; 
                    this.targetCamera.x += dx;
                    this.targetCamera.y += dy;

                    this.lastMouse = { x: e.clientX, y: e.clientY }; 
                    this.clampCamera(); 
                }
                
                // 2. Ğ›Ğ¾Ğ³Ñ–ĞºĞ° Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ñ„Ñ–Ğ³ÑƒÑ€ (Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€)
                if (this.isPainting) this.tryPlacePiece(c, r);

                // 3. ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚ Ğ² UI
                if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) { 
                    const file = this.getFileLabel(c); 
                    const rank = this.boardSize - r; 
                    document.getElementById('coord').innerText = `${file}${rank}`; 
                }
            }


                       onMouseUp(e) {
                // --- ĞŸĞ ĞĞ’Ğ ĞšĞĞĞŸĞšĞ (Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ¸) ---
                if (e.button === 2 && this.rmbStart) {
                    const w = this.screenToWorld(e.clientX, e.clientY);
                    let rawC = Math.floor(w.x / this.cellSize); 
                    let rawR = Math.floor(w.y / this.cellSize);
                    const endC = Math.max(0, Math.min(this.boardSize - 1, rawC));
                    const endR = Math.max(0, Math.min(this.boardSize - 1, rawR));

                    if (this.rmbStart.c !== endC || this.rmbStart.r !== endR) {
                        const newArrow = { sx: this.rmbStart.c, sy: this.rmbStart.r, ex: endC, ey: endR };
                        const idx = this.customArrows.findIndex(a => a.sx === newArrow.sx && a.sy === newArrow.sy && a.ex === newArrow.ex && a.ey === newArrow.ey);
                        if (idx >= 0) this.customArrows.splice(idx, 1); 
                        else this.customArrows.push(newArrow);
                    }
                    this.rmbStart = null; 
                    this.previewArrow = null; // <--- Ğ”ĞĞ”ĞĞĞ: ĞÑ‡Ğ¸Ñ‰ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ñ€ĞµĞ²'Ñ
                    this.updateUI(); 
                    return;
                }

                if (e.button === 2) this.isPainting = false;
                if (this.promotionPending) return;

                // --- Ğ›Ğ†Ğ’Ğ ĞšĞĞĞŸĞšĞ (Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ Ñ…Ğ¾Ğ´Ñƒ Ğ°Ğ±Ğ¾ ĞºĞ°Ğ¼ĞµÑ€Ğ¸) ---
                if (e.button === 0) {
                    const w = this.screenToWorld(e.clientX, e.clientY);
                    const c = Math.floor(w.x / this.cellSize); 
                    const r = Math.floor(w.y / this.cellSize);

                    // 1. Ğ¡Ğ¿Ğ¾Ñ‡Ğ°Ñ‚ĞºÑƒ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ñ†Ğµ Ğ±ÑƒĞ² ĞºĞ»Ñ–Ğº
                    let isClick = false;
                    if (this.clickStart) {
                        const dist = Math.hypot(e.clientX - this.clickStart.x, e.clientY - this.clickStart.y);
                        if (dist < 5) isClick = true;
                    }

                    // 2. Ğ¯ĞºÑ‰Ğ¾ Ğ¼Ğ¸ Ñ€ÑƒÑ…Ğ°Ğ»Ğ¸ ĞºĞ°Ğ¼ĞµÑ€Ñƒ
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.canvas.style.cursor = "grab";
                        if (!isClick) return; 
                    }

                    // Ğ¡Ğ¦Ğ•ĞĞĞ Ğ†Ğ™ Ğ: ĞšĞ›Ğ†Ğš (Ğ’Ğ¸Ğ±Ñ–Ñ€ Ğ°Ğ±Ğ¾ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¾Ñ€)
                    if (isClick) {
                        if (!this.turnModeEnabled) {
                            this.tryPlacePiece(c, r);
                        }
                        this.isDraggingPiece = false;
                        this.draggedPiece = null;
                        this.highlightedMoves = [];
                        this.updateUI();
                        return; 
                    }

                    // Ğ¡Ğ¦Ğ•ĞĞĞ Ğ†Ğ™ Ğ‘: ĞšĞ†ĞĞ•Ğ¦Ğ¬ ĞŸĞ•Ğ Ğ•Ğ¢Ğ¯Ğ“Ğ£Ğ’ĞĞĞĞ¯ Ğ¤Ğ†Ğ“Ğ£Ğ Ğ˜ (Ğ¥Ñ–Ğ´)
                    if (this.isDraggingPiece && this.draggedPiece) {
                        if (c >= 0 && c < this.boardSize && r >= 0 && r < this.boardSize) {
                            if (c !== this.draggedPiece.startC || r !== this.draggedPiece.startR) {
                                
                                // 1. ĞÑ‚Ñ€Ğ¸Ğ¼ÑƒÑ”Ğ¼Ğ¾ Ğ²ÑÑ– Ğ»ĞµĞ³Ğ°Ğ»ÑŒĞ½Ñ– Ñ…Ğ¾Ğ´Ğ¸ Ğ´Ğ»Ñ Ñ†Ñ–Ñ”Ñ— Ñ„Ñ–Ğ³ÑƒÑ€Ğ¸
                                const potentialMoves = this.generatePotentialMoves(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR);
                                // 2. Ğ¨ÑƒĞºĞ°Ñ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ñ” ÑĞµÑ€ĞµĞ´ Ğ½Ğ¸Ñ… Ñ‚Ğ¾Ğ¹, ÑĞºĞ¸Ğ¹ Ğ·Ñ€Ğ¾Ğ±Ğ¸Ğ² Ğ³Ñ€Ğ°Ğ²ĞµÑ†ÑŒ (Ğ¿Ğ¾ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ°Ñ…)
                                const chosenMove = potentialMoves.find(m => m.c === c && m.r === r);

                                if (chosenMove) {
                                    // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ±ĞµĞ·Ğ¿ĞµĞºĞ¸ (Ğ´Ğ»Ñ ÑˆĞ°Ñ…Ñ–Ğ²)
                                    let isMoveSafe = true;
                                    if (this.rulesEnabled && !this.checkersSymbols.has(this.draggedPiece.data.s)) {
                                        isMoveSafe = this.simulateMoveAndCheckSafety(this.draggedPiece.data, this.draggedPiece.startC, this.draggedPiece.startR, c, r);
                                    }
                                    
                                    if (isMoveSafe) {
                                        // --- Ğ›ĞĞ“Ğ†ĞšĞ Ğ”Ğ›Ğ¯ Ğ¨ĞĞ¨ĞĞš (Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ) ---
                                        if (this.checkersSymbols.has(this.draggedPiece.data.s) && chosenMove.isCapture) {
                                            // Ğ’Ğ¸Ğ´Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿Ğ¾Ğ±Ğ¸Ñ‚Ñƒ ÑˆĞ°ÑˆĞºÑƒ
                                            if (chosenMove.captured) {
                                                this.removePiece(chosenMove.captured.x, chosenMove.captured.y);
                                            }
                                        }

                                        // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¿Ñ–ÑˆĞ°ĞºĞ° Ğ½Ğ° Ğ¿ĞµÑ€ĞµÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ (Ğ¨Ğ°Ñ…Ğ¸ Ñ‚Ğ° Ğ¨Ğ°ÑˆĞºĞ¸)
                                        const isWhite = this.draggedPiece.data.c === 'w';
                                        const isPawn = this.draggedPiece.data.s === 'â™™' || this.draggedPiece.data.s === 'â™Ÿ';
                                        const isCheckerMan = this.draggedPiece.data.s === 'â›€' || this.draggedPiece.data.s === 'â›‚';
                                        const promotionRow = isWhite ? 0 : this.boardSize - 1;
                                        
                                        // ĞŸĞµÑ€ĞµÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ ĞŸÑ–ÑˆĞ°ĞºĞ° (Ğ¨Ğ°Ñ…Ğ¸)
                                        if (isPawn && r === promotionRow) {
                                            this.promotionPending = { piece: this.draggedPiece.data, startC: this.draggedPiece.startC, startR: this.draggedPiece.startR, endC: c, endR: r };
                                            this.showPromotionDialog(this.draggedPiece.data.c);
                                            this.draggedPiece = null; this.isDraggingPiece = false; this.highlightedMoves = []; return;
                                        }
                                        // ĞŸĞµÑ€ĞµÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ”Ğ°Ğ¼ĞºĞ¸ (Ğ¨Ğ°ÑˆĞºĞ¸) - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾
                                        if (isCheckerMan && r === promotionRow) {
                                            this.draggedPiece.data.s = isWhite ? 'â›' : 'â›ƒ';
                                        }

                                        // Ğ—Ğ°Ğ¿Ğ¸Ñ Ñ…Ğ¾Ğ´Ñƒ Ğ² Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ
                                        const startCoord = this.getCoordString(this.draggedPiece.startC, this.draggedPiece.startR);
                                        const endCoord = this.getCoordString(c, r);
                                        const isCap = !!this.getPiece(c,r) || (chosenMove.isCapture); // Ğ’Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ±Ğ¾Ñ Ğ² ÑˆĞ°ÑˆĞºĞ°Ñ…
                                        
                                        const historyStep = { turn: this.currentTurn, prevKingPos: { w: this.kingPos.w ? {...this.kingPos.w} : null, b: this.kingPos.b ? {...this.kingPos.b} : null }, multiJumpSource: null, changes: [], notation: { icon: this.draggedPiece.data.s, start: startCoord, end: endCoord, cap: isCap } };
                                        
                                        const recordState = (col, row) => { const k = this.getKey(col, row); const v = this.grid.get(k); historyStep.changes.push({ key: k, value: v }); };
                                        recordState(this.draggedPiece.startC, this.draggedPiece.startR); recordState(c, r);
                                        if (chosenMove.captured) recordState(chosenMove.captured.x, chosenMove.captured.y); // Ğ—Ğ°Ğ¿Ğ¸Ñ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ¾Ñ— ÑˆĞ°ÑˆĞºĞ¸
                                        
                                        this.moveHistory.push(historyStep);
                                        this.updateLogUI();
                                        
                                        // Ğ¤Ñ–Ğ·Ğ¸Ñ‡Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ¼Ñ–Ñ‰ĞµĞ½Ğ½Ñ
                                        this.removePiece(this.draggedPiece.startC, this.draggedPiece.startR);
                                        this.draggedPiece.data.x = c; this.draggedPiece.data.y = r; this.draggedPiece.data.hasMoved = true;
                                        this.setPiece(c, r, this.draggedPiece.data);
                                        
                                        // --- ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ ĞœĞ£Ğ›Ğ¬Ğ¢Ğ˜-Ğ‘Ğ†Ğ™ (Ğ¨ĞĞ¨ĞšĞ˜) ---
                                        if (this.checkersSymbols.has(this.draggedPiece.data.s) && chosenMove.isCapture) {
                                            // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾, Ñ‡Ğ¸ Ñ” Ñ‰Ğµ Ğ±Ñ–Ğ¹ Ğ· ĞĞĞ’ĞĞ‡ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ñ–Ñ—
                                            const followUpMoves = this.getCheckersMoves(this.draggedPiece.data, c, r, true); // true = onlyCaptures
                                            if (followUpMoves.length > 0) {
                                                this.multiJumpSource = { c: c, r: r }; // Ğ¤Ñ–ĞºÑÑƒÑ”Ğ¼Ğ¾ Ğ´Ğ¶ĞµÑ€ĞµĞ»Ğ¾ ÑÑ‚Ñ€Ğ¸Ğ±ĞºÑ–Ğ²
                                                // ĞĞ• ĞŸĞ•Ğ Ğ•Ğ”ĞĞ„ĞœĞ Ğ¥Ğ†Ğ”, Ğ¾Ğ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ UI Ñ– Ğ²Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾
                                                this.isDraggingPiece = false;
                                                this.draggedPiece = null;
                                                this.highlightedMoves = [];
                                                this.updateUI();
                                                return; 
                                            }
                                        }

                                        this.multiJumpSource = null; // Ğ¡ĞºĞ¸Ğ´Ğ°Ñ”Ğ¼Ğ¾ ÑĞµÑ€Ñ–Ñ, ÑĞºÑ‰Ğ¾ Ğ²Ğ¾Ğ½Ğ° Ğ·Ğ°ĞºÑ–Ğ½Ñ‡Ğ¸Ğ»Ğ°ÑÑŒ
                                        setTimeout(() => this.switchTurn(), 0);
                                    }
                                }
                            }
                        }
                    }
                }

                this.isDragging = false;
                this.isDraggingPiece = false;
                this.draggedPiece = null;
                this.highlightedMoves = []; 
                this.updateUI();
            }


            undoMove() {
                if (this.moveHistory.length === 0) return;
                const last = this.moveHistory.pop();

                last.changes.forEach(change => {
                    if (change.value === undefined) this.grid.delete(change.key);
                    else this.grid.set(change.key, change.value);
                });

                this.currentTurn = last.turn;
                this.kingPos = last.prevKingPos;
                this.multiJumpSource = last.multiJumpSource;
                this.gameOver = false;
                this.promotionPending = null;
                document.getElementById('promotionOverlay').style.display = 'none';
                document.getElementById('gameOverOverlay').style.display = 'none';

                this.highlightedMoves = [];
                this.updateTurnIndicator();
                this.updateUI();
                this.updateLogUI(); // <--- Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ
            }

            onKeyDown(e) {
                if (this.gameOver || this.turnModeEnabled || this.promotionPending) return;
                if (e.key === 'Delete') {
                    // Default delete key behavior is now Undo via main listener
                } else if (e.shiftKey && e.key === 'Delete') {
                    // Eraser tool
                    const w = this.screenToWorld(this.mouse.x, this.mouse.y);
                    const c = Math.floor(w.x / this.cellSize);
                    const r = Math.floor(w.y / this.cellSize);
                    this.removePiece(c, r);
                    this.updateUI();
                }
            }

            screenToWorld(sx, sy) { return { x: (sx - this.camera.x) / this.camera.zoom, y: (sy - this.camera.y) / this.camera.zoom }; }

            update() {
                // ĞšĞ»Ğ°Ğ²Ñ–Ğ°Ñ‚ÑƒÑ€Ğ° (Ñ€ÑƒÑ…Ğ°Ñ” Ñ†Ñ–Ğ»ÑŒ)
                const moveSpeed = 15;
                if (this.keys.ArrowLeft) this.targetCamera.x += moveSpeed;
                if (this.keys.ArrowRight) this.targetCamera.x -= moveSpeed;
                if (this.keys.ArrowUp) this.targetCamera.y += moveSpeed;
                if (this.keys.ArrowDown) this.targetCamera.y -= moveSpeed;

                // Ğ†Ğ½Ñ‚ĞµÑ€Ğ¿Ğ¾Ğ»ÑÑ†Ñ–Ñ (Lerp)
                // Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ„Ğ°ĞºÑ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ²ÑÑŒĞ¾Ğ³Ğ¾, Ñ‰Ğ¾Ğ± Ñ€ÑƒÑ… Ğ±ÑƒĞ² ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ¸Ğ¼
                const factor = 0.12; 

                // ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ÑÑ”Ğ¼Ğ¾ Ñ€Ñ–Ğ·Ğ½Ğ¸Ñ†Ñ, Ñ‰Ğ¾Ğ± Ğ½Ğµ Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ·Ğ°Ğ¹Ğ²Ğ¾Ğ³Ğ¾ (ĞµĞºĞ¾Ğ½Ğ¾Ğ¼Ñ–Ñ CPU)
                const diffZ = Math.abs(this.targetCamera.zoom - this.camera.zoom);
                const diffX = Math.abs(this.targetCamera.x - this.camera.x);
                const diffY = Math.abs(this.targetCamera.y - this.camera.y);

                // ĞŸĞ¾Ñ€Ñ–Ğ³ Ñ‡ÑƒÑ‚Ğ»Ğ¸Ğ²Ğ¾ÑÑ‚Ñ– Ğ·Ğ°Ğ»ĞµĞ¶Ğ¸Ñ‚ÑŒ Ğ²Ñ–Ğ´ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ñƒ
                const threshold = Math.max(1e-10, this.targetCamera.zoom * 0.0001);

                if (diffZ > threshold || diffX > 1 || diffY > 1) {
                    this.camera.zoom += (this.targetCamera.zoom - this.camera.zoom) * factor;
                    this.camera.x += (this.targetCamera.x - this.camera.x) * factor;
                    this.camera.y += (this.targetCamera.y - this.camera.y) * factor;

                    // ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ UI
                    if (this.camera.zoom > 0) {
                        document.getElementById('zoomSlider').value = Math.log10(this.camera.zoom);
                    }
                    let disp = Math.round(this.camera.zoom * 100) + '%';
                    if (this.camera.zoom < 0.01) disp = this.camera.zoom.toExponential(2);
                    document.getElementById('zoomDisplay').innerText = disp;
                } else {
                    // "ĞŸÑ€Ğ¸Ğ¼Ğ°Ğ³Ğ½Ñ–Ñ‡ÑƒÑ”Ğ¼Ğ¾" Ğ² ĞºÑ–Ğ½Ñ†Ñ– Ğ°Ğ½Ñ–Ğ¼Ğ°Ñ†Ñ–Ñ—, Ñ‰Ğ¾Ğ± Ğ¿Ñ€Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¸ Ğ¼Ñ–ĞºÑ€Ğ¾-Ñ‚Ñ€ĞµĞ¼Ñ‚Ñ–Ğ½Ğ½Ñ
                    this.camera.zoom = this.targetCamera.zoom;
                    this.camera.x = this.targetCamera.x;
                    this.camera.y = this.targetCamera.y;
                }

                // ĞĞ±Ğ¼ĞµĞ¶ÑƒÑ”Ğ¼Ğ¾ ĞºĞ°Ğ¼ĞµÑ€Ñƒ (Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ¿Ğ¾Ğ»ĞµÑ‚Ñ–Ğ»Ğ° Ğ² ĞºĞ¾ÑĞ¼Ğ¾Ñ)
                this.clampCamera();
            }

            drawCustomArrows(ctx, cs, bx, by) {
                // ĞĞ±'Ñ”Ğ´Ğ½ÑƒÑ”Ğ¼Ğ¾ Ğ¿Ğ¾ÑÑ‚Ñ–Ğ¹Ğ½Ñ– ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ¸ Ğ· Ñ‚Ğ¸Ğ¼Ñ‡Ğ°ÑĞ¾Ğ²Ğ¾Ñ (ÑĞºÑ‰Ğ¾ Ğ²Ğ¾Ğ½Ğ° Ñ”) Ğ´Ğ»Ñ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ
                let arrowsToDraw = [...this.customArrows];
                if (this.previewArrow) {
                    arrowsToDraw.push(this.previewArrow);
                }

                if (!arrowsToDraw.length) return;

                ctx.save();
                
                // Ğ¡Ñ‚Ğ¸Ğ»ÑŒ Lichess: Ğ—ĞµĞ»ĞµĞ½Ğ¸Ğ¹, Ğ½Ğ°Ğ¿Ñ–Ğ²Ğ¿Ñ€Ğ¾Ğ·Ğ¾Ñ€Ğ¸Ğ¹
                ctx.fillStyle = "rgba(21, 120, 27, 0.85)"; 
                
                // ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ñ€Ğ¾Ğ¿Ğ¾Ñ€Ñ†Ñ–Ğ¹ ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ¸ Ğ²Ñ–Ğ´Ğ½Ğ¾ÑĞ½Ğ¾ Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€Ñƒ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸ (cs)
                const lineWidth = cs * 0.15;  // Ğ¢Ğ¾Ğ²Ñ‰Ğ¸Ğ½Ğ° Ñ…Ğ²Ğ¾ÑÑ‚Ğ°
                const headLen = cs * 0.35;    // Ğ”Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ğ° Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¸
                const headWidth = cs * 0.45;  // Ğ¨Ğ¸Ñ€Ğ¸Ğ½Ğ° Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¸

                arrowsToDraw.forEach(arrow => {
                    const startX = bx + arrow.sx * cs + cs / 2;
                    const startY = by + arrow.sy * cs + cs / 2;
                    const endX = bx + arrow.ex * cs + cs / 2;
                    const endY = by + arrow.ey * cs + cs / 2;

                    const dx = endX - startX;
                    const dy = endY - startY;
                    const angle = Math.atan2(dy, dx);
                    const len = Math.hypot(dx, dy);

                    // Ğ¯ĞºÑ‰Ğ¾ ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ° Ğ·Ğ°Ğ½Ğ°Ğ´Ñ‚Ğ¾ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ°, Ğ½Ğµ Ğ¼Ğ°Ğ»ÑÑ”Ğ¼Ğ¾
                    if (len < cs * 0.2) return;

                    // Ğ’Ñ–Ğ´ÑÑ‚ÑƒĞ¿ Ğ½Ğ°Ğ·Ğ°Ğ´, Ñ‰Ğ¾Ğ± Ğ²Ñ–ÑÑ‚Ñ€Ñ Ğ±ÑƒĞ»Ğ¾ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ² Ñ†ĞµĞ½Ñ‚Ñ€Ñ– ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ¸
                    const adjustedLen = len - (cs * 0.05);

                    ctx.save();
                    // ĞŸĞµÑ€ĞµĞ½Ğ¾ÑĞ¸Ğ¼Ğ¾ Ñ†ĞµĞ½Ñ‚Ñ€ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚ Ñƒ Ğ¿Ğ¾Ñ‡Ğ°Ñ‚Ğ¾Ğº ÑÑ‚Ñ€Ñ–Ğ»ĞºĞ¸ Ñ– Ğ¿Ğ¾Ğ²ĞµÑ€Ñ‚Ğ°Ñ”Ğ¼Ğ¾
                    ctx.translate(startX, startY);
                    ctx.rotate(angle);

                    // ĞœĞ°Ğ»ÑÑ”Ğ¼Ğ¾ ÑÑ‚Ñ€Ñ–Ğ»ĞºÑƒ
                    ctx.beginPath();
                    ctx.lineTo(0, -lineWidth / 2);
                    ctx.lineTo(adjustedLen - headLen, -lineWidth / 2);
                    ctx.lineTo(adjustedLen - headLen, -headWidth / 2);
                    ctx.lineTo(adjustedLen, 0);
                    ctx.lineTo(adjustedLen - headLen, headWidth / 2);
                    ctx.lineTo(adjustedLen - headLen, lineWidth / 2);
                    ctx.lineTo(0, lineWidth / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                });
                ctx.restore();
            }
            
            render() {
                const ctx = this.ctx;
                const width = this.canvas.width; const height = this.canvas.height;
                const cs = this.cellSize * this.camera.zoom;

                // 1. ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ
                ctx.fillStyle = this.colors.void;
                ctx.fillRect(0, 0, width, height);

                const bx = this.camera.x; const by = this.camera.y;
                // ĞœĞµĞ¶Ñ– Ğ²Ğ¸Ğ´Ğ¸Ğ¼Ğ¾Ğ³Ğ¾ ĞµĞºÑ€Ğ°Ğ½Ñƒ (Ñƒ ĞºĞ»Ñ–Ñ‚Ğ¸Ğ½ĞºĞ°Ñ…)
                const startCol = Math.floor((-this.camera.x) / cs);
                const endCol = Math.floor((width - this.camera.x) / cs) + 1;
                const startRow = Math.floor((-this.camera.y) / cs);
                const endRow = Math.floor((height - this.camera.y) / cs) + 1;
                
                const boardPixelW = this.boardSize * cs; const boardPixelH = this.boardSize * cs;

                // 2. ĞœĞ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ´Ğ¾ÑˆĞºĞ¸
                // 2. ĞœĞ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ´Ğ¾ÑˆĞºĞ¸
                if (bx < width && by < height && bx + boardPixelW > 0 && by + boardPixelH > 0) {
                     ctx.fillStyle = this.colors.light;
                     
                     // ĞĞŸĞ¢Ğ˜ĞœĞ†Ğ—ĞĞ¦Ğ†Ğ¯: Ğ¯ĞºÑ‰Ğ¾ Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€ Ğ´Ğ¾ÑˆĞºĞ¸ Infinity (Ñ‡ĞµÑ€ĞµĞ· Ğ²ĞµĞ»Ğ¸Ñ‡ĞµĞ·Ğ½Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾), Ğ¼Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ½Ğ° Ğ²ĞµÑÑŒ ĞµĞºÑ€Ğ°Ğ½
                     const drawW = (boardPixelW > width || !isFinite(boardPixelW)) ? width : boardPixelW;
                     const drawH = (boardPixelH > height || !isFinite(boardPixelH)) ? height : boardPixelH;

                     ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), drawW, drawH);
                     ctx.fillStyle = this.colors.dark;

                     // ĞĞŸĞ¢Ğ˜ĞœĞ†Ğ—ĞĞ¦Ğ†Ğ¯: ĞœĞ°Ğ»ÑÑ”Ğ¼Ğ¾ ĞºĞ²Ğ°Ğ´Ñ€Ğ°Ñ‚Ğ¸ĞºĞ¸ Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ ÑĞºÑ‰Ğ¾ Ğ²Ğ¾Ğ½Ğ¸ Ğ±Ñ–Ğ»ÑŒÑˆÑ– Ğ·Ğ° 3 Ğ¿Ñ–ĞºÑĞµĞ»Ñ–
                     // Ğ¯ĞºÑ‰Ğ¾ cs Ğ´ÑƒĞ¶Ğµ Ğ¼Ğ°Ğ»Ğ¸Ğ¹, Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ñ‚Ğ¸ Ğ¼Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ğ¸ ĞºĞ²Ğ°Ğ´Ñ€Ğ°Ñ‚Ğ¸ĞºÑ–Ğ² â€” Ñ†Ğµ ÑĞ¼ĞµÑ€Ñ‚ÑŒ Ğ´Ğ»Ñ FPS. 
                     // Ğ¢Ğ¾Ğ¼Ñƒ Ğ¼Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ÑÑƒÑ†Ñ–Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ½Ğ°Ğ¿Ñ–Ğ²Ğ¿Ñ€Ğ¾Ğ·Ğ¾Ñ€Ğ¸Ğ¹ ÑˆĞ°Ñ€ (ĞµÑ„ĞµĞºÑ‚ ÑĞµÑ€ĞµĞ´Ğ½ÑŒĞ¾Ğ³Ğ¾ ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ñƒ).
                     if (cs > 3) {
                         ctx.beginPath();
                         const renderStartC = Math.max(0, startCol);
                         const renderEndC = Math.min(this.boardSize, endCol);
                         const renderStartR = Math.max(0, startRow);
                         const renderEndR = Math.min(this.boardSize, endRow);

                         for (let r = renderStartR; r < renderEndR; r++) {
                             let c = renderStartC;
                             // Ğ›Ğ¾Ğ³Ñ–ĞºĞ° ÑˆĞ°Ñ…Ñ–Ğ²Ğ½Ğ¸Ñ†Ñ–: (r+c) Ğ½ĞµĞ¿Ğ°Ñ€Ğ½Ğµ = Ñ‚ĞµĞ¼Ğ½Ğµ
                             if ((r % 2) !== 0) { if (c % 2 !== 0) c++; } else { if (c % 2 === 0) c++; }
                             for (; c < renderEndC; c += 2) {
                                 ctx.rect((bx + c * cs) | 0, (by + r * cs) | 0, Math.ceil(cs), Math.ceil(cs));
                             }
                         }
                         ctx.fill();
                     } else {
                         // Ğ ĞµĞ¶Ğ¸Ğ¼ "Solid": ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ğ·Ğ°Ğ»Ğ¸Ğ²Ğ°Ñ”Ğ¼Ğ¾ Ñ‚ĞµĞ¼Ğ½Ğ¸Ğ¼ ĞºĞ¾Ğ»ÑŒĞ¾Ñ€Ğ¾Ğ¼ Ğ· Ğ¿Ñ€Ğ¾Ğ·Ğ¾Ñ€Ñ–ÑÑ‚Ñ 50%
                         ctx.globalAlpha = 0.5;
                         ctx.fillRect(Math.max(bx, 0), Math.max(by, 0), drawW, drawH);
                         ctx.globalAlpha = 1.0;
                     }
                     
                     ctx.strokeStyle = this.colors.border;
                     ctx.lineWidth = Math.max(2, cs * 0.1);
                     
                     // ĞœĞ°Ğ»ÑÑ”Ğ¼Ğ¾ Ñ€Ğ°Ğ¼ĞºÑƒ, Ñ‚Ñ–Ğ»ÑŒĞºĞ¸ ÑĞºÑ‰Ğ¾ Ñ€Ğ¾Ğ·Ğ¼Ñ–Ñ€Ğ¸ ÑĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ½Ñ– (Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ»Ğ°Ğ¼Ğ°Ğ»Ğ¾ ĞºĞ°Ğ½Ğ²Ğ°Ñ Ğ¿Ñ€Ğ¸ 10^2625)
                     if (isFinite(boardPixelW) && isFinite(boardPixelH)) {
                        ctx.strokeRect(bx, by, boardPixelW, boardPixelH);
                     }
                }

                // 3. ĞŸÑ–Ğ´ÑĞ²Ñ–Ñ‚ĞºĞ° Ğ¨Ğ°Ñ…/ĞœĞ°Ñ‚
                if (this.rulesEnabled && cs > 2) {
                    for (const color of ['w', 'b']) {
                        if (this.kingsInCheck[color]) {
                            const k = this.kingsInCheck[color];
                            if (k.c >= startCol && k.c <= endCol && k.r >= startRow && k.r <= endRow) {
                                ctx.fillStyle = (this.gameOver && this.currentTurn === color) ? this.colors.mateHighlight : this.colors.checkHighlight;
                                ctx.fillRect(bx + k.c * cs, by + k.r * cs, cs, cs);
                            }
                        }
                    }
                }

                // 4. ĞŸĞ†Ğ”Ğ¡Ğ’Ğ†Ğ¢ĞšĞ Ğ¥ĞĞ”Ğ†Ğ’ (Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ Ğ”Ğ›Ğ¯ Ğ¡ĞšĞ›ĞĞ”ĞĞ˜Ğ¥ Ğ’Ğ•ĞšĞ¢ĞĞ Ğ†Ğ’)
                if (this.highlightedMoves.length > 0) {
                    const viewMinC = startCol - 1;
                    const viewMaxC = endCol + 1;
                    const viewMinR = startRow - 1;
                    const viewMaxR = endRow + 1;

                    ctx.fillStyle = "rgba(46, 204, 113, 0.8)"; 

                    this.highlightedMoves.forEach(move => {
                        if (move.type === 'point') {
                            // ĞœĞ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ñ‚Ğ¾Ñ‡Ğ¾Ğº
                            if (move.c >= viewMinC && move.c <= viewMaxC && move.r >= viewMinR && move.r <= viewMaxR) {
                                // Ğ”Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ°, Ñ‰Ğ¾Ğ± Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ½Ğµ Ğ¼Ğ°Ğ»ÑĞ²Ğ°Ğ»Ğ°ÑÑŒ Ğ·Ğ° Ğ¼ĞµĞ¶Ğ°Ğ¼Ğ¸ Ñ–Ğ³Ñ€Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»Ñ
                                if (move.c >= 0 && move.c < this.boardSize && move.r >= 0 && move.r < this.boardSize) {
                                    const hx = bx + move.c * cs + cs/2;
                                    const hy = by + move.r * cs + cs/2;
                                    ctx.beginPath();
                                    if (move.capture) {
                                        const capSize = Math.max(cs * 0.35, 4);
                                        ctx.fillStyle = "rgba(200, 50, 50, 0.7)";
                                        ctx.arc(hx, hy, capSize, 0, Math.PI * 2);
                                        ctx.fill();
                                        ctx.fillStyle = "rgba(46, 204, 113, 0.8)"; 
                                    } else {
                                        const dotSize = Math.max(cs * 0.18, 3);
                                        ctx.arc(hx, hy, dotSize, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }
                            }
                        } 
                        else if (move.type === 'ray') {
                            // ĞœĞ°Ğ»ÑĞ²Ğ°Ğ½Ğ½Ñ Ğ»Ñ–Ğ½Ñ–Ğ¹ (Rays)
                            // Ğ’Ğ˜ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ: ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¸Ğ¹ Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº tMin/tMax Ğ· ÑƒÑ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½ÑĞ¼ dx/dy != 1
                            let tMin = 1;         
                            let tMax = move.len;  

                            // Clipping X
                            if (move.dx !== 0) {
                                const t1 = (viewMinC - move.cx) / move.dx;
                                const t2 = (viewMaxC - move.cx) / move.dx;
                                // Ğ¡Ğ¾Ñ€Ñ‚ÑƒÑ”Ğ¼Ğ¾ t1, t2, Ğ±Ğ¾ Ğ¿Ñ€Ğ¸ Ğ²Ñ–Ğ´'Ñ”Ğ¼Ğ½Ğ¾Ğ¼Ñƒ dx Ğ²Ğ¾Ğ½Ğ¸ Ğ¼Ñ–Ğ½ÑÑÑ‚ÑŒÑÑ Ğ¼Ñ–ÑÑ†ÑĞ¼Ğ¸
                                tMin = Math.max(tMin, Math.ceil(Math.min(t1, t2)));
                                tMax = Math.min(tMax, Math.floor(Math.max(t1, t2)));
                            } else {
                                // Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ° Ğ»Ñ–Ğ½Ñ–Ñ: ÑĞºÑ‰Ğ¾ X Ğ¿Ğ¾Ğ·Ğ° ĞµĞºÑ€Ğ°Ğ½Ğ¾Ğ¼ - Ğ½Ğµ Ğ¼Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ½Ñ–Ñ‡Ğ¾Ğ³Ğ¾
                                if (move.cx < viewMinC || move.cx > viewMaxC) tMax = -1;
                            }

                            // Clipping Y
                            if (move.dy !== 0) {
                                const t1 = (viewMinR - move.cy) / move.dy;
                                const t2 = (viewMaxR - move.cy) / move.dy;
                                tMin = Math.max(tMin, Math.ceil(Math.min(t1, t2)));
                                tMax = Math.min(tMax, Math.floor(Math.max(t1, t2)));
                            } else {
                                // Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ° Ğ»Ñ–Ğ½Ñ–Ñ
                                if (move.cy < viewMinR || move.cy > viewMaxR) tMax = -1;
                            }

                            if (tMin <= tMax) {
                                for (let t = tMin; t <= tMax; t++) {
                                    const gridX = move.cx + t * move.dx;
                                    const gridY = move.cy + t * move.dy;
                                    
                                    // Ğ¡ÑƒĞ²Ğ¾Ñ€Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¼ĞµĞ¶ Ğ´Ğ¾ÑˆĞºĞ¸, Ñ‰Ğ¾Ğ± Ğ½Ğµ Ğ²Ğ¸Ğ»Ğ°Ğ·Ğ¸Ğ»Ğ¾ (ÑĞºÑ€Ñ–Ğ½ 1)
                                    if (gridX < 0 || gridX >= this.boardSize || gridY < 0 || gridY >= this.boardSize) continue;

                                    const hx = bx + gridX * cs + cs/2;
                                    const hy = by + gridY * cs + cs/2;
                                    const dotSize = Math.max(cs * 0.18, 3);
                                    
                                    ctx.beginPath();
                                    ctx.arc(hx, hy, dotSize, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        }
                    });
                }

                // 5. Ğ¢ĞµĞºÑÑ‚ Ñ– Ğ¡Ñ‚Ñ€Ñ–Ğ»ĞºĞ¸
                if (cs > 5) this.drawCustomArrows(ctx, cs, bx, by);
                if (cs > 25) {
                    const fontSize = Math.max(cs * 0.25, 12); ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; const labelX = bx - 5;
                    const rStart = Math.max(0, startRow); const rEnd = Math.min(this.boardSize, endRow);
                    for(let r = rStart; r < rEnd; r++) {
                        const rankVal = this.boardSize - r; const labelY = by + r*cs + cs/2;
                        if(labelY > 0 && labelY < height) { ctx.fillStyle = '#ccc'; ctx.fillText(rankVal.toString(), labelX, labelY); }
                    }
                    ctx.textAlign = 'center'; ctx.textBaseline = 'top'; const labelYBottom = by + this.boardSize*cs + 5;
                    const cStart = Math.max(0, startCol); const cEnd = Math.min(this.boardSize, endCol);
                    for(let c = cStart; c < cEnd; c++) {
                        const labelXPos = bx + c*cs + cs/2;
                        if(labelXPos > 0 && labelXPos < width) { ctx.fillStyle = '#ccc'; ctx.fillText(this.getFileLabel(c), labelXPos, labelYBottom); }
                    }
                }

                // 6. Ğ¤Ñ–Ğ³ÑƒÑ€Ğ¸
                const visibleCellsW = endCol - startCol;
                const visibleCellsH = endRow - startRow;
                const totalVisible = visibleCellsW * visibleCellsH;
                let skip = 1;
                if (totalVisible > 50000) skip = Math.ceil(Math.sqrt(totalVisible / 50000));
                
                const minDrawSize = 12;
                const drawSize = Math.max(cs, minDrawSize);

                const renderStartC = Math.max(0, startCol);
                const renderEndC = Math.min(this.boardSize, endCol);
                const renderStartR = Math.max(0, startRow);
                const renderEndR = Math.min(this.boardSize, endRow);

                for (let r = renderStartR; r < renderEndR; r += skip) {
                    for (let c = renderStartC; c < renderEndC; c += skip) {
                        if (this.isDraggingPiece && this.draggedPiece && this.draggedPiece.startC === c && this.draggedPiece.startR === r) continue;
                        const piece = this.getPiece(c, r);
                        if (!piece) continue;
                        const px = (bx + c * cs + cs/2) | 0;
                        const py = (by + r * cs + cs/2) | 0;
                        const sprite = this.getLowResSprite(piece.s, piece.c);
                        ctx.drawImage(sprite, px - drawSize/2, py - drawSize/2, drawSize, drawSize);
                    }
                }

                if (this.isDraggingPiece && this.draggedPiece) {
                    this.drawPiece(ctx, this.draggedPiece.data, this.mouse.x | 0, this.mouse.y | 0, Math.max(cs, 40));
                }
            }
            
            drawPiece(ctx, pieceData, x, y, size) {
                const sprite = this.getPieceSprite(pieceData.s, pieceData.c);
                const drawSize = size * 0.85;
                ctx.drawImage(sprite, (x - drawSize/2) | 0, (y - drawSize/2) | 0, drawSize | 0, drawSize | 0);
            }

            formatCount(n) {
                if (typeof n === 'number' && !isFinite(n)) return "ĞĞµÑĞºÑ–Ğ½Ñ‡ĞµĞ½Ğ½Ñ–ÑÑ‚ÑŒ";

                let bigN;
                try {
                    bigN = BigInt(n);
                } catch (e) {
                    return "ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ñ‡Ğ¸ÑĞ»Ğ°";
                }

                if (bigN < 1000000n) return bigN.toLocaleString('uk-UA');

                // 1. ĞÑ‚Ñ€Ğ¸Ğ¼ÑƒÑ”Ğ¼Ğ¾ Ñ€ÑĞ´Ğ¾Ğº Ñ‡Ğ¸ÑĞ»Ğ°
                let s = bigN.toString();
                let exp = s.length - 1; // Ğ¡Ñ‚ĞµĞ¿Ñ–Ğ½ÑŒ (ĞºÑ–Ğ»ÑŒĞºÑ–ÑÑ‚ÑŒ Ğ½ÑƒĞ»Ñ–Ğ²)

                // ĞŸĞ°ÑÑ…Ğ°Ğ»ĞºĞ° Ğ“ÑƒĞ³Ğ¾Ğ»
                if (exp >= 100 && exp < 103) return "10^" + exp + " (Ğ“ÑƒĞ³Ğ¾Ğ»)";

                // 2. Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€ -Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ğ° (N)
                // N = (Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº - 1) / 3
                // Ğ”Ğ»Ñ 10^445: N = (445 / 3) - 1 = 148 - 1 = 147
                let nIllion = (BigInt(exp) / 3n) - 1n;

                // 3. ĞœĞ°Ğ½Ñ‚Ğ¸ÑĞ° (ĞºÑ€Ğ°ÑĞ¸Ğ²Ğ¸Ğ¹ Ğ²Ğ¸Ğ²Ñ–Ğ´ Ğ¿ĞµÑ€ÑˆĞ¸Ñ… Ñ†Ğ¸Ñ„Ñ€, Ğ½Ğ°Ğ¿Ñ€. 9.99)
                let firstDigits = s.substring(0, 4);
                let mantissaVal = parseFloat(firstDigits) / 1000;
                let mod = exp % 3;
                if (mod === 1) mantissaVal *= 10;
                if (mod === 2) mantissaVal *= 100;

                // --- Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞšĞĞĞ’Ğ•Ğ¯-Ğ’Ğ•ĞšĞ¡Ğ›Ğ•Ğ Ğ (UKR WIKI) ---
                
                // ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº: ĞĞ´Ğ¸Ğ½Ğ¸Ñ†Ñ– -> Ğ”ĞµÑÑÑ‚ĞºĞ¸ -> Ğ¡Ğ¾Ñ‚Ğ½Ñ–
                // Ğ’Ğ¸Ğ½ÑÑ‚ĞºĞ¸ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ğ¹ Ğ±ÑƒĞºĞ² Ñ‚ÑƒÑ‚ ÑĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ñ– Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ½Ğ¾Ñ— Ñ€ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ—
                
                const ones = ["", "Ğ£Ğ½", "Ğ”ÑƒĞ¾", "Ğ¢Ñ€Ğµ", "ĞšĞ²Ğ°Ñ‚ÑƒĞ¾Ñ€", "ĞšĞ²Ñ–Ğ½", "Ğ¡ĞµĞºÑ", "Ğ¡ĞµĞ¿Ñ‚ĞµĞ½", "ĞĞºÑ‚Ğ¾", "ĞĞ¾Ğ²ĞµĞ¼"];
                const tens = ["", "Ğ”ĞµÑ†Ğ¸", "Ğ’Ñ–Ğ³Ñ–Ğ½Ñ‚Ñ–", "Ğ¢Ñ€Ğ¸Ğ³Ñ–Ğ½Ñ‚Ñ–", "ĞšĞ²Ğ°Ğ´Ñ€Ğ°Ğ³Ñ–Ğ½Ñ‚Ñ–", "ĞšĞ²Ñ–Ğ½ĞºĞ²Ğ°Ğ³Ñ–Ğ½Ñ‚Ñ–", "Ğ¡ĞµĞºÑĞ°Ğ³Ñ–Ğ½Ñ‚Ñ–", "Ğ¡ĞµĞ¿Ñ‚ÑƒĞ°Ğ³Ñ–Ğ½Ñ‚Ñ–", "ĞĞºÑ‚Ğ¾Ğ³Ñ–Ğ½Ñ‚Ñ–", "ĞĞ¾Ğ½Ğ°Ğ³Ñ–Ğ½Ñ‚Ñ–"];
                const hundreds = ["", "Ğ¦ĞµĞ½Ñ‚Ñ–", "Ğ”ÑƒÑ†ĞµĞ½Ñ‚Ñ–", "Ğ¢Ñ€ĞµÑ†ĞµĞ½Ñ‚Ñ–", "ĞšĞ²Ğ°Ğ´Ñ€Ñ–Ğ½Ğ³ĞµĞ½Ñ‚Ñ–", "ĞšĞ²Ñ–Ğ½Ğ³ĞµĞ½Ñ‚Ñ–", "Ğ¡ĞµÑÑ†ĞµĞ½Ñ‚Ñ–", "Ğ¡ĞµĞ¿Ñ‚Ğ¸Ğ½Ğ³ĞµĞ½Ñ‚Ñ–", "ĞĞºÑ‚Ñ–Ğ½Ğ³ĞµĞ½Ñ‚Ñ–", "ĞĞ¾Ğ½Ğ³ĞµĞ½Ñ‚Ñ–"];

                // Ğ¤ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ´Ğ»Ñ Ñ‡Ğ¸ÑĞ»Ğ° 1..999
                const getLatinPart = (num) => {
                    let val = Number(num);
                    if (val === 0) return "";
                    
                    let u = val % 10;             // ĞĞ´Ğ¸Ğ½Ğ¸Ñ†Ñ–
                    let t = Math.floor((val % 100) / 10); // Ğ”ĞµÑÑÑ‚ĞºĞ¸
                    let h = Math.floor(val / 100);        // Ğ¡Ğ¾Ñ‚Ğ½Ñ–

                    // Ğ¡Ğ¿ĞµÑ†Ñ–Ğ°Ğ»ÑŒĞ½Ñ– Ğ²Ğ¸Ğ¿Ğ°Ğ´ĞºĞ¸ (Ğ½Ğ°Ğ¿Ñ€Ğ¸ĞºĞ»Ğ°Ğ´, Ğ¢Ñ€Ğµ Ğ·Ğ¼Ñ–Ğ½ÑÑ”Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¢Ñ€ĞµÑ Ğ¿ĞµÑ€ĞµĞ´ Ğ¿ĞµĞ²Ğ½Ğ¸Ğ¼Ğ¸ Ğ±ÑƒĞºĞ²Ğ°Ğ¼Ğ¸),
                    // Ğ°Ğ»Ğµ Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ° ĞºĞ¾Ğ½ĞºĞ°Ñ‚ĞµĞ½Ğ°Ñ†Ñ–Ñ Ğ´Ğ°Ñ” Ğ·Ñ€Ğ¾Ğ·ÑƒĞ¼Ñ–Ğ»Ğ¸Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚.
                    
                    // ĞŸĞĞ Ğ¯Ğ”ĞĞš: ĞĞ´Ğ¸Ğ½Ğ¸Ñ†Ñ– + Ğ”ĞµÑÑÑ‚ĞºĞ¸ + Ğ¡Ğ¾Ñ‚Ğ½Ñ–
                    // 147 = 7(Ğ¡ĞµĞ¿Ñ‚ĞµĞ½) + 40(ĞšĞ²Ğ°Ğ´Ñ€Ğ°Ğ³Ñ–Ğ½Ñ‚Ñ–) + 100(Ğ¦ĞµĞ½Ñ‚Ñ–)
                    
                    let str = ones[u] + tens[t] + hundreds[h];
                    
                    // ĞšĞ¾ÑĞ¼ĞµÑ‚Ğ¸Ñ‡Ğ½Ğ° Ñ‡Ğ¸ÑÑ‚ĞºĞ° (Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ğ²Ñ–Ğ¹Ğ½Ğ¸Ñ… Ğ³Ğ¾Ğ»Ğ¾ÑĞ½Ğ¸Ñ…, ÑĞºÑ‰Ğ¾ Ñ‚Ñ€ĞµĞ±Ğ°, Ğ°Ğ»Ğµ Ğ´Ğ»Ñ Ğ³Ñ€Ğ¸ Ñ†Ğµ Ğ¾Ğº)
                    return str;
                };

                const buildName = (valBig) => {
                    // Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ– (Ğ·Ğ²Ğ¸Ñ‡Ğ½Ñ–) Ğ½Ğ°Ğ·Ğ²Ğ¸
                    if (valBig === 0n) return "ĞÑ–Ğ»";
                    if (valBig === 1n) return "ĞœÑ–Ğ»ÑŒ";
                    if (valBig === 2n) return "Ğ‘Ñ–Ğ»ÑŒ";
                    if (valBig === 3n) return "Ğ¢Ñ€Ğ¸Ğ»ÑŒ";
                    if (valBig === 4n) return "ĞšĞ²Ğ°Ğ´Ñ€Ğ¸Ğ»ÑŒ";
                    if (valBig === 5n) return "ĞšĞ²Ñ–Ğ½Ñ‚Ğ¸Ğ»ÑŒ";
                    if (valBig === 6n) return "Ğ¡ĞµĞºÑÑ‚Ğ¸Ğ»ÑŒ";
                    if (valBig === 7n) return "Ğ¡ĞµĞ¿Ñ‚Ğ¸Ğ»ÑŒ";
                    if (valBig === 8n) return "ĞĞºÑ‚Ğ¸Ğ»ÑŒ";
                    if (valBig === 9n) return "ĞĞ¾Ğ½Ñ–Ğ»ÑŒ";
                    if (valBig === 10n) return "Ğ”ĞµÑ†Ğ¸Ğ»ÑŒ";

                    // Ğ ĞµĞºÑƒÑ€ÑÑ–Ñ Ğ´Ğ»Ñ "ĞœÑ–Ğ»Ğ»Ñ–Ğ°" (Ñ‚Ğ¸ÑÑÑ‡ Ñ–Ğ»ÑŒĞ¹Ğ¾Ğ½Ñ–Ğ²)
                    let parts = [];
                    let tempVal = valBig;
                    let level = 0; // 0=Ğ½Ñ–Ñ‡Ğ¾Ğ³Ğ¾, 1=Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°, 2=Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°...

                    while (tempVal > 0n) {
                        let chunk = tempVal % 1000n;
                        
                        if (chunk > 0n) {
                            let latin = getLatinPart(chunk);
                            
                            // Ğ”Ğ¾Ğ´Ğ°Ñ”Ğ¼Ğ¾ ÑÑƒÑ„Ñ–ĞºÑ "Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°"
                            // 1 Ñ€Ñ–Ğ²ĞµĞ½ÑŒ = "Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°", 2 = "Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°"
                            let suffix = "";
                            for(let i=0; i<level; i++) suffix += "Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°";
                            
                            // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ñ€Ñ–Ğ²Ğ½Ğ¾ 1000 (chunk==1 Ğ½Ğ° Ñ€Ñ–Ğ²Ğ½Ñ– 1), ĞºĞ°Ğ¶ĞµĞ¼Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ "ĞœÑ–Ğ»Ğ»Ñ–Ğ°", Ğ° Ğ½Ğµ "Ğ£Ğ½Ğ¼Ñ–Ğ»Ğ»Ñ–Ğ°"
                            if (chunk === 1n && level > 0) latin = "";

                            parts.unshift(latin + suffix);
                        }
                        tempVal = tempVal / 1000n;
                        level++;
                    }
                    return parts.join("");
                };

                let name = buildName(nIllion);

                // ĞĞ±Ñ€Ñ–Ğ·ĞºĞ° Ğ´Ğ»Ñ UI, ÑĞºÑ‰Ğ¾ Ğ½Ğ°Ğ·Ğ²Ğ° Ğ´Ğ¾Ğ²ÑˆĞ° Ğ·Ğ° 60 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ–Ğ²
                if (name.length > 60) {
                    let start = name.substring(0, 25);
                    let end = name.substring(name.length - 25);
                    return mantissaVal.toFixed(2) + " " + start + "..." + end + "Ğ¹Ğ¾Ğ½Ñ–Ğ²"; // Ğ¡ĞºĞ¾Ñ€Ğ¾Ñ‡ĞµĞ½Ğ¾
                }

                return mantissaVal.toFixed(2) + " " + name + "Ğ¹Ğ¾Ğ½Ñ–Ğ²";
            }

            updatePieceCounts() {
                let w = 0n;
                let b = 0n;
                
                // 1. ĞĞ¢Ğ Ğ˜ĞœĞĞĞĞ¯ Ğ ĞĞ—ĞœĞ†Ğ Ğ£ (ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ Ğ’ĞĞ–Ğ›Ğ˜Ğ’Ğ)
                let rawInput = document.getElementById('boardSize').value.trim();
                let bs = 32n; // Ğ—Ğ° Ğ·Ğ°Ğ¼Ğ¾Ğ²Ñ‡ÑƒĞ²Ğ°Ğ½Ğ½ÑĞ¼

                try {
                    if (!rawInput) {
                        bs = 32n;
                    } 
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ½Ğ°ÑƒĞºĞ¾Ğ²Ğ¸Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ (1e+200)
                    else if (rawInput.toLowerCase().includes('e')) {
                        let parts = rawInput.toLowerCase().split('e');
                        let base = parts[0];
                        let power = parseInt(parts[1].replace('+',''));
                        // Ğ¡Ñ‚Ğ²Ğ¾Ñ€ÑÑ”Ğ¼Ğ¾ Ñ€ÑĞ´Ğ¾Ğº: 1 + Ğ½ÑƒĞ»Ñ–
                        let zeros = '0'.repeat(power);
                        // Ğ†Ğ³Ğ½Ğ¾Ñ€ÑƒÑ”Ğ¼Ğ¾ Ğ´Ñ€Ñ–Ğ±Ğ½Ñƒ Ñ‡Ğ°ÑÑ‚Ğ¸Ğ½Ñƒ Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ»Ñ Ğ½Ğ°Ğ´Ñ–Ğ¹Ğ½Ğ¾ÑÑ‚Ñ– Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ– BigInt
                        let baseInt = Math.floor(parseFloat(base)).toString();
                        bs = BigInt(baseInt + zeros);
                    } 
                    // Ğ¯ĞºÑ‰Ğ¾ Ñ†Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ´Ğ¾Ğ²Ğ³Ğ¸Ğ¹ Ñ€ÑĞ´Ğ¾Ğº Ñ†Ğ¸Ñ„Ñ€ (999999....)
                    else {
                        bs = BigInt(rawInput);
                    }
                } catch(e) {
                    console.error("ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ñ‡Ğ¸ÑĞ»Ğ°:", e);
                    bs = 32n;
                }

                // 2. ĞĞ‘Ğ§Ğ˜Ğ¡Ğ›Ğ•ĞĞĞ¯ ĞšĞ†Ğ›Ğ¬ĞšĞĞ¡Ğ¢Ğ† Ğ¤Ğ†Ğ“Ğ£Ğ 
                if (this.virtualGen) {
                    let rows = 0n;
                    if (this.virtualGen === 'chess960') {
                        rows = 2n; 
                    } else {
                        let percent = BigInt(Math.floor(this.virtualProps.percent));
                        rows = (bs * percent) / 100n;
                        if (this.virtualGen !== 'checkers' && rows < 2n) rows = 2n;
                    }
                    
                    let totalBase = bs * rows; 
                    if (this.virtualGen === 'checkers') totalBase = totalBase / 2n;

                    w = totalBase;
                    b = totalBase;
                }

                // ĞšĞ¾Ñ€ĞµĞºÑ†Ñ–Ñ Ñ€ÑƒÑ‡Ğ½Ğ¸Ñ… Ğ·Ğ¼Ñ–Ğ½ (Grid)
                for (const [key, val] of this.grid) {
                    if (val !== GRID_VOID) {
                        const id = val & 0xFFFF;
                        const p = this.palette[id - 1];
                        if (p.c === 'w') w = w + 1n;
                        else if (p.c === 'b') b = b + 1n;
                    }
                }

                // 3. Ğ’Ğ˜Ğ’Ğ†Ğ”
                const totalSquaresBig = bs * bs;
                
                // Ğ Ğ°Ñ…ÑƒÑ”Ğ¼Ğ¾ ÑÑ‚ĞµĞ¿Ñ–Ğ½ÑŒ (10^X) Ğ´Ğ»Ñ Ğ´Ğ¾Ğ²Ñ–Ğ´ĞºĞ¸
                let sLen = totalSquaresBig.toString().length - 1;

                const html = `
                    <div style="margin-bottom: 4px; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 4px; font-size: 13px; color: #333;">
                         ğŸ“ ĞŸĞ»Ğ¾Ñ‰Ğ°: <b>${this.formatCount(totalSquaresBig)}</b> 
                         <span style="font-size:10px;color:#777;display:block">(10^${sLen})</span>
                         <div style="font-size:10px; color:#555; word-break: break-all; margin-top:3px; max-height:60px; overflow-y:auto; background:rgba(0,0,0,0.03); padding:2px; border-radius:4px;">
                            ${totalSquaresBig.toString()}
                         </div>
                    </div>
                    <span style="color:#555; font-weight:bold;">Ğ¤Ñ–Ğ³ÑƒÑ€: ${this.formatCount(w+b)}</span> 
                    (<span style="color:#27ae60">Ğ‘: ${this.formatCount(w)}</span> | 
                    <span style="color:#c0392b">Ğ§: ${this.formatCount(b)}</span>)
                `;
                document.getElementById('count').innerHTML = html;
            }

            updateUI() {
                // Ğ’Ğ¸ĞºĞ»Ğ¸ĞºĞ°Ñ”Ğ¼Ğ¾ Ğ½Ğ°ÑˆÑƒ Ğ½Ğ¾Ğ²Ñƒ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ¿Ñ–Ğ´Ñ€Ğ°Ñ…ÑƒĞ½ĞºÑƒ
                this.updatePieceCounts();
            }

            animate() {
                const now = performance.now();
                if (Math.random() < 0.05) document.getElementById('fps').innerText = Math.round(1000 / (now - this.renderTime || 16));
                this.renderTime = now;
                this.update();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }

        const game = new SmoothChess();
    </script>
</body>
</html>
